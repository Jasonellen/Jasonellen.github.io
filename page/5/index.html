<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <meta name="baidu-site-verification" content="ggTdcuuNh2" />
  <link rel="dns-prefetch" href="http://Jasonellen.github.io">
  <title>奋斗蚁🐜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="奋斗蚁🐜">
<meta property="og:url" content="http://Jasonellen.github.io/page/5/index.html">
<meta property="og:site_name" content="奋斗蚁🐜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="奋斗蚁🐜">
  
    <link rel="alternative" href="/atom.xml" title="奋斗蚁🐜" type="application/atom+xml">
  
  
    <link rel="icon" href="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jasonellen</a></h1>
		</hgroup>

		
		<p class="header-subtitle">前端拼搏中的小小蚁🐜</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">文章列表</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="//github.com/Jasonellen/" title="github">github</a>
		        
			</div>
		</nav>
	</header>			
</div>



      <div class="ball" style=' width:100px;
            height:100px;
            position: absolute;
            bottom:0;
            left:200px;
            background: url(http://img3.imgtn.bdimg.com/it/u=2342940863,4159168232&fm=23&gp=0.jpg) no-repeat;
            background-size:contain;
            border-radius:50%;
      '>
      </div>

        <script>
            var ball = document.querySelector(".ball");
            gravBall(ball);

            function gravBall(obj){
                var timer = null;
                var speedX =0, speedY=0,x=0,y=0;
                var gapX =0, gapY=0;

                // obj.onmousedown = down;
                addHandler(obj,'mousedown',down);
                addHandler(obj,'mouseup',up);

                function down(ev){           
                    clearInterval(timer); 
                    var ev = ev || window.event;
                    gapX = ev.clientX - obj.offsetLeft;
                    gapY = ev.clientY - obj.offsetTop;
                    addHandler(document,'mousemove',move);    
                }
                function up(){
                    var currentX=0,currentY=0,l=0,t=0;
                    removeHandler(document,'mousemove',move)
                    clearInterval(timer); 
                    timer = setInterval(function(){
                        speedY +=3;  //一直有一个Y方向的增加，仿重力
                        currentX = window.innerWidth - obj.offsetWidth;
                        currentY = window.innerHeight - obj.offsetHeight;
                        l = obj.offsetLeft + speedX;
                        t = obj.offsetTop + speedY;
                        //speedY +=3;  //放在这里就是先判断再+3，根本停不下来
                        if(l > currentX){
                            speedX *= -0.8;
                            l =currentX;
                        }
                        if(l < 0){
                            speedX *= -0.8;
                            l = 0;
                        }
                        if(t > currentY){
                            speedY *= -0.8;
                            speedX *= 0.8;
                            t = currentY;
                        }
                        if(t < 0){
                            speedY *= -0.8;
                            speedX *= 0.8;
                            t = 0;
                        }
                        if( Math.abs(t-currentY)<1 && Math.abs(speedY)<1.5 && Math.abs(speedX)<1.5){
                            clearInterval(timer);
                        }
                        obj.style.left = l  + "px";
                        obj.style.top = t  + "px";
                    },30)
                }

                function move(ev){
                    var ev = ev || window.event;
                    //难点一，记录当前速度 是最后一次的offsetLeft减去上一次的offsetLeft
                    speedX = ev.clientX - x - gapX;
                    speedY = ev.clientY - y - gapY;
                    //记录本次的offsetLeft作为下一次移动的的上一次的offsetLeft；
                    x = obj.offsetLeft;
                    y = obj.offsetTop;
                    var evX = ev.clientX;
                    var evY = ev.clientY;
                    if(ev.clientX<gapX || ev.clientX>window.innerWidth-gapX || ev.clientY<0 || ev.clientY>window.innerHeight){
                        up();
                    }
                    obj.style.left = evX - gapX  + "px";
                    obj.style.top = evY - gapY  + "px";
                }
            }


            function addHandler(element,type,handler){
                if(element.addEventListener){//检测是否为DOM2级方法
                    element.addEventListener(type, handler, false);
                }else if (element.attachEvent){//检测是否为IE级方法
                    element.attachEvent("on" + type, handler);
                } else {//检测是否为DOM0级方法
                    element["on" + type] = handler;
                }
            }
             function removeHandler(element, type, handler){
                if (element.removeEventListener){
                    element.removeEventListener(type, handler, false);
                } else if (element.detachEvent){
                    element.detachEvent("on" + type, handler);
                } else {
                    element["on" + type] = null;
                }
            }  
        </script>  
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Jasonellen</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Jasonellen</h1>
			</hgroup>
			
			<p class="header-subtitle">前端拼搏中的小小蚁🐜</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="//github.com/Jasonellen/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-微信小程序实战，从入门到弃坑（转）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/03/微信小程序实战，从入门到弃坑（转）/">微信小程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="微信小程序实战，从入门到弃坑（转）"><a href="#微信小程序实战，从入门到弃坑（转）" class="headerlink" title="微信小程序实战，从入门到弃坑（转）"></a>微信小程序实战，从入门到弃坑（转）</h1><p><a href="http://www.jianshu.com/p/4433d46e6235" target="_blank" rel="external">原文链接</a></p>
<p>最近集中开发了两款微信小程序，分别是好奇心日历（每天一条辞典+一个小投票）和好奇心日报（轻量版），直接上图：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-6c7ccf0f8e3019b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>本文将结合具体的实战经验，主要介绍微信小程序的基础知识、开发中遇到的难点、项目的架构设计、最佳实践以及踩过的坑。<strong>文章内容较多，如果想看架构设计和躲坑技巧，请直接浏览后面的正文</strong>，简书没有目录，也挺伤感的。</p>
<p>值得再次声明的是：<strong>微信小程序的内容部分是hybrid模式，并非原生</strong>，所以性能并不好，绑定的tap事件也有明显的延迟。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-ef6d4c647e8b188c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图<em><code>每一个由边框围起来的部分，都是一个最小粒度的原生view</code></em>可以看出，整个微信小程序的内容部分，就是一个原生view。</p>
<h2 id="小程序有哪些基础知识？"><a href="#小程序有哪些基础知识？" class="headerlink" title="小程序有哪些基础知识？"></a>小程序有哪些基础知识？</h2><p>一个完整的微信小程序是由一个App实例和多个Page实例构成，其中App实例表示该小程序应用，多个Page表示该小程序的多个页面。<br>此外，微信小程序并没有提供自定义组件的方式，这就导致微信小程序在开发较复杂应用时，可能会比较艰难。</p>
<p>微信小程序本身很简单，和一个模板语言的难度几乎相当，翻翻官方教程就可以开始动手搞。</p>
<p>我也建议大家先动起来，然后再细致啃啃官方文档。由于微信官方文档仍在不断大幅更新中，所以务必查看最新官方文档。</p>
<p>微信小程序的基础知识主要分为以下几个部分：</p>
<ul>
<li>两种配置文件 &amp;&amp; 两个核心函数</li>
<li>WXML模板语法，页面渲染</li>
<li>页面间的跳转</li>
<li>交互事件</li>
<li>官方组件和官方API</li>
</ul>
<h3 id="两种配置文件-amp-amp-两个核心函数"><a href="#两种配置文件-amp-amp-两个核心函数" class="headerlink" title="两种配置文件 &amp;&amp; 两个核心函数"></a>两种配置文件 &amp;&amp; 两个核心函数</h3><p><code>app.json</code><strong>应用的全局配置文件</strong></p>
<p><code>app.json</code>是针对微信小程序的全局配置，主要包含以下几个配置：</p>
<ul>
<li>pages：页面路径的数组，表示小程序要加载的所有页面，其中数组第一项代表小程序的初始页面。</li>
<li>window：微信原生功能，定制化不强。可设置小程序的状态栏、导航条、标题以及窗口背景色。</li>
<li>tabBar：微信原生功能，定制化不强。适用于常规的Tab应用，Tab栏可置于顶部或底部；tabBar是一个数组，仅支持2-5个tab。</li>
<li>networkTimeout：配置小程序网络请求的超时时间。</li>
<li>debug：调试模式开关，开发模式下建议开启，正式发布别忘了关闭。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1158202-719f23c56cd215ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>page.json</code> <strong>页面的全局配置文件</strong></p>
<p>除了上面提到的全局配置，每个页面还可以单独配置page.json，page.json会覆盖app.json中的配置，并只对当前页面生效。</p>
<p>page.json只能对window配置，有两个比较有用的配置项分别是：</p>
<ul>
<li>enablePullDownRefresh：是否开启下拉刷新</li>
<li>disableScroll：只能在page.json配置，禁止页面上下滚动，猜测可以实现完美滑屏滑动（未验证）</li>
</ul>
<p><code>App()</code> <strong>小程序注册入口，全局唯一</strong></p>
<p>App()用来注册一个小程序，全局只有一个，全局的数据也可以放到这里面来操作。</p>
<pre><code>// 注册微信小程序，全局只有一个
let appConfig = {
    // 小程序生命周期的各个阶段
    onLaunch: function(){},
    onShow: function(){},
    onHide: function(){},
    onError: function(){},

    // 自定义函数或者属性
    ...
};
App(appConfig);

// 在别的地方可以获取这个全局唯一的小程序实例
const app = getApp();
</code></pre><p>小程序并没有提供销毁的方式，所以只有当小程序进入后台一定时间、或者系统资源占用过高的时候，才会被真正的销毁。</p>
<p><code>Page()</code> <strong>页面注册入口</strong></p>
<p>Page()用来注册一个页面，维护该页面的生命周期以及数据。</p>
<pre><code>// 注册微信小程序，全局只有一个
let pageConfig = {
    data: {},
    // 页面生命周期的各个阶段
    onLoad: function(){},
    onShow: function(){},
    onReady: function(){},
    onHide: function(){},
    onUnload: function(){},
    onPullDownRefresh: function(){},
    onReachBottom: function(){},
    onShareAppMessage: function(){},

    // 自定义函数或者属性
    ...
};
Page(pageConfig);

// 获取页面堆栈，表示历史访问过的页面，最后一个元素为当前页面
const page = getCurrentPages();
</code></pre><p>关于各个生命周期的细节以及流程，参考下图，可以细细品味：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-481a42f6d299528e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>app.json</code> 和 <code>page.json</code> 维护了应用和页面的配置属性。<code>App()</code> 和 <code>Page()</code> 维护了应用和页面的各个生命周期以及数据。</p>
<p>那么，<code>APP</code> 和 <code>Page</code> 如何将数据传递到页面呢？页面又是如何渲染呢？</p>
<h3 id="WXML模板语法，页面渲染"><a href="#WXML模板语法，页面渲染" class="headerlink" title="WXML模板语法，页面渲染"></a>WXML模板语法，页面渲染</h3><p>小程序虽然是hybrid模式，但并不使用HTML渲染，而是全部通过自定义标签来渲染页面。这样做的好处我不清楚，但问题却不少：不能跨浏览器、富文本解析困难，iframe视频不支持，没办法外链跳转。<br>和所有的模板语言一样，WXML支持数据绑定、条件渲染、循环、模块化等功能。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>在 WXML 中可以使用<code>双大括号</code>将 <code>Page</code> 的变量或者表达式包裹起来，实现数据绑定，举个例子：</p>
<pre><code>// 将message的值渲染到view中
&lt;view&gt; {{ message }} &lt;/view&gt;

// 将id的值渲染到view的id属性中
&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;

// 根据isSelected的值，输出不同的class
&lt;view class=&quot;{{isSelected ? 'selected' : ''}}&quot;&gt; HelloWorld &lt;/view&gt;

// 结合template，可以传入更复杂的数据
&lt;template is=&quot;objectCombine&quot; data=&quot;{{...article, categoty, tag: '埃隆马斯克'}}&quot;&gt;&lt;/template&gt;
</code></pre><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>循环渲染，适合遍历数据输出多段 WXML，举个例子：</p>
<pre><code>// wx:for 表示需要遍历的数据
// wx:key 使用唯一的字段来标识，有利于提升性能
// wx:for-index 表示数组的下标
// wx:for-item 表示数组的元素
&lt;view wx:for=&quot;{{[{id:1, message: 'HelloWorld1'}, {id:2, message: 	'HelloWorld2'}]}}&quot; 
    wx:key=&quot;id&quot; 
    wx:for-index=&quot;idx&quot; 
    wx:for-item=&quot;item&quot;&gt;
    {{idx}}: {{item.message}}
&lt;/view&gt;
</code></pre><p><code>wx:key</code> 有利于提升重新渲染时的效率，建议添加</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>WXML的模块化，可以让我们复用一些wxml片段，还挺重要的，举个例子：</p>
<pre><code>// 引入wxml模块
&lt;import src=&quot;../../components/grid-article/index&quot;&gt;&lt;/import&gt;

&lt;block wx:for=&quot;{{posts}}&quot; wx:for-item=&quot;post&quot; wx:key=&quot;id&quot;&gt;
    // 调用wxml模块，同时可传入数据
    &lt;template is=&quot;grid-article&quot; data=&quot;{{post}}&quot;&gt;&lt;/template&gt;
&lt;/block&gt;
</code></pre><p>数据和页面的状态是一一对应的，微信小程序中，设计一份好的数据结构，对于Page和页面的代码都有很大的帮助。<br>微信小程序并不支持a标签，那么多个页面之间如何跳转呢？</p>
<h3 id="页面间的跳转"><a href="#页面间的跳转" class="headerlink" title="页面间的跳转"></a>页面间的跳转</h3><p>小程序以栈的形式维护了历史访问的所有页面，并提供了多种页面间的跳转方式；结合前文提到的App()和Page()的各个生命周期，不同的跳转方式和不同的生命周期关联，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-cf7de8f472d6a147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>举个例子，Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）<br><img src="http://upload-images.jianshu.io/upload_images/1158202-80ab7b1ea2766468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>好了，APP和Page负责维护小程序的生命周期和数据，模板负责接受数据完成页面渲染，页面间的跳转负责将多个页面贯穿起来，那么，如何发生交互呢？接下来我们简单说一下事件。</p>
<h3 id="交互事件"><a href="#交互事件" class="headerlink" title="交互事件"></a>交互事件</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><pre><code>// bindtap 和 catchtap的区别在于
// bindtap 不会阻止事件冒泡
// catchtap会冒泡事件冒泡
&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;
&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; catchtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;

// 绑定的函数tapName只是一个函数名称，默认接受一个event对象作为参数
Page({
    tapName: function(event) {
        console.log(event)
        }
    })
</code></pre><p>接下来，另一个问题是：<code>tapName()</code> 如何接受自定义参数呢？</p>
<h4 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h4><p>传递自定义参数主要有两种方式：</p>
<p>第一种：将参数绑定到wxml标签上，然后通过event.target.dataset获取</p>
<p>第二种：直接使用Page.data或其他数据</p>
<p>到目前为止，一个完整的小程序框架已经实现</p>
<ul>
<li>小程序只有逻辑和视图两部分，而且不提供组件化解决方案</li>
<li>逻辑主要包含四个东西：两个配置文件 &amp;&amp; 两个核心函数</li>
<li>视图很简单，模板语法稍微有点不完善</li>
<li>逻辑层的数据绑定到视图层是由小程序框架自动支持，数据变化，视图自动变化</li>
<li>视图层到逻辑层的，主要通过事件的方式来实现</li>
<li>视图之间的跳转，小程序也提供了它自己的方式，并不支持a标签</li>
</ul>
<p>框架有了，小程序还提供了官方组件以便快速开发，提供了API以增强应用能力。</p>
<p>这块就不具体介绍了，也需要注意小程序的官方文档还在大规模的更新中，务必查看最新版</p>
<p>官方组件：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161222" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161222</a></p>
<p>官方API：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222</a></p>
<p>微信小程序的基础知识就是以上的内容，并不复杂，边查边写都可以。</p>
<p>接下来会介绍更进阶一些的内容，内容主要结合好奇心日报这个小程序项目，先看效果：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-50ade533c922cb0d.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h2 id="如何设计微信小程序？"><a href="#如何设计微信小程序？" class="headerlink" title="如何设计微信小程序？"></a>如何设计微信小程序？</h2><h3 id="构建系统-amp-amp-目录结构"><a href="#构建系统-amp-amp-目录结构" class="headerlink" title="构建系统 &amp;&amp; 目录结构"></a>构建系统 &amp;&amp; 目录结构</h3><h4 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h4><p>由于微信小程序本身对工程化几乎没有任何的支持，所以动手搭建一份：<a href="https://github.com/qixiuss/wxapp-redux-starter" target="_blank" rel="external">wxapp-redux-starter</a>。</p>
<p><strong>使用gulp进行编译构建，主要功能包括：</strong></p>
<ul>
<li>集成了<code>Redux</code>，数据管理更方便</li>
<li>开发过程中，使用<code>xml</code>取代<code>wxml</code>，对开发工具更友好</li>
<li>开发过程中，使用<code>less</code>取代<code>wxss</code>，功能更强大</li>
<li>引入<code>es-promise</code>，以便可以创建并使用<code>Promise</code></li>
<li>添加<code>promisify</code>工具函数，可以便捷的将官方<code>Api</code>转换成<code>Pormise</code>模式</li>
<li>引入<code>normalizr</code>，可以将数据扁平化，更方便进行数据管理</li>
<li>引入<code>babel</code>自动进行<code>ES2015</code>特性转换</li>
<li>对<code>wxml/wxss/js/img</code>压缩，相对开发者工具提供的压缩，会减小一丢丢体积。<h4 id="目录结构设计"><a href="#目录结构设计" class="headerlink" title="目录结构设计"></a>目录结构设计</h4>按照pages、components、redux、vendors/libs、images几个核心部分拆分，直接上目录。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-6583ba0c0928481c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>dist目录：构建输出的文件存放到这个目录。</li>
<li>src目录：开发模式的文件，包括app、页面、组件、图片等静态资源、辅助函数库、Redux数据管理器、第三方工具库。</li>
<li>gulpfile.js：不用多说，gulp构建任务的入口文件。</li>
<li>package.json：不用多说，管理者构建任务的依赖。</li>
<li>thirdPlugins：由于小程序并不支持直接使用npm，我们可以自主拉取构建，然后拷贝到vendors里，有时候需要简单修改。</li>
</ul>
<p>构建系统会将src目录下的代码，编译处理后输出到dist目录，小程序开发工具只需要引入dist目录即可。</p>
<p>有了构建工具，代码开发起来更舒心，但很快就遇到另外一个糟心的问题，那就是如何管理散布在各处的数据？<br>要知道，微信小程序并没有提供组件化方案，所以<strong>把组件写成无状态组件</strong>特别适合，但是页面管理太多数据很凌乱，有什么办法可以将数据集中管理呢？</p>
<h3 id="引入Redux进行数据集中管理"><a href="#引入Redux进行数据集中管理" class="headerlink" title="引入Redux进行数据集中管理"></a>引入Redux进行数据集中管理</h3><p>关于Redux相关的内容，之前有三篇博客详细介绍，有兴趣的建议先移步：</p>
<ul>
<li>Redux整体介绍：<a href="http://www.jianshu.com/p/d296a8c34936" target="_blank" rel="external">Redux 入门教程，应用的状态管理器</a></li>
<li>对State进行横向和纵向拆分设计：<a href="http://www.jianshu.com/p/ba8654cb77b6" target="_blank" rel="external">State设计，Redux 开发第一步</a></li>
<li>Reducer的最佳实践：<a href="http://www.jianshu.com/p/938f8121ba0f" target="_blank" rel="external">Reducer 最佳实践，Redux 开发最重要的部分</a></li>
</ul>
<p>这儿就简单介绍一下，如何在微信小程序中引入Redux 以及 如何将微信小程序和Redux连接起来。</p>
<h4 id="引入Redux"><a href="#引入Redux" class="headerlink" title="引入Redux"></a>引入Redux</h4><p>直接在 <code>thirdPlugins</code>目录 运行 <code>yarn add redux / npm install redux</code>，等<code>redux</code>安装好了之后，将 <code>dist</code>目录 的 <code>redux.js/redux.min.js</code> 拷贝到<code>vendors</code>目录中。<br>需要进行简单的修改才能使用，将压缩版208行代码 <code>(i)</code> 改成 <code>(i || {})</code>即可。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-143fad06f8c52bca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="连接微信小程序和Redux"><a href="#连接微信小程序和Redux" class="headerlink" title="连接微信小程序和Redux"></a>连接微信小程序和Redux</h4><p>将Redux和微信小程序连接起来才会真的有用处。找了个现成的方案<a href="https://github.com/charleyw/wechat-weapp-redux" target="_blank" rel="external">charleyw/wechat-weapp-redux</a>，可以直接使用。</p>
<p>一个完整的Redux方案如下，包括：将Store注入到App中、将state的数据和reducer的方法映射到Page中。一旦state发生变化，Page.data也会更新，进而触发页面的重新渲染。</p>
<pre><code>// APP的逻辑
import { createStore, applyMiddleware, combineReducers } from &apos;./vendors/redux.js&apos;;
import thunk from &apos;./vendors/redux-thunk.js&apos;;
import { Provider } from &apos;./vendors/weapp-redux.js&apos;;

// import reducers
import { rootReducer } from &apos;./redux/reducer.js&apos;;

// 从Storage读取数据
let entities = wx.getStorageSync(&apos;entities&apos;) || {};

const store = createStore(
    rootReducer, {
        // 将读取的数据注入到store中
        entities: entities
    },
    applyMiddleware(
        thunk
    )
);

let appConfig = {
    onLaunch: function() {},

    onHide: function() {
        let state = store.getState(),
            cacheEntities = {};

        // 体积大于2M，直接清空，防止缓存占用过大体积
        if (sizeof(state.entities) &lt;= 2 * 1024 * 1024) {
            cacheEntities = state.entities;
        }

        // 退出时将entities缓存下来
        wx.setStorageSync(&apos;entities&apos;, cacheEntities);
    }
};

App(Provider(store)(appConfig));
// Page的逻辑
import { connect } from &apos;../../vendors/weapp-redux.js&apos;;

import { fetchArticleDetail } from &apos;../../redux/models/articles.js&apos;;

let pageConfig = {
    data: {
        id: 0,
        postsHash: {}
    },
    onLoad: function(params) {
        var me = this,
            { id, postsHash } = me.data;

        me.fetchArticleDetail(id, function() {}, function() {});
    }
}

// 考虑到列表页已经获取到部分数据
// 为了在详情页第一时间利用这些数据，我们将params传入
// 防止以后需要用data的数据，我们将data也一并传入
let mapStateToData = (state, params, data) =&gt; {
    return {
        id: params.id,
        postsHash: state.entities.posts
    }
};

let mapDispatchToPage = dispatch =&gt; ({
    fetchArticleDetail: (id, callback, errorCallback) =&gt; dispatch(fetchArticleDetail(id, callback, errorCallback)),
});

pageConfig = connect(mapStateToData, mapDispatchToPage)(pageConfig)
Page(pageConfig);
</code></pre><p>需要注意的是，为了保证第一时间能拿到数据，我们对<code>wechat-weapp-redux/src/connect.js</code>做了优化调整，修改的地方如下</p>
<pre><code>// 修改了以下两个函数
// 可以对照原项目修改，也可以直接拿我的模板项目使用
function handleChange(options) {
    if (!this.unsubscribe) {
        return
    }

    const state = this.store.getState();
    // 将data也一并传入
    const mappedState = mapState(state, options, this.data);
    if (!this.data || shallowEqual(this.data, mappedState)) {
        return;
    }
    this.setData(mappedState)
}

function onLoad(options) {
    this.store = app.store;
    if (!this.store) {
        warning(&quot;Store对象不存在!&quot;)
    }
    if (shouldSubscribe) {
        this.unsubscribe = this.store.subscribe(handleChange.bind(this, options))
        // 第一次处理的时候也传入options
        handleChange.apply(this, [options])
    }
    if (typeof _onLoad === &apos;function&apos;) {
        _onLoad.call(this, options)
    }
}
</code></pre><h4 id="引入Redux的优势"><a href="#引入Redux的优势" class="headerlink" title="引入Redux的优势"></a>引入Redux的优势</h4><p>引入Redux的好处在于可以集中管理数据，并且让Page的代码保持绝对简单，让所有的组件都变成简单可复用的无状态组件。<br>此外，Redux还让离线缓存更方便，数据复用更简单。</p>
<p>引入Redux解决了数据散布各处的问题，参考Redux的管理思路，我们构思了一套简单组件化解决方案：假设我们把所有的组件都设计成无状态组件，而组件的数据来源是Page.data，那么我们是否也可以将组件数据的管理抽离到一个单独的文件中呢？接下来讲讲我们使用的简单的组件化解决方案。</p>
<h4 id="简单的组件化解决方案"><a href="#简单的组件化解决方案" class="headerlink" title="简单的组件化解决方案"></a>简单的组件化解决方案</h4><p>这份组件化解决方案的核心就在于把组件的关联数据集中起来管理，只暴露出默认数据和数据的操作函数。</p>
<p>比如好奇心日报的详情页有个Toolbar，该Toolbar并不复杂，主要提供返回和点赞功能，其中点赞功能只对文章详情有效，研究所详情页会将点赞功能隐藏。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-2d1dc48a1ecaf25b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>// components/toolbar/index.js 文件
// 仅提供默认值，不需要和page中的数据保持同步
let defaultData = {
    isPraised: false,
    praiseCount: 0,
    showPraiseIcon: false,
};
// 切换点赞状态
function togglePraise() {
    // 本质上是修改Page.data中的toolbarData
}
// 返回上一级
function navigateToBack(wx) {
    wx.navigateBack({ delta: 1 });
}
module.exports = {
    defaultData,

    togglePraise,
    navigateToBack
}

// pages/articles/show.js 文件
import Toolbar from &apos;../../components/toolbar/index.js&apos;;

let pageConfig = {
    data: {
        // 其他数据
        id: 0,
        // Toolbar数据，单独的一份数据，便于维护
        toolbarData: Toolbar.defaultData
    },
    // 点赞或者取消赞
    togglePraise: function() {
        let me = this;

        Toolbar.togglePraise.call(me);
    }
}

// 这儿的组件化并不是真正的组件化
// 而是将组件相关的逻辑和函数抽离到单独的文件中，保证Page代码清晰。
// 同时也为这部分组件逻辑复用提供了可能。
// 本质上来说，抽离出的组件都是“操作Page.data的工具函数”，他们也是纯函数，和“操作state的reducer”类似。
</code></pre><p>这种Redux的组件化解决方案既简单又好用，保持一定的代码规范即可。这样设计当然是为了复用，同时也让Page的逻辑保持极度精简。</p>
<h2 id="开发中遇到了哪些难点-amp-amp-微信小程序有多少坑？"><a href="#开发中遇到了哪些难点-amp-amp-微信小程序有多少坑？" class="headerlink" title="开发中遇到了哪些难点 &amp;&amp; 微信小程序有多少坑？"></a>开发中遇到了哪些难点 &amp;&amp; 微信小程序有多少坑？</h2><p>微信小程序目前的确算不上公测的版本，开发者工具不完善、真机表现和开发环境差异很大、部分组件性能较差、部分功能有缺陷，只有经历了这些大坑，才会真的知道你有多“爱”微信小程序。这儿总结了开发中的难点以及微信小程序中遇到的比较明显的坑。</p>
<h3 id="富文本解析"><a href="#富文本解析" class="headerlink" title="富文本解析"></a>富文本解析</h3><p>微信小程序并不支持HTML标签，所以对于富文本解析来说，难度较大，而且有些功能还没有办法实现，比如：iframe视频、连接跳转等<br>这块功能建议由后台统一转换，如果非得前端转换，建议参考下面的思路。</p>
<p>非常感谢 <a href="https://github.com/icindy/wxParse" target="_blank" rel="external">wxParse</a> 这款组件，替我省了不少时间。推荐大家使用，期间遇到一些问题，也分享给大家。</p>
<ul>
<li>wxParse 默认层级只支持10层html嵌套，如果想要支持更深的层级，在wxParse.xml复制几份template即可。</li>
<li>wxParse 提供了图片加载成功的回调<code>wxParseImgLoad</code>，很好用。但如果富文本中的图片已经预设宽高比，那么可以不用依赖该回调，在html2jons.js中根据屏幕宽度直接计算出图片高度，先占位，可以避免页面频繁抖动的问题。</li>
<li>如果你的富文本中有自定义模块，对wxParse.xml中的template进行改造即可。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-52ce324bcc9879bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="数据扁平化"><a href="#数据扁平化" class="headerlink" title="数据扁平化"></a>数据扁平化</h3>具体如何扁平化，请移步上一篇博客 <a href="http://www.jianshu.com/p/ba8654cb77b6" target="_blank" rel="external">State设计，Redux 开发第一步</a>。<br>这儿只简单介绍下扁平化应用场景：<br>好奇心日报的研究所是三级表结构：<code>papers &gt; questions &gt; options</code>，后台返回的数据是三级嵌套数据，如果想要修改option.selected字段，需要三级嵌套循环！如果想要获取所有选中的option，需要三级嵌套循环！<h3 id="页面展现速度优化"><a href="#页面展现速度优化" class="headerlink" title="页面展现速度优化"></a>页面展现速度优化</h3>数据复用，比如复用列表页的数据，可以让详情页的标题等字段第一时间呈现出来。<br>离线缓存，同样可以让列表页和详情页第一时间呈现出来，甚至有可能减少请求数量。</li>
</ul>
<p>无论是数据复用还是离线缓存，配合数据扁平化，都非常好用。</p>
<h3 id="小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）"><a href="#小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）" class="headerlink" title="小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）"></a>小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）</h3><p>解决方法很简单，设置微信小程序不使用代理；或者临时关闭VPN即可。<br>最新版开发者工具已经解决该问题。</p>
<h3 id="最新版微信小程序移除了对Promise的支持。"><a href="#最新版微信小程序移除了对Promise的支持。" class="headerlink" title="最新版微信小程序移除了对Promise的支持。"></a>最新版微信小程序移除了对Promise的支持。</h3><p>开发者自行引入兼容库即可，推荐<a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="external">es6-promise</a>。使用的时候，直接引入Promise即可。</p>
<pre><code>// 引入Promise
import Promise from &apos;../vendors/es6-promise.js&apos;;

// 用Promise封装wx.request网络请求
function request(method = &apos;GET&apos;) {
    return function(url, data = {}) {
        return new Promise(function(resolve, reject) {
            wx.request({
                url,
                data,
                method,
                header: {
                    &apos;Content-Type&apos;: &apos;application/json&apos;
                },
                success: function(res) {
                    let { statusCode, errMsg, data } = res;

                    if (statusCode == 200 &amp;&amp; data.meta &amp;&amp; data.meta.status == 200) {
                        resolve(data.response);
                    } else {
                        reject(&apos;网路请求错误，请稍后再试~&apos;);
                    }
                },
                fail: function(err) {
                    reject(&apos;网路请求不符合规范，请检查域名是否符合要求~&apos;);
                }
            });
        })
    }
}
export const GET = request(&apos;GET&apos;);
export const POST = request(&apos;POST&apos;);
export const PUT = request(&apos;PUT&apos;);
export const DELETE = request(&apos;DELETE&apos;);

// 用Promise封装小程序的其他API
export const promisify = (api) =&gt; {
    return (options, ...params) =&gt; {
        return new Promise((resolve, reject) =&gt; {
            api(Object.assign({}, options, { success: resolve, fail: reject }), ...params);
        });
    }
}
// 使用
const getLocation = promisify(wx.getLocation);
</code></pre><p>不清楚微信为何会临时移除Promise，统一内置不也挺好？</p>
<h3 id="小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。"><a href="#小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。" class="headerlink" title="小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。"></a>小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。</h3><p>小程序一旦滚动顶部或者底部，继续滑动的时候，就会出现拉扯现象。而这个拉扯现象还无法禁止。<br>最新版可以对页面配置disableScroll，预计可以修复这个问题，待实际验证。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-691d39e8e75dc7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）"><a href="#swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）" class="headerlink" title="swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）"></a>swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）</h4><ul>
<li>swiper组件之前并不支持轮播，最新版已修复</li>
<li>swiper组件之前是通过设置left属性来实现动画，在小米5、华为V8等高端等安卓机上能够感受到明显的卡顿，当然原因是X5内核引起的。最新版已修复，换成了transform，性能有一定的提升。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-942330479da5c884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><p>文档并未标记可以垂直轮播，但其实是可以的。</p>
<pre><code>// 简单设置vertical即可，但由于官方文档并未备注，尽量不要使用。可以自己开发一个swiper组件。
&lt;swiper vertical=&quot;true&quot;&gt;&lt;/swiper&gt;
</code></pre></li>
<li>swiper组件的小圆点其实是可以定制化的，但是官方文档并未说明，而且开发者工具也看不出来，只有鼠标hover到元素上的时候可以看到相关的class，简单猜测一下，最后分析出来它的实现方式。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1158202-70f78f4950ce9817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>// 圆点的父元素，用来控制圆点间的间距
.wx-swiper-dot {
    width: 30rpx;
    // 圆点，可以通过font-size修改圆点的大小，color修改圆点的颜色
    &amp;:before {
        width: 100%;
        display: inline-block;
        font-size: 56rpx;
        content: &apos;圆点编码&apos;;
    }
    // active状态的圆点
    &amp;.wx-swiper-dot-active {
        &amp;:before {
            color: #ffc81f;
        }
    }
}
</code></pre><h3 id="小程序WXSS的font-face的url不接受路径作为参数"><a href="#小程序WXSS的font-face的url不接受路径作为参数" class="headerlink" title="小程序WXSS的font-face的url不接受路径作为参数"></a>小程序WXSS的font-face的url不接受路径作为参数</h3><p>可以将字体文件转换为base64，然后引用。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-4d8cf6721984b58c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>同样，如果想要使用iconfont，也可以使用类似的方案，将iconfont字体文件base64之后再引入。</p>
<h4 id="小程序的margin表现有问题（最新版已经修复）"><a href="#小程序的margin表现有问题（最新版已经修复）" class="headerlink" title="小程序的margin表现有问题（最新版已经修复）"></a>小程序的margin表现有问题（最新版已经修复）</h4><p>之前发生margin折叠的时候，会取小的那个值。会导致底部留白等设置失效。</p>
<h4 id="canvas问题"><a href="#canvas问题" class="headerlink" title="canvas问题"></a>canvas问题</h4><p>canvas并没有深入研究，目前的发现的问题主要是两个，如下图标记：</p>
<ul>
<li>层级问题，canvas总是会盖在其他元素上面。</li>
<li>支持度不好，在小米5、iPhone5s画图会出现畸形。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-aaea239242906e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>最后通过CSS3的方式绘制饼图</p>
<pre><code>&lt;template name=&quot;pie&quot;&gt;
    &lt;view class=&quot;com-pie&quot;&gt;
        &lt;!-- 小于50% --&gt;
        &lt;view class=&quot;percent-1&quot; style=&quot;transform: rotate(0.4turn);&quot;&gt;&lt;/view&gt;
        &lt;view class=&quot;percent-2&quot;&gt;&lt;/view&gt;
        &lt;!-- 大于50% --&gt;
        &lt;view class=&quot;percent-1&quot; style=&quot;transform: rotate(0.5turn);&quot;&gt;&lt;/view&gt;
        &lt;view class=&quot;percent-2&quot; style=&quot;opacity:1; transform: rotate(0.3turn);&quot;&gt;&lt;/view&gt;
    &lt;/view&gt;
&lt;/template&gt;

.com-pie {
    position: relative;
    z-index: 0;
    display: inline-block;
    width: 100rpx;
    height: 100rpx;
    line-height: 100rpx;
    border-radius: 50%;
    color: #000;
    background-color: #ebebeb;
    background-image: linear-gradient(to right, transparent 50%, #cccccc 0);
    overflow: hidden;
    .percent-1,
    .percent-2 {
        position: absolute;
        top: 0;
        width: 60%;
        height: 100%;
        left: 50%;
        transform-origin: center left;
    }
    .percent-1 {
        background-color: inherit;
        z-index: -2;
    }
    .percent-2 {
        height: 110%;
        opacity: 0;
        z-index: -1;
        background-color: #cccccc;
    }
    &amp;.selected {
        background-color: #ffe9a5;
        background-image: linear-gradient(to right, transparent 50%, #ffc81f 0);
        .percent-2 {
            background-color: #ffc81f;
        }
    }
}
</code></pre><h3 id="微信小程序的rpx会出现精度问题"><a href="#微信小程序的rpx会出现精度问题" class="headerlink" title="微信小程序的rpx会出现精度问题"></a>微信小程序的rpx会出现精度问题</h3><p>设置margin-left/margin-right负值，可能导致页面能够左右晃动。猜测 是rpx导致的精度问题。<br>rpx本质上会转换为px，在不同宽度的设备上，实际的rpx值会转换为带小数的px值，四舍五入可能出现问题，之前使用rem布局的时候在QQ浏览器遇到过类似的问题。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-83e69b31a569928f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="wx-request表现不合理，并且携带特殊字符会报错"><a href="#wx-request表现不合理，并且携带特殊字符会报错" class="headerlink" title="wx.request表现不合理，并且携带特殊字符会报错"></a>wx.request表现不合理，并且携带特殊字符会报错</h4><ul>
<li>请求返回404错误，也会触发success回调。<br>不要想当然的认为会触发fail回调，判断一个请求成功或失败，请使用wx.request返回的状态来判断。只有不符合规范的请求，才会触发fail。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-ebad0e91ac279124.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></li>
<li>请求的数据中，如果有特殊字符（比如\u2820），会报错。<br>只会在真机上出现，开发者工具没毛病。估计会有更多的特殊字符会导致这个问题。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-9110f7d78b3fb4aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="开发者工具，切换页面的时候，有时候wxml不会同步切换"><a href="#开发者工具，切换页面的时候，有时候wxml不会同步切换" class="headerlink" title="开发者工具，切换页面的时候，有时候wxml不会同步切换"></a>开发者工具，切换页面的时候，有时候wxml不会同步切换</h3>希望微信什么时候能解决一下。<h3 id="微信小程序给wxml模板赋值的时候，解构放到前面可能会报错"><a href="#微信小程序给wxml模板赋值的时候，解构放到前面可能会报错" class="headerlink" title="微信小程序给wxml模板赋值的时候，解构放到前面可能会报错"></a>微信小程序给wxml模板赋值的时候，解构放到前面可能会报错</h3>最新版会遇到这个问题，老版本虽然不会报错，但是在部分真机上会出现问题。<br>原因未知，遇到这个问题的朋友可以考虑绕过去。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-e379fd7fca1b99cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="微信小程序的scroll-view暴露的bindscroll函数并不能实时监听"><a href="#微信小程序的scroll-view暴露的bindscroll函数并不能实时监听" class="headerlink" title="微信小程序的scroll-view暴露的bindscroll函数并不能实时监听"></a>微信小程序的scroll-view暴露的bindscroll函数并不能实时监听</h3>依赖实时获取滚动位置的功能不能实现。比如滚动时toolbar的动态隐藏和显示。<h3 id="最新版开发工具不能关掉自动刷新"><a href="#最新版开发工具不能关掉自动刷新" class="headerlink" title="最新版开发工具不能关掉自动刷新"></a>最新版开发工具不能关掉自动刷新</h3>微信小程序的会默认监听文件变化，然后自动刷新。<br>但不足的是每次都是全量刷新，而不是模块的热替换，反而会影响开发速度，尤其对于喜欢频繁Command + S的开发者，你会发现你的小程序在不断的刷新。建议关闭。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-1418bc0e4b307f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但最新版开发者工具，不勾选也会自动刷新。</li>
</ul>
<h3 id="微信小程序不支持requestAnimationFrame"><a href="#微信小程序不支持requestAnimationFrame" class="headerlink" title="微信小程序不支持requestAnimationFrame"></a>微信小程序不支持<code>requestAnimationFrame</code></h3><p>微信小程序不支持<code>requestAnimationFrame</code>，所以部分性能优化做不了。不支持的原因未知。</p>
<h3 id="Page-onload函数可以接受参数"><a href="#Page-onload函数可以接受参数" class="headerlink" title="Page.onload函数可以接受参数"></a>Page.onload函数可以接受参数</h3><p>该参数是有URL决定的，也就是URL携带的参数。<br>官方文档这块写的有点混淆，特意拿出来说一下。举个例子：url中传递的时候<code>id=1</code>，那么<code>option.id=1</code>，而不是什么<code>option.query</code>。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-8135e6e4e97b2ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="真机上有概率卡死，目前不确定是代码问题还是小程序的问题。"><a href="#真机上有概率卡死，目前不确定是代码问题还是小程序的问题。" class="headerlink" title="真机上有概率卡死，目前不确定是代码问题还是小程序的问题。"></a>真机上有概率卡死，目前不确定是代码问题还是小程序的问题。</h3><p>有遇到类似问题的朋友欢迎指出。</p>
<h4 id="总结说点啥？"><a href="#总结说点啥？" class="headerlink" title="总结说点啥？"></a>总结说点啥？</h4><p>本文主要围绕微信小程序的基础知识、如何设计微信小程序、开发过程中遇到的问题三个方面介绍。<br>微信小程序的基础知识主要包括：</p>
<ul>
<li>两种配置文件 &amp;&amp; 两个核心函数</li>
<li>WXML模板语法，页面渲染</li>
<li>页面间的跳转</li>
<li>交互事件</li>
<li>官方组件和官方API</li>
</ul>
<p>如何设计微信小程序的内容主要包括：</p>
<ul>
<li>构建系统 &amp;&amp; 目录结构</li>
<li>引入Redux进行数据集中管理</li>
<li>简单的组件化解决方案</li>
</ul>
<p>最后还介绍开发过程中遇到的难点 以及 微信小程序的大小坑。</p>
<p>微信小程序本身并不复杂，开发过程却比较艰辛，尤其是第一次在真机上运行的时候，觉得这个世界恶意满满。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/03/微信小程序实战，从入门到弃坑（转）/" class="archive-article-date">
  	<time datetime="2017-01-03T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信小程序/">微信小程序</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-mobiscroll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/02/mobiscroll/">mobiscroll</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>mobiscroll一款使用简单而强大的JQ插件，依赖文件可以在我的<a href="https://github.com/Jasonellen/relyOn/tree/master/timepicker" target="_blank" rel="external">github</a>中找到，这种timepicker在手机端还是非常常见的，实用！</p>
</blockquote>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code>引入依赖文件
&lt;link rel=&quot;stylesheet&quot; href=&quot;mobiscroll.custom-2.17.0.min.css&quot;&gt;
&lt;script src=&apos;jquery.min.js&apos;&gt;&lt;/script&gt;
&lt;script src=&apos;mobiscroll.custom-2.17.0.min.js&apos;&gt;&lt;/script&gt;
</code></pre><p><br>    </p>
<pre><code>目标对象
&lt;input id=&quot;demo&quot; placeholder=&quot;Please Select...&quot; /&gt;
&lt;button id=&quot;show&quot;&gt;show&lt;/button&gt;
&lt;button id=&quot;clear&quot;&gt;clear&lt;/button&gt;
</code></pre><p><br></p>
<pre><code>初始化，及调用mobiscroll方法
$(function () {
    var now = new Date(),
        minDate = new Date(now.getFullYear() - 10, now.getMonth(), now.getDate()),
        maxDate = new Date(now.getFullYear() + 10, now.getMonth(), now.getDate());

    $(&apos;#demo&apos;).mobiscroll().datetime({
        theme: &apos;mobiscroll&apos;,
        lang: &apos;zh&apos;,
        display: &apos;bottom&apos;,
        min: minDate,
        max: maxDate,
        stepMinute: 1 , //设置分钟间隔

        dateFormat: &apos;yy-mm-dd&apos;, //日期格式
        // timeFormat: &apos;HH:ii&apos;, //事件格式 大写24H 小写12H
           // timeWheels: &apos;HHii&apos;
           //dateOrder: &apos;ddyymm&apos;, //面板中日期排列格式

    });

    $(&apos;#show&apos;).click(function () {  
        $(&apos;#demo&apos;).mobiscroll(&apos;show&apos;);
        return false;  
    }); 

    $(&apos;#clear&apos;).click(function () {  
        $(&apos;#demo&apos;).mobiscroll(&apos;clear&apos;);  
        return false;  
    });
});
</code></pre><blockquote>
<p>样式肯定不止这一种啦，更多使用demo请直接转官网<a href="https://demo.mobiscroll.com/v3/jquery/datetime#demo=rtl" target="_blank" rel="external">demo.mobiscroll.com</a>    </p>
<h2 id="修改基本样式"><a href="#修改基本样式" class="headerlink" title="修改基本样式"></a>修改基本样式</h2><pre><code>如果你愿意，当然后找一找还是能找到很多样式接口：
&lt;style&gt;
    .mbsc-mobiscroll .dwb0{
        color: red;
        /*确定按钮的颜色*/
    }
    .dw-ul{
        color: lightgrey;  
        /*所有字体的颜色*/
    }
    .dw-sel{
        color: brown;
        /*当前选中字体的颜色*/
    }
    ....    
&lt;/style&gt;
</code></pre></blockquote>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>不要下手太重，<a href="http://htmlpreview.github.io/?https://github.com/Jasonellen/relyOn/blob/master/timepicker/timepicker.html" target="_blank" rel="external">轻轻戳我预览</a>😁</p>
<h2 id="不只是timepicker"><a href="#不只是timepicker" class="headerlink" title="不只是timepicker"></a>不只是timepicker</h2><p>看一个完整的例子</p>
<h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width:device-width,initial-scale=1.0&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;content/Content/mobiscroll-2.13.2.full.min.css&quot;&gt;
&lt;script src=&apos;jquery.min.js&apos;&gt;&lt;/script&gt;
&lt;script src=&apos;content/Scripts/mobiscroll-2.13.2.full.min.js&apos;&gt;&lt;/script&gt;
</code></pre><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><pre><code>&lt;style&gt;  
.mbsc-android-holo .dwv { text-align:left;text-indent:.8em; }  
&lt;/style&gt;  
&lt;ul id=&quot;treelist&quot;&gt; 
  &lt;li&gt;  
      &lt;span&gt;奥迪&lt;/span&gt;  
      &lt;ul&gt;  
          &lt;li&gt;奥迪A3&lt;/li&gt;  
          &lt;li&gt;奥迪A4L&lt;/li&gt;  
          &lt;li&gt;奥迪A6L&lt;/li&gt;  
          &lt;li&gt;奥迪Q3&lt;/li&gt;  
          &lt;li&gt;奥迪Q5&lt;/li&gt;  
          &lt;li&gt;奥迪A4&lt;/li&gt;  
          &lt;li&gt;奥迪A6&lt;/li&gt;  
          &lt;li&gt;奥迪A1&lt;/li&gt;  
          &lt;li&gt;奥迪A3(进口)&lt;/li&gt;  
      &lt;/ul&gt;  
  &lt;/li&gt;  
  &lt;li&gt;  
      &lt;span&gt;宝马&lt;/span&gt;  
      &lt;ul&gt;  
          &lt;li&gt;宝马X1&lt;/li&gt;  
          &lt;li&gt;宝马i3&lt;/li&gt;  
          &lt;li&gt;宝马1系&lt;/li&gt;  
          &lt;li&gt;宝马3系&lt;/li&gt;  
          &lt;li&gt;宝马5系&lt;/li&gt;  
      &lt;/ul&gt;  
  &lt;/li&gt;  
  &lt;li&gt;  
      &lt;span&gt;奔驰&lt;/span&gt;  
      &lt;ul&gt;  
          &lt;li&gt;奔驰A级&lt;/li&gt;  
          &lt;li&gt;奔驰C级&lt;/li&gt;  
          &lt;li&gt;奔驰E级&lt;/li&gt;  
          &lt;li&gt;奔驰S级&lt;/li&gt;  
          &lt;li&gt;奔驰GLK级&lt;/li&gt;  
          &lt;li&gt;奔驰CLA级&lt;/li&gt;  
          &lt;li&gt;奔驰CLS级&lt;/li&gt;  
      &lt;/ul&gt;  
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><pre><code>$(function () {
  var i = Math.floor($(&apos;#treelist&gt;li&apos;).length / 2),  
      j = Math.floor($(&apos;#treelist&gt;li&apos;).eq(i).find(&apos;ul li&apos;).length / 2);  
  $(&quot;#treelist&quot;).mobiscroll().treelist({  
      theme: &quot;android-ics light&quot;,  
      lang: &quot;zh&quot;,  
      defaultValue: [i,j],  
      cancelText: &apos;取消&apos;,  
      placeholder: &apos;选择车型&apos;,  
      headerText: function (valueText) { return &quot;选择车型&quot;; },  
      formatResult: function (array) { //返回自定义格式结果  
          return $(&apos;#treelist&gt;li&apos;).eq(array[0]).children(&apos;span&apos;).text() +&apos; --&apos;+ $(&apos;#treelist&gt;li&apos;).eq(array[0]).find(&apos;ul li&apos;).eq(array[1]).text().trim(&apos; &apos;);  
      }  
  }); 
}) 
</code></pre><h3 id="效果预览-1"><a href="#效果预览-1" class="headerlink" title="效果预览"></a>效果预览</h3><p><a href="http://htmlpreview.github.io/?https://github.com/Jasonellen/relyOn/blob/master/timepicker/%E8%87%AA%E5%AE%9A%E4%B9%89picker.html" target="_blank" rel="external">轻轻戳我预览</a>😁，注意这个自定义用的文件上是<code>mobiscroll-2.13.2.full.min</code>文件哦。</p>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code>theme: &apos;android-ics light&apos;, //皮肤样式
display: &apos;modal&apos;, //显示方式
mode:&apos;scroller&apos;,
dateFormat: &apos;yy-mm-dd&apos;, // 日期格式
setText: &apos;确定&apos;, //确认按钮名称
cancelText: &apos;取消&apos;,//取消按钮
dateOrder: &apos;yymmdd&apos;, //面板中日期排列格式
headerText: function (valueText) { array = valueText.split(&apos;-&apos;); return array[0] + &quot;年&quot; + array[1] + &quot;月&quot;+array[2]+&quot;日&quot;; }, //自定义弹出框头部格式
rows:5,//滚动区域内的行数 
</code></pre><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><pre><code>（1）onBeforeClose(valueText, btn, inst)
描述：在list关闭之前执行，如果返回false则不会关闭list。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onBeforeClose: function (valueText, btn, inst) {
    }
});

（2）onBeforeShow(inst)
描述：在list显示之前执行的事件，一样如果返回false则list不会显示。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onBeforeShow: function (inst) {
    }
});

（3）onCancel(valueText, inst)
描述：当取消按钮被点击的时候执行的事件。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onCancel: function (valueText, inst) {
    }
});

（4）onChange(valueText, inst)
描述：当value值改变的时候执行
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onChange: function (valueText, inst) {
    }
});

（5）onClosed(valueText, inst)
描述：当list关闭的时候执行的回调函数
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onClosed: function (valueText, inst) {
    }
});

（6）onDestroy(inst)
描述：当miboscroll实例被destoroy的时候回调
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onDestroy: function (inst) {
    }
});

（7）onHide(inst)
描述：list 关闭的动画执行完毕后回调
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onHide: function (inst) {
    }
});

（8）onInit(inst)
描述：mobiscroll实例初始化完成后执行
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onInit: function (inst) {
    }
});

（9）onMarkupReady(html, inst)
描述：list的html代码已经生成，但是还没有显示到页面中的时候，这个时候可以进行标签的修改。例如添加自定义元素。它会在定位完成前执行。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onMarkupReady: function (html, inst) {
    }
});

（10）onPosition(html, windowWidth, windowHeight, inst)
描述：list定位完成后调用（包括初始化完成以及大小/方向调整之后）
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onPosition: function (html, windowWidth, windowHeight, inst) {
    }
});

（11）onSelect(valueText, inst)
描述：当value被设置的时候，简单理解就是选择好了原始点击确定之后
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onSelect: function (valueText, inst) {
    }
});
（12）onShow(html, valueText, inst)
描述：当list出现的时候
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onShow: function (html, valueText, inst) {
    }
});

（13）onValueTap(item, inst)
描述：当用户点击list上面的值是调用
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onValueTap: function (item, inst) {
    }
});
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/02/mobiscroll/" class="archive-article-date">
  	<time datetime="2017-01-02T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobiscroll/">mobiscroll</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-彻底弄懂事件委托" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/23/彻底弄懂事件委托/">彻底弄懂事件委托</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>事件委托又叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理<code>某一类型</code>的所有事件。何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>
</blockquote>
<h2 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h2><p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个<code>优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收</code>。</p>
<h2 id="Why-we-use❓"><a href="#Why-we-use❓" class="headerlink" title="Why we use❓"></a>Why we use❓</h2><h4 id="先看一段代码"><a href="#先看一段代码" class="headerlink" title="先看一段代码"></a>先看一段代码</h4><pre><code>&lt;ul id=&quot;ul1&quot;&gt;
    &lt;li&gt;111&lt;/li&gt;
    &lt;li&gt;222&lt;/li&gt;
    &lt;li&gt;333&lt;/li&gt;
    &lt;li&gt;444&lt;/li&gt;
&lt;/ul&gt;

window.onload = function(){
    var oUl = document.getElementById(&quot;ul1&quot;);
    var aLi = oUl.getElementsByTagName(&apos;li&apos;);
    for(var i=0;i&lt;aLi.length;i++){
        aLi[i].onclick = function(){
            alert(123);
        }
    }
}
</code></pre><p>看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li</p>
<p><hr><br>当然，这是常规的做法，一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，1000个li,每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p>
<blockquote>
<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
</blockquote>
<h4 id="事件委托触发相同事件"><a href="#事件委托触发相同事件" class="headerlink" title="事件委托触发相同事件"></a>事件委托触发相同事件</h4><pre><code>window.onload = function(){
    var oUl = document.getElementById(&quot;ul1&quot;);
    oUl.onclick = function(){
        alert(123);
    }
}
</code></pre><p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，这里是用ul的点击达到同样的效果<code>那么问题来了，如果单纯的点击ul也会触发li本该触发的事件，更精确点，我们只想要li点击时才触发事件怎么办？继续往下走...</code><br><br></p>
<blockquote>
<p>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称为事件源，也就是说，target就可以表示为当前的事件操作的dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较(强迫症是很难改的…)</p>
</blockquote>
<pre><code>window.onload = function(){
    var oUl = document.getElementById(&quot;ul1&quot;);
    oUl.onclick = function(ev){
        var ev = ev || window.event;
        var target = ev.target || ev.srcElement;
        if(target.nodeName.toLowerCase() == &apos;li&apos;){
            alert(123);
            alert(target.innerHTML);
        }
    }
}
</code></pre><p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p>
<hr>

<h4 id="事件委托触发不同事件"><a href="#事件委托触发不同事件" class="headerlink" title="事件委托触发不同事件"></a>事件委托触发不同事件</h4><p>上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？答案是肯定的，如果有标记的话😁<br>​<br><code>未使用委托：4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，</code></p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt;
&lt;/div&gt;

window.onload = function(){
   var Add = document.getElementById(&quot;add&quot;);
   var Remove = document.getElementById(&quot;remove&quot;);
   var Move = document.getElementById(&quot;move&quot;);
   var Select = document.getElementById(&quot;select&quot;);

   Add.onclick = function(){
       alert(&apos;添加&apos;);
   };
   Remove.onclick = function(){
       alert(&apos;删除&apos;);
   };
   Move.onclick = function(){
       alert(&apos;移动&apos;);
   };
   Select.onclick = function(){
       alert(&apos;选择&apos;);
   }

}
</code></pre><p><code>使用委托：可以只用一次dom操作就能实现所有的效果</code></p>
<pre><code>window.onload = function(){
        var oBox = document.getElementById(&quot;box&quot;);
        oBox.onclick = function (ev) {
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if(target.nodeName.toLocaleLowerCase() == &apos;input&apos;){
                switch(target.id){
                    case &apos;add&apos; :
                        alert(&apos;添加&apos;);
                        break;
                    case &apos;remove&apos; :
                        alert(&apos;删除&apos;);
                        break;
                    case &apos;move&apos; :
                        alert(&apos;移动&apos;);
                        break;
                    case &apos;select&apos; :
                        alert(&apos;选择&apos;);
                        break;
                }
            }
        }

    }
</code></pre><h3 id="关于动态添加新元素"><a href="#关于动态添加新元素" class="headerlink" title="关于动态添加新元素"></a>关于动态添加新元素</h3><p><code>未使用事件委托</code></p>
<pre><code>for(var i=0; i&lt;aLi.length;i++){
    aLi[i].onclick = function(){
        this.style.background = &apos;red&apos;;
    };
}
//添加新节点
oBtn.onclick = function(){
    var oLi = document.createElement(&apos;li&apos;);
    oLi.innerHTML = 111*num;
    oUl.appendChild(oLi);
};
</code></pre><p>这是一般的做法，你会发现，新增的li是没有点击事件的</p>
<p><code>使用事件委托</code></p>
<pre><code>oUl.onclick = function(ev){
  var ev = ev || window.event;
  var target = ev.target || ev.srcElement;
  if(target.nodeName.toLowerCase() == &apos;li&apos;){
      target.style.background = &quot;red&quot;;
  }
};
oBtn.onclick = function(){
  var oLi = document.createElement(&apos;li&apos;);
  oLi.innerHTML = 111*num;
  oUl.appendChild(oLi);
};
</code></pre><p>这里你会发现，新添加的li元素无需做其他操作，已有点击事件</p>
<hr>


<h1 id="事件委托适用场景"><a href="#事件委托适用场景" class="headerlink" title="事件委托适用场景"></a>事件委托适用场景</h1><ul>
<li>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</li>
<li>不适合使用的事件：mouseover,mouseout和mousemove,因为不是单纯地点击等操作，每次触发都需要重新计算一下位置，处理起来也不是很方便，就不用喽</li>
<li>focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</li>
</ul>
<h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/23/彻底弄懂事件委托/" class="archive-article-date">
  	<time datetime="2016-12-23T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-博观而约取，厚积而薄发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/博观而约取，厚积而薄发/">博观而约取，厚积而薄发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>出自宋代诗人苏轼的《杂说送张琥》</p>
</blockquote>
<h3 id="博观而约取，厚积而薄发，吾告子止于此矣。"><a href="#博观而约取，厚积而薄发，吾告子止于此矣。" class="headerlink" title="博观而约取，厚积而薄发，吾告子止于此矣。"></a>博观而约取，厚积而薄发，吾告子止于此矣。</h3><pre><code>多读书，取其精华，去其糟粕，我认为人生也是如此，应该记着开心的，忘掉烦心的。

无论知识，还是其他都是需要积累的，人要一步一个脚印，只有脚踏实地，才能仰望苍穹。
</code></pre><p><img src="http://ww1.sinaimg.cn/mw690/908edb0ejw1fayrfiu3x8j204b0640sm.jpg" alt=""></p>
<p><em>博观：指大量的看书，多多阅读，了解事物;约取：指少量的慢慢的拿出来。 厚积：指大量地、充分地积蓄;薄发：指少量地、慢慢地放出。多多积蓄，慢慢放出。形容只有准备充分才能办好事情。 其实上面两句话的意思差不多，总的意思就是指要经过长时间有准备的积累即将大有可为，施展作为。</em><br><br><br><br><br><br></p>
<h1 id="左耳是靠近心脏最近的地方，甜言蜜语要说给左耳听"><a href="#左耳是靠近心脏最近的地方，甜言蜜语要说给左耳听" class="headerlink" title="左耳是靠近心脏最近的地方，甜言蜜语要说给左耳听"></a>左耳是靠近心脏最近的地方，甜言蜜语要说给左耳听</h1><p><img src="http://ww2.sinaimg.cn/mw690/908edb0egw1fayivy45s9j2064064gle.jpg" alt=""></p>
<p><br><br><br><br><br></p>
<h1 id="踮起脚尖，离阳光更近一点"><a href="#踮起脚尖，离阳光更近一点" class="headerlink" title="踮起脚尖，离阳光更近一点"></a>踮起脚尖，离阳光更近一点</h1><p><img src="http://ww1.sinaimg.cn/mw690/908edb0egw1fayiyya74ij206c064zk6.jpg" alt=""><br><br><br><br><br><br></p>
<h1 id="会有人想你的那个地方，就是你回去的地方"><a href="#会有人想你的那个地方，就是你回去的地方" class="headerlink" title="会有人想你的那个地方，就是你回去的地方"></a>会有人想你的那个地方，就是你回去的地方</h1><p><img src="http://ww4.sinaimg.cn/mw690/908edb0egw1fayj6cmia2j21kw23u7wh.jpg" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/22/博观而约取，厚积而薄发/" class="archive-article-date">
  	<time datetime="2016-12-22T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-22</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他/">其他</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-文件拖拽" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/文件拖拽/">文件拖拽</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。Internet Explorer 9、Firefox、Opera 12、Chrome 以及 Safari 5 支持拖放。<code>注意</code>即使元素可以拖拽，在拖拽的过程中（ondragover）默认情况下是无法将数据、元素放到其他元素中的，如果需要允许，就要阻止默认处理；</p>
</blockquote>
<h2 id="拖拽API"><a href="#拖拽API" class="headerlink" title="拖拽API"></a>拖拽API</h2><pre><code>draggable ：
–    设置为true，元素就可以拖拽了

拖拽元素事件 :  事件对象为被拖拽元素
–    dragstart ,  拖拽前触发 
–    drag ,拖拽前、拖拽结束之间，连续触发
–    dragend  , 拖拽结束触发

目标元素事件 :  事件对象为目标元素
–    dragenter ,  进入目标元素触发，相当于mouseover
–    dragover  ,进入目标、离开目标之间，连续触发
–    dragleave ,  离开目标元素触发，相当于mouseout
–    drop  ,  在目标元素上释放鼠标触发
</code></pre><h2 id="Demo1-拖拽删除"><a href="#Demo1-拖拽删除" class="headerlink" title="Demo1-拖拽删除"></a>Demo1-拖拽删除</h2><p><a href="http://htmlpreview.github.io/?https://github.com/Jasonellen/jasonProject.github.io/blob/master/drag1.html" target="_blank" rel="external"><code>效果示例</code></a></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Untitled Document&lt;/title&gt;
    &lt;style&gt;
        li{ list-style:none; width:100px; height:30px; background:yellow; margin:10px;}
        #div1{ width:100px; height:100px; background:red; margin:200px;}
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;ul&gt;
        &lt;li draggable=&quot;true&quot;&gt;a&lt;/li&gt;
        &lt;li draggable=&quot;true&quot;&gt;b&lt;/li&gt;
        &lt;li draggable=&quot;true&quot;&gt;c&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
    window.onload = function(){
        var aLi = document.getElementsByTagName(&apos;li&apos;);
        var oUl=document.getElementsByTagName(&apos;ul&apos;)[0];
        var oDiv = document.getElementById(&apos;div1&apos;);
        var oImg = document.getElementById(&apos;img1&apos;);

        for(var i=0;i&lt;aLi.length;i++){
            aLi[i].index = i;
            aLi[i].ondragstart = function(ev){
                ev.dataTransfer.setData(&apos;name&apos;,this.index);
                this.style.background = &apos;green&apos;;
                //ev.dataTransfer.setDragImage(this,0,0); //设置拖动时显示的对象和坐标
            };

            aLi[i].ondrag = function(){  //开始与结束连续触发
                document.title = i++;
            };

            aLi[i].ondragend = function(){
                this.style.background = &apos;yellow&apos;;
            };
        }

        oDiv.ondragenter = function(){
            this.style.background = &apos;blue&apos;;
        };

        oDiv.ondragover = function(ev){
            //enter和leave之间连续触发
            document.title = i++;
            //要想触发drop事件，就必须在dragover当中阻止默认事件
            ev.preventDefault();
        };

        oDiv.ondragleave = function(){
            this.style.background = &apos;red&apos;;
        };

        oDiv.ondrop = function(ev){
            ev.preventDefault();   //阻止默认事件，不然是外部图片就直接打开了
            var n=ev.dataTransfer.getData(&apos;name&apos;);
            // ev.dataTransfer.clearData(&quot;name&quot;);
            oUl.removeChild( aLi[n]); //删除以后要从新算index
            for(var i=0;i&lt;aLi.length;i++){
                aLi[i].index = i;
            }
            this.style.background = &apos;red&apos;;    
        };    
    };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="Demo2-外部文件拖入显示"><a href="#Demo2-外部文件拖入显示" class="headerlink" title="Demo2-外部文件拖入显示"></a>Demo2-外部文件拖入显示</h2><p><a href="http://htmlpreview.github.io/?https://github.com/Jasonellen/jasonProject.github.io/blob/master/drag2.html" target="_blank" rel="external"><code>效果示例</code></a></p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Untitled Document&lt;/title&gt;
    &lt;style&gt;
    ul,li{ margin:0;padding:0;list-style:none;}
    div{
        width:200px; height:200px; background:red; text-align:center;
    }
    ul{
        width:600px; background-color:#000; 
    }
    li {
        margin:10px 20px;
    }
    ul:after {
        content:&apos;&apos;;
        display:block;
        clear:both;
    }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;把图片拖到这里&lt;/div&gt;
    &lt;ul&gt;&lt;/ul&gt;

    &lt;script&gt;
    window.onload=function(){
        var oDiv = document.querySelector(&apos;div&apos;);
        var oUl = document.querySelector(&apos;ul&apos;);
        oDiv.ondragenter=function(){
            this.innerHTML=&apos;可以松开了哦&apos;;
        }
        oDiv.ondragover=function(ev){
            var ev=ev||event;
            ev.preventDefault(); 
        }
        oDiv.ondragleave=function(){
            this.innerHTML=&apos;把图片拖到这里&apos;;
        }
        oDiv.ondrop=function(ev){
            var ev=ev||event;
            ev.preventDefault(); //阻止默认事件，不然是外部图片就直接打开了
            this.innerHTML=&apos;把图片拖到这里&apos;;

            var fs=ev.dataTransfer.files; //拖拽的文件集合
            for(var i=0; i&lt;fs.length; i++){
                if(fs[i].type.indexOf(&apos;image&apos;)!=-1){ //判断拖拽内容的类型是image
                    var fd=new FileReader();  //创建可以读文件的对象
                    fd.readAsDataURL(fs[i]);  //读
                    fd.onload=function(){  //读取成功直接执行onload
                        var oLi    =document.createElement(&apos;li&apos;);
                        oLi.style.float=&apos;left&apos;;
                        var oImg= document.createElement(&apos;img&apos;);
                        oImg.style.height=&apos;200px&apos;;
                        oImg.src = this.result;  //地址就是获取到的url信息
                        oLi.appendChild(oImg);
                        oUl.appendChild(oLi);
                    }
                }else{
                    alert(&apos;非法图片&apos;);
                }
            }
        }
    }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/21/文件拖拽/" class="archive-article-date">
  	<time datetime="2016-12-21T06:39:54.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-图片预览上传" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/图片预览上传/">图片预览上传</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>上传图片之前应该让用户可以预览一下刚才选中的图片，这对于优化用户体验非常重要，本文主要介绍一下简单的图片预览的效果及ajax的formData上传和php接收添加数据库的基本操作</p>
</blockquote>
<p><code>直接上代码</code></p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>&lt;style&gt;
  button{
    margin-top: 50px;
  }
&lt;/style&gt;
&lt;body&gt; 
    &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt;
    &lt;!--这里限制了可以上传的文件只能是图片，且可以一次上传多张图片--&gt;
      &lt;input type=&quot;file&quot; id=&quot;file&quot; accept=&quot;image/gif,image/jpeg,image/jpg,image/png&quot; multiple&gt;&lt;br/&gt;
      &lt;button&gt;上传&lt;/button&gt;
      &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; 
&lt;/body&gt;
</code></pre><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><pre><code>$(function(){
    //图片预览
    var FileReader = window.FileReader;   //创建文件读取对象
    $(&quot;#file&quot;).change(function() {  
        if (FileReader) {                 //chrome浏览器处理  
            var file = this.files;        //获取一次上传的全部文件
            var length = file.length; 
            for(var i=0; i&lt;length;i++){
                upload(this,i)            //逐个上传
            } 
        }  
        else {//其他浏览器处理
           var path = $(this).val();  
            if (/&quot;\w\W&quot;/.test(path)) {  
                path = path.slice(1,-1);  
            }  
            $(&quot;#image&quot;).attr(&quot;src&quot;,path);
        }  
    });  

    function upload(obj,i){
        var reader = new FileReader();
        var file = obj.files;
        reader.readAsDataURL(file[i]);   //读取文件路径
        reader.onload = function(e) {  
            var Img = new Image()
            Img.src=e.target.result;     //将读取到的文件给到新创建的image
            Img.width=100;
            Img.height=100;
            document.body.appendChild(Img);//这里是把图片转成64位数据存入&lt;img&gt;中的src里
        };  
    }  

    //图片上传
    $(&apos;button&apos;).click(function(){
        var username =$(&apos;#username&apos;).val();
        var form = new FormData();
        var file = $(&apos;#file&apos;)[0][&apos;files&apos;][0]; //点击提交的时候获取图片地址    
        form.append(&apos;username&apos;,username);
        form.append(&apos;file&apos;,file);     
        $.ajax({
            type:&apos;post&apos;,
            url:&apos;../php/add.php&apos;,
            data:form,
            processData:false,   //ajax 提交的时候不会序列化data，而是直接使用data
            contentType:false,   //发送信息至服务器时内容编码类型设置为不需要编码
            success:function(data){
                alert(data)
            }
        })

    })
})
</code></pre><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><pre><code>if(!empty($_POST[&apos;username&apos;])){
    $username = $_POST[&apos;username&apos;];
}    
//处理文件
if(!file_exists(&apos;../uploads&apos;)){
    mkdir(&apos;../uploads&apos;);  //创建文件夹接收图片
}
$file = $_FILES[&apos;file&apos;][&apos;tmp_name&apos;];  //获取文件路径
$newName = $_FILES[&apos;file&apos;][&apos;name&apos;]; //获取文件的名字
$res = move_uploaded_file($file,&quot;../uploads/{$newName}&quot;); //原名上传到指定文件夹
if($res){
    $url=&quot;../uploads/{$newName}&quot;;
}

$sql =&quot;INSERT INTO addmore (username,url) VALUES(&apos;$username&apos;,&apos;$url&apos;)&quot;;
$res =add($sql);

//增加数据
function add($sql){
    $mysqli = new mysqli(&apos;localhost&apos;,&apos;root&apos;,&apos;&apos;,&apos;mybook&apos;);
    //设置编码
    $mysqli-&gt;query(&apos;set names utf8&apos;);
    $res = $mysqli-&gt;query($sql);
    if($res){
        echo &apos;添加成功&apos;;
    }else{
        echo &apos;添加失败&apos;;
    }
}
</code></pre><h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/19/图片预览上传/" class="archive-article-date">
  	<time datetime="2016-12-19T14:11:14.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-19</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/upload/">upload</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-ReactNative启动白屏解决" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/ReactNative启动白屏解决/">ReactNative启动白屏解决</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="本文主要设置andriod的启动屏，ios的感觉不需要这个插件"><a href="#本文主要设置andriod的启动屏，ios的感觉不需要这个插件" class="headerlink" title="本文主要设置andriod的启动屏，ios的感觉不需要这个插件.."></a>本文主要设置andriod的启动屏，ios的感觉不需要这个插件..</h1><h2 id="下载依赖插件"><a href="#下载依赖插件" class="headerlink" title="下载依赖插件"></a>下载依赖插件</h2><p><code>在项目根目录打开终端运行</code></p>
<pre><code>npm react-native-splash-screen --save 
</code></pre><h2 id="安装-自动安装或手动安装"><a href="#安装-自动安装或手动安装" class="headerlink" title="安装(自动安装或手动安装)"></a>安装(自动安装或手动安装)</h2><p><code>自动安装终端运行：（推荐）</code></p>
<pre><code>react-native link react-native-splash-screen  
或
rnpm link react-native-splash-screen  
</code></pre><p><code>手动安装</code></p>
<pre><code>1.在你的android/settings.gradle 文件中添加下列代码:
include &apos;:react-native-splash-screen&apos;     
project(&apos;:react-native-splash-screen&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-splash-screen/android&apos;)  

2.在你的android/app/build.gradle 文件中添加 :react-native-splash-screen：
...  
dependencies {  
        ...  
    compile project(&apos;:react-native-splash-screen&apos;)  
}

3.更新你的MainApplication.Java文件，如下:
public class MainApplication extends Application implements     ReactApplication {  

private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {  
    @Override  
    protected boolean getUseDeveloperSupport() {  
        return BuildConfig.DEBUG;  
    }  

    @Override  
    protected List&lt;ReactPackage&gt; getPackages() {  
        return Arrays.&lt;ReactPackage&gt;asList(  
                new MainReactPackage(),  
        new SplashScreenReactPackage()  //添加这一句  
        );  
    }  
};  

@Override  
public ReactNativeHost getReactNativeHost() {  
    return mReactNativeHost;  
}  
}
</code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>1.更新你的MainActivity.java 文件如下：</code></p>
<pre><code>import android.os.Bundle; //需要新添加的？
import com.facebook.react.ReactActivity; //原来有的
import com.cboy.rn.splashscreen.SplashScreen; //需要新添加的？

public class MainActivity extends ReactActivity {  
    //原来有的
    @Override
    protected String getMainComponentName() {
        return &quot;examples&quot;;
    }
    //下面是新添加的
       @Override  
        protected void onCreate(Bundle savedInstanceState) {  
               SplashScreen.show(this);    
            super.onCreate(savedInstanceState);  
        }  
    }
}
</code></pre><p><code>2.创建一个名为launch_screen.xml 的布局文件来自定义你的启动屏幕</code></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:background=&quot;@drawable/launch_screen&quot;&gt;  
&lt;/LinearLayout&gt;  
</code></pre><p>创建的文件夹和文件路径如下：<br>splash.png就是你想要设置的启动图图片，<br><img src="http://ww4.sinaimg.cn/mw690/908edb0egw1fakekfg8w3j208q0d6t9k.jpg" alt=""><br>​<br><code>3.在.js文件中使用</code></p>
<pre><code>import SplashScreen from &apos;react-native-splash-screen&apos;  

//然后在componentDidMount中调用Splash.hide().
export default class WelcomePage extends Component {
    componentDidMount() {
        SplashScreen.hide();
    }
}
</code></pre><p>参考网址：<a href="https://github.com/crazycodeboy/react-native-splash-screen" target="_blank" rel="external">https://github.com/crazycodeboy/react-native-splash-screen</a></p>
<h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/10/ReactNative启动白屏解决/" class="archive-article-date">
  	<time datetime="2016-12-10T03:23:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/">ReactNative</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-SVG图标使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/09/SVG图标使用/">SVG图标使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在网页设计中，经常会用掉SVG图标，或者自己画或者别人画，画好的SVG该如何使用，本文对此做点使用介绍</p>
</blockquote>
<h2 id="首先这里需要借助第三方图标库icomoon"><a href="#首先这里需要借助第三方图标库icomoon" class="headerlink" title="首先这里需要借助第三方图标库icomoon"></a>首先这里需要借助第三方图标库icomoon</h2><p><a href="https://icomoon.io/" target="_blank" rel="external">icomoon入口</a></p>
<h2 id="网站进入后依次进行如下："><a href="#网站进入后依次进行如下：" class="headerlink" title="网站进入后依次进行如下："></a>网站进入后依次进行如下：</h2><p><code>1.点击进入IcoMoon App</code><br><img src="http://ww2.sinaimg.cn/mw690/908edb0egw1fajg72bsqzj20ix02w74o.jpg" alt=""></p>
<p><code>2.点击import icons上传本地.svg文件</code><br><img src="http://ww3.sinaimg.cn/mw690/908edb0egw1fajg72mkubj20lq0cdac6.jpg" alt=""></p>
<p><code>3.上传后如下图显示</code><br><img src="http://ww2.sinaimg.cn/mw690/908edb0egw1fajg72z1oij20oj07d3yz.jpg" alt=""></p>
<p><code>4.shift+鼠标左键选中上传的图标，点击右下角Generate Font</code><br><img src="http://ww3.sinaimg.cn/mw690/908edb0egw1fajg73mw8wj20sf0nx425.jpg" alt=""></p>
<p><code>5.显示如下图，记住图标对应的类名,然后点击右下角download下载到本地</code></p>
<pre><code>类名使用的时候需要icon-add_circle    
&lt;span class=&apos;icon-add_circle&apos;&gt;&lt;/span&gt;
</code></pre><p><img src="http://ww3.sinaimg.cn/mw690/908edb0egw1fajg748jzuj20s50o30v0.jpg" alt=""></p>
<p><code>6.把下载下来的font和style.css拷贝到项目目录下</code><br><img src="http://ww1.sinaimg.cn/mw690/908edb0egw1fajg74le3kj206u040wen.jpg" alt=""></p>
<p><code>7.使用方式如下，直接引入css文件，用color和font-size改变颜色和大小</code><br>​<br>    &lt;!DOCTYPE html&gt;<br>    <html lang="en"><br>    <head><br>        <meta charset="UTF-8"><br>        <title>Document</title><br>        <link rel="stylesheet" href="style.css"><br>        <style><br>            span{<br>                color: red;<br>                font-size: 56px;<br>            }<br>        </style><br>    </head><br>    <body><br>        <span class="icon-add_circle"></span><br>    </body><br>    </html></p>
<h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/09/SVG图标使用/" class="archive-article-date">
  	<time datetime="2016-12-09T08:11:35.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG/">SVG</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-CSS布局之Stickyfooters" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/08/CSS布局之Stickyfooters/">CSS布局之Stickyfooters</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在网页设计中，Sticky footers设计是最古老和最常见的效果之一，大多数人都曾经经历过。它可以概括如下：如果页面内容不够长的时候，页脚块粘贴在视窗底部；如果内容足够长时，页脚块会被内容向下推送。</p>
</blockquote>
<h2 id="这里说2个实现的原理"><a href="#这里说2个实现的原理" class="headerlink" title="这里说2个实现的原理"></a>这里说2个实现的原理</h2><pre><code>因为兼容性问题，请在高端浏览器或手机端使用~
</code></pre><h3 id="1-使用CSS取值函数calc"><a href="#1-使用CSS取值函数calc" class="headerlink" title="1.使用CSS取值函数calc()"></a>1.使用CSS取值函数calc()</h3><p><code>注意运算符的前后一定要➕空格</code></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        *{margin:0;}
        header,footer{
            height: 50px;
            color: red;
            background: #000;
        }
        div{
            background: blue;
            min-height: calc(100vh - 100px);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;头部&lt;/header&gt;
    &lt;div&gt;内容部分&lt;/div&gt;
    &lt;footer&gt;底部&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><em>效果就不展示了，自己建一个html运行一下吧…</em><br>​    </p>
<h3 id="2-使用flex布局"><a href="#2-使用flex布局" class="headerlink" title="2.使用flex布局"></a>2.使用flex布局</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        *{margin:0;}
        body{
            display: flex;
            flex-direction: column;
            min-height: 100vh;   //给body一个最小的高度
        }
        header,footer{
            height: 50px;
            color: red;
            background: #000;
        }
        div{
            background: blue;
            flex:1;  //头部底部固定，中间占据剩余空间
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;头部&lt;/header&gt;
    &lt;div&gt;内容部分&lt;/div&gt;
    &lt;footer&gt;底部&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="OVRE"><a href="#OVRE" class="headerlink" title="OVRE"></a>OVRE</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/08/CSS布局之Stickyfooters/" class="archive-article-date">
  	<time datetime="2016-12-08T08:28:46.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-手机端自适应单位换算" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/07/手机端自适应单位换算/">手机端自适应单位换算</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="移动端自适应布局之单位换算"><a href="#移动端自适应布局之单位换算" class="headerlink" title="移动端自适应布局之单位换算"></a>移动端自适应布局之单位换算</h1><h2 id="首先头部全部需要引入如下文件"><a href="#首先头部全部需要引入如下文件" class="headerlink" title="首先头部全部需要引入如下文件"></a>首先头部全部需要引入如下文件</h2><p><a href="https://github.com/Jasonellen/relyOn/blob/master/手机端头部文件/flexible.debug.js" target="_blank" rel="external">flexible.debug.js</a> + <a href="https://github.com/Jasonellen/relyOn/blob/master/手机端头部文件/flexible_css.debug.js" target="_blank" rel="external">flexible_css.debug.js</a>+<a href="https://github.com/Jasonellen/relyOn/blob/master/手机端头部文件/update.js" target="_blank" rel="external">update.js</a></p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><pre><code>使用cssrem+sublime,布局开始时，设置配置文件（例如：视觉稿640*1136）就设置为64
width:100p + tab 自动生成rem单位
</code></pre><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p><code>使用这个源文件还是px，容易修改，上面的源文件都改为rem了</code><br>    使用gulp转换<br>    npm install gulp-postcss</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var postcss = require(&apos;gulp-postcss&apos;);
var px2rem = require(&apos;postcss-px2rem&apos;);

             //这里的75和cssrem一样根据视觉稿更改
gulp.task(&apos;default&apos;, function() {
      var processors = [px2rem({remUnit: 75})];
       return gulp.src(&apos;./src/*.css&apos;)
        .pipe(postcss(processors))
        .pipe(gulp.dest(&apos;./dest&apos;));
    });
</code></pre><h2 id="vue文件"><a href="#vue文件" class="headerlink" title=".vue文件"></a>.vue文件</h2><pre><code>这个和方式一相同，可以直接在sublime中使用
</code></pre><p>​<br>​    </p>
<h2 id="react-native"><a href="#react-native" class="headerlink" title="react native"></a>react native</h2><pre><code>import {Dimensions} from &apos;react-native&apos;;
//app 只有竖屏模式，所以可以只获取一次 width
const deviceWidthDp = Dimensions.get(&apos;window&apos;).width;
// UI 默认给图是 640
const uiWidthPx = 640;

function pxToDp(uiElementPx) {
    return uiElementPx *  deviceWidthDp / uiWidthPx;
}
export default pxToDp;


调用方法
import pxToDp from &apos;./pxToDp&apos;;
&lt;View style={{width:pxToDp(100),height:pxToDp(100)}}&gt;&lt;/View&gt;
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/07/手机端自适应单位换算/" class="archive-article-date">
  	<time datetime="2016-12-07T14:13:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动端/">移动端</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Jasonellen
    	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>

  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/CDN加速/" style="font-size: 10px;">CDN加速</a> <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/ES6/" style="font-size: 13.33px;">ES6</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IScroll/" style="font-size: 10px;">IScroll</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JS试题/" style="font-size: 10px;">JS试题</a> <a href="/tags/MYSQL/" style="font-size: 13.33px;">MYSQL</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/ReactNative/" style="font-size: 13.33px;">ReactNative</a> <a href="/tags/Rem适配/" style="font-size: 10px;">Rem适配</a> <a href="/tags/SVG/" style="font-size: 10px;">SVG</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/UpLoad/" style="font-size: 10px;">UpLoad</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a> <a href="/tags/ZnPicker/" style="font-size: 10px;">ZnPicker</a> <a href="/tags/canvas/" style="font-size: 16.67px;">canvas</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/filter/" style="font-size: 10px;">filter</a> <a href="/tags/import/" style="font-size: 10px;">import</a> <a href="/tags/jQuery/" style="font-size: 13.33px;">jQuery</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/mobiscroll/" style="font-size: 10px;">mobiscroll</a> <a href="/tags/moment/" style="font-size: 10px;">moment</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/package/" style="font-size: 10px;">package</a> <a href="/tags/php/" style="font-size: 16.67px;">php</a> <a href="/tags/react/" style="font-size: 16.67px;">react</a> <a href="/tags/react-router/" style="font-size: 10px;">react-router</a> <a href="/tags/regexp/" style="font-size: 13.33px;">regexp</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/tips/" style="font-size: 10px;">tips</a> <a href="/tags/upload/" style="font-size: 10px;">upload</a> <a href="/tags/userAgent/" style="font-size: 10px;">userAgent</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/异步函数/" style="font-size: 10px;">异步函数</a> <a href="/tags/弹球/" style="font-size: 10px;">弹球</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/移动端/" style="font-size: 13.33px;">移动端</a> <a href="/tags/简版日历/" style="font-size: 10px;">简版日历</a> <a href="/tags/运算符/" style="font-size: 10px;">运算符</a> <a href="/tags/配置文件/" style="font-size: 10px;">配置文件</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cn.bing.com/">必应</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://gold.xitu.io/">掘金</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="//vuefe.cn/guide/">Vue</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">百度</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://yaomengyyu.github.io/">家浩</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://wangyalijas.github.io/">王雅丽</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;我只是想学记录点东西&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>


    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>
</div>
  </div>
</body>
</html>