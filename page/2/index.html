<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <meta name="baidu-site-verification" content="ggTdcuuNh2" />
  <link rel="dns-prefetch" href="http://Jasonellen.github.io">
  <title>奋斗蚁🐜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="奋斗蚁🐜">
<meta property="og:url" content="http://Jasonellen.github.io/page/2/index.html">
<meta property="og:site_name" content="奋斗蚁🐜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="奋斗蚁🐜">
  
    <link rel="alternative" href="/atom.xml" title="奋斗蚁🐜" type="application/atom+xml">
  
  
    <link rel="icon" href="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jasonellen</a></h1>
		</hgroup>

		
		<p class="header-subtitle">前端拼搏中的小小蚁🐜</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">文章列表</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="//github.com/Jasonellen/" title="github">github</a>
		        
			</div>
		</nav>
	</header>			
</div>



      <div class="ball" style=' width:100px;
            height:100px;
            position: absolute;
            bottom:0;
            left:200px;
            background: url(http://img3.imgtn.bdimg.com/it/u=2342940863,4159168232&fm=23&gp=0.jpg) no-repeat;
            background-size:contain;
            border-radius:50%;
      '>
      </div>

        <script>
            var ball = document.querySelector(".ball");
            gravBall(ball);

            function gravBall(obj){
                var timer = null;
                var speedX =0, speedY=0,x=0,y=0;
                var gapX =0, gapY=0;

                // obj.onmousedown = down;
                addHandler(obj,'mousedown',down);
                addHandler(obj,'mouseup',up);

                function down(ev){           
                    clearInterval(timer); 
                    var ev = ev || window.event;
                    gapX = ev.clientX - obj.offsetLeft;
                    gapY = ev.clientY - obj.offsetTop;
                    addHandler(document,'mousemove',move);    
                }
                function up(){
                    var currentX=0,currentY=0,l=0,t=0;
                    removeHandler(document,'mousemove',move)
                    clearInterval(timer); 
                    timer = setInterval(function(){
                        speedY +=3;  //一直有一个Y方向的增加，仿重力
                        currentX = window.innerWidth - obj.offsetWidth;
                        currentY = window.innerHeight - obj.offsetHeight;
                        l = obj.offsetLeft + speedX;
                        t = obj.offsetTop + speedY;
                        //speedY +=3;  //放在这里就是先判断再+3，根本停不下来
                        if(l > currentX){
                            speedX *= -0.8;
                            l =currentX;
                        }
                        if(l < 0){
                            speedX *= -0.8;
                            l = 0;
                        }
                        if(t > currentY){
                            speedY *= -0.8;
                            speedX *= 0.8;
                            t = currentY;
                        }
                        if(t < 0){
                            speedY *= -0.8;
                            speedX *= 0.8;
                            t = 0;
                        }
                        if( Math.abs(t-currentY)<1 && Math.abs(speedY)<1.5 && Math.abs(speedX)<1.5){
                            clearInterval(timer);
                        }
                        obj.style.left = l  + "px";
                        obj.style.top = t  + "px";
                    },30)
                }

                function move(ev){
                    var ev = ev || window.event;
                    //难点一，记录当前速度 是最后一次的offsetLeft减去上一次的offsetLeft
                    speedX = ev.clientX - x - gapX;
                    speedY = ev.clientY - y - gapY;
                    //记录本次的offsetLeft作为下一次移动的的上一次的offsetLeft；
                    x = obj.offsetLeft;
                    y = obj.offsetTop;
                    var evX = ev.clientX;
                    var evY = ev.clientY;
                    if(ev.clientX<gapX || ev.clientX>window.innerWidth-gapX || ev.clientY<0 || ev.clientY>window.innerHeight){
                        up();
                    }
                    obj.style.left = evX - gapX  + "px";
                    obj.style.top = evY - gapY  + "px";
                }
            }


            function addHandler(element,type,handler){
                if(element.addEventListener){//检测是否为DOM2级方法
                    element.addEventListener(type, handler, false);
                }else if (element.attachEvent){//检测是否为IE级方法
                    element.attachEvent("on" + type, handler);
                } else {//检测是否为DOM0级方法
                    element["on" + type] = handler;
                }
            }
             function removeHandler(element, type, handler){
                if (element.removeEventListener){
                    element.removeEventListener(type, handler, false);
                } else if (element.detachEvent){
                    element.detachEvent("on" + type, handler);
                } else {
                    element["on" + type] = null;
                }
            }  
        </script>  
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Jasonellen</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Jasonellen</h1>
			</hgroup>
			
			<p class="header-subtitle">前端拼搏中的小小蚁🐜</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="//github.com/Jasonellen/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-import" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/import/">import</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>作为一个初学者，在如何导入/导出自己写的组件时，有时也是摸不着头脑，想我当年一样喽☺</p>
</blockquote>
<h1 id="下面列举几个常见的栗子🌰"><a href="#下面列举几个常见的栗子🌰" class="headerlink" title="下面列举几个常见的栗子🌰"></a>下面列举几个常见的栗子🌰</h1><h3 id="1-import-React-Component-from-‘react’"><a href="#1-import-React-Component-from-‘react’" class="headerlink" title="1. import React ,{ Component } from ‘react’;"></a>1. import React ,{ Component } from ‘react’;</h3><pre><code>这是RN 0.26后导入React的方式，这意思是，导入‘react’文件里export的一个默认的组件，将其命名为React以及Component这个非默认组件
</code></pre><p>​    </p>
<h3 id="2-import-Home-from-‘-Home’"><a href="#2-import-Home-from-‘-Home’" class="headerlink" title="2.import Home from ‘./Home’;"></a>2.import Home from ‘./Home’;</h3><pre><code>这是导入‘Home’文件里export的带default关键字的组件，即默认组件,将其命名为Home(可以自定义命名)
</code></pre><p><img src="http://wx4.sinaimg.cn/mw690/908edb0egy1fckd559kn5j20ea0b43z3.jpg" alt=""></p>
<h3 id="3-import-Home-from-‘-Home’"><a href="#3-import-Home-from-‘-Home’" class="headerlink" title="3.import { Home } from ‘./Home’;"></a>3.import { Home } from ‘./Home’;</h3><pre><code>导入‘Home’文件里export的叫Home的 非默认组件，注意，非默认，非默认，非默认，以及命名Home,命名Home,命名Home
</code></pre><p>​    </p>
<h3 id="4-import-Home-Discover-from-‘-Home’"><a href="#4-import-Home-Discover-from-‘-Home’" class="headerlink" title="4.import { Home , Discover } from ‘/Home’;"></a>4.import { Home , Discover } from ‘/Home’;</h3><pre><code>跟3的差不多，不过是{  },可以导入多个组件，用，隔开就可以
</code></pre><p>​    </p>
<h3 id="5-import-as-Home-from’-compoments-Home’"><a href="#5-import-as-Home-from’-compoments-Home’" class="headerlink" title="5.import * as Home from’./compoments/Home’;"></a>5.import * as Home from’./compoments/Home’;</h3><pre><code>意思是将./compoments/Home&apos;文件里的所有非默认组件，全部集结成一个Home模型组件，命名可以自定义，然后可以通过点语法，来使用组件里面的所有export的组件，例如：
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/908edb0egy1fckda4pc8gj20hx0bgmy0.jpg" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/21/import/" class="archive-article-date">
  	<time datetime="2017-02-21T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/import/">import</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-redux入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/redux入门/">redux入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>个人只是把redux和vuex当做进行统一状态管理的工具，那个和上一篇vuex一样，这里还是举个相同的加减栗子来对redux做个入门介绍</p>
</blockquote>
<h1 id="Redux-基础概念"><a href="#Redux-基础概念" class="headerlink" title="Redux 基础概念"></a>Redux 基础概念</h1><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><pre><code>State 描述一个应用程序的全部状态,所有需要控制的状态都应设计到 state 对象中
</code></pre><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><pre><code>Action 用来描述一个行为，并负载相应的信息。
</code></pre><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><pre><code>Reducer 接收两个参数，第一个参数是当前状态，而第二参数是 action, 返回更新后的状态。
用来执行store触发的Action对应的方法
</code></pre><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><pre><code>Store 是管理应用程序 state 的容器

store = {
    getState,
    dispatch,
    subscribe,
    replaceReducer
}
</code></pre><h4 id="如上，store共有4个API"><a href="#如上，store共有4个API" class="headerlink" title="如上，store共有4个API,"></a>如上，store共有4个API,</h4><pre><code>getState: (数据接口)
使用方式: store.getState()
功能点: redux对外导出数据的接口(getter)

subscribe: (订阅接口)
使用方式: store.subscribe(回调函数)
功能点: 在每次执行dispatch的时候，用于执行自定义的回调函数操作

dispatch: (执行接口)
使用方式: store.dispatch(action)
功能点: 在执行redux的state更新的同时，执行所有subscribe过的回调函数

replaceReducer: (重置store接口)
使用方式: store.replaceReducer(nextReducer)
功能点: 重置redux的reducer，重新启动store流程
</code></pre><h3 id="流程图如下"><a href="#流程图如下" class="headerlink" title="流程图如下"></a>流程图如下</h3><p><img src="http://wx4.sinaimg.cn/mw690/908edb0egy1fchwn37a5fj20jf0d5mx6.jpg" alt=""></p>
<h2 id="项目实战："><a href="#项目实战：" class="headerlink" title="项目实战："></a>项目实战：</h2><p><strong>首先安装redux到项目中</strong></p>
<pre><code>npm install --save redux
</code></pre><p><strong>代码编写</strong></p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><pre><code>&lt;p&gt;
    Clicked: &lt;span id=&quot;value&quot;&gt;0&lt;/span&gt;
    &lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt;
    &lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt;
&lt;/p&gt;
</code></pre><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><pre><code>//导入createStroe
import { createStore } from &apos;redux&apos;

//初始化状态
let initState = {
      count: 0,
      score: 0,
      description:&apos;描述&apos;
}

//创建一个Reducer
function counter(state = initState, action) {
    switch (action.type) {
        case &apos;INCREMENT&apos;:
              return{
                  count:state.count + 1,
                score:state.score + 2,
                description:action.data
              } 
        case &apos;DECREMENT&apos;:
              return{
                  count:state.count - 1,
                score:state.score - 2,
                description:action.data
              } 
        default:
              return state;
          }
    }

//将创建好的Reducer传入创建Store
let store = Redux.createStore(counter);

//获取元素节点，并绑定点击事件，点击后store将触发相应的动作Action
let valueEl = document.getElementById(&apos;value&apos;);
document.getElementById(&apos;increment&apos;).addEventListener(&apos;click&apos;, function() {
    store.dispatch({
          type: &apos;INCREMENT&apos;,
          data:&apos;增加的&apos;
    })
})
document.getElementById(&apos;decrement&apos;).addEventListener(&apos;click&apos;, function() {
    store.dispatch({
          type: &apos;DECREMENT&apos;,
          data:&apos;减少的&apos;,
    })
})

//写一个render方法，在这里动态改变元素的内容
function render() {
    valueEl.innerHTML = &apos;点击&apos;+store.getState().count.toString()+&apos;次-得        分&apos;+store.getState().score.toString()+store.getState().description;
}

//执行render方法
render();

//绑定subscribe回调
store.subscribe(render);
</code></pre><h5 id="上述JS文件，当按钮点击的时候-redux的状态管理者store调用dispatch-API触发相应type的Action-然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl-innerHTML的值并没有改变，此时需要调用store-subscribe-render-函数执行回调函数render"><a href="#上述JS文件，当按钮点击的时候-redux的状态管理者store调用dispatch-API触发相应type的Action-然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl-innerHTML的值并没有改变，此时需要调用store-subscribe-render-函数执行回调函数render" class="headerlink" title="上述JS文件，当按钮点击的时候 redux的状态管理者store调用dispatch API触发相应type的Action,然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl.innerHTML的值并没有改变，此时需要调用store.subscribe(render)函数执行回调函数render()"></a>上述JS文件，当按钮点击的时候 redux的状态管理者store调用dispatch API触发相应type的Action,然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl.innerHTML的值并没有改变，此时需要调用store.subscribe(render)函数执行回调函数render()</h5><h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/21/redux入门/" class="archive-article-date">
  	<time datetime="2017-02-21T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redux入门/">redux入门</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-fetch_faild_in_reactnative" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/fetch_faild_in_reactnative/">fetch faild in reactnative</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>fetch在ReactNative中可能会报错如下：Possible unhandled promise rejection (id:0: Network request failed</p>
</blockquote>
<h3 id="According-to-this-post-you-should-enable-it-in-XCode"><a href="#According-to-this-post-you-should-enable-it-in-XCode" class="headerlink" title="According to this post, you should enable it in XCode."></a>According to this post, you should enable it in XCode.</h3><ol>
<li>Click on your project in the Project Navigator</li>
<li>Open the Info tab</li>
<li>Click on the down arrow left to the “App Transport Security Settings”</li>
<li>Right click on “App Transport Security Settings” and select Add Row</li>
<li>For created row set the key “Allow Arbitrary Loads“, type to boolean and value to YES.</li>
</ol>
<p><img src="http://wx4.sinaimg.cn/mw690/908edb0egy1fd057agsrdj20hk07yjuv.jpg" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/14/fetch_faild_in_reactnative/" class="archive-article-date">
  	<time datetime="2017-02-14T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fetch-faild-in-reactnative/">fetch faild in reactnative</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/24/vuex/">vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>关于vuex到底是什么，看到眼热就去查了下资料，然后扯出来一堆flux、redux、state、state之类的概念，以及大型工程必要性之类的，我只想说，整这么复杂干什么？走远了..</p>
</blockquote>
<h1 id="什么是vuex-作用又是什么？"><a href="#什么是vuex-作用又是什么？" class="headerlink" title="什么是vuex,作用又是什么？"></a>什么是vuex,作用又是什么？</h1><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态 。这里的关键在于 集中式存储管理 。这意味着本来需要共享状态的更新是需要组件之间通讯的，而现在有了vuex，就组件就都和store通讯了</p>
<h3 id="简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件"><a href="#简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件" class="headerlink" title="简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件"></a>简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件</h3><p><code>应用场景：</code><br></p>
<ul>
<li>多个组件依赖于同一状态。传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</li>
<li>来自不同组件的行为需要变更同一状态。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><strong>当我们需要制作一个加一，减一操作按钮的时候，用下面两个demo做一个演示</strong><h3 id="未使用vuex"><a href="#未使用vuex" class="headerlink" title="未使用vuex"></a>未使用vuex</h3></li>
<li>单纯依赖于vue.js</li>
</ul>
</blockquote>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot;&gt;
      &lt;p&gt;{{count}}
            &lt;button @click=&quot;inc&quot;&gt;+&lt;/button&gt;
            &lt;button @click=&quot;dec&quot;&gt;-&lt;/button&gt;
      &lt;/p&gt;
  &lt;/div&gt;
  &lt;script&gt;
  new Vue({
    el:&apos;#app&apos;,
    data () {
      return {
        count: 0
      }
    },
    methods: {
      inc () {
        this.count++
      },
      dec () {
        this.count--
      }
    }
  })
  &lt;/script&gt;
</code></pre><p>  整个代码结构非常清晰，代码是代码，数据是数据，代码就是放在methods数组内的两个函数inc、dec，被指令@click关联到button上。而data内返回一个属性count，此属性通过绑定到标签p内。从而可以动态的改为count的值。</p>
<h2 id="使用vuex"><a href="#使用vuex" class="headerlink" title="使用vuex"></a>使用vuex</h2><ul>
<li><p>依赖vue.js，也使用了vuex技术</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/vuex@next&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{count}}
        &lt;button @click=&quot;inc&quot;&gt;+&lt;/button&gt;
        &lt;button @click=&quot;dec&quot;&gt;-&lt;/button&gt;
    &lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    const store = new Vuex.Store({
        state: {
          count: 0
        },
        mutations: {
            inc: state =&gt; state.count++,
          dec: state =&gt; state.count--
        }
    })
      const app = new Vue({
        el: &apos;#app&apos;,
        computed: {
          count () {
             return store.state.count
          }
        },
        methods: {
          inc () {
                store.commit(&apos;inc&apos;) //执行store.inc放大
          },
          dec () {
              store.commit(&apos;dec&apos;)
          }
        }
    })
&lt;/script&gt;
</code></pre><h4 id="我们先看到有哪些重要的变化："><a href="#我们先看到有哪些重要的变化：" class="headerlink" title="我们先看到有哪些重要的变化："></a>我们先看到有哪些重要的变化：</h4></li>
</ul>
<ol>
<li>新的代码添加了对vuex@next脚本的依赖。这是当然的，因为你需要使用vuex的技术，当然需要引用它</li>
<li>methods数组还是这两个方法，这和demo1是一样的；但是方法内的计算逻辑，不再是在函数内进行，而是提交给store对象！这是一个新的对象！</li>
<li>count数据也不再是一个data函数返回的对象的属性；而是通过计算字段来返回，并且在计算字段内的代码也不是自己算的，而是转发给store对象</li>
<li>store对象是Vuex.Store的实例。在store内有分为state对象和mutations对象，其中的state放置 状态 ,mutations则是一个会引发状态改变的所有方法。正如我们看到的，目前的state对象，其中的状态就只有一个count。而mutations有两个成员，它们参数为state，在函数体内对state内的count成员做加1和减1的操作。</li>
</ol>
<p><strong>总结：</strong>就是说，之前在vue实例内做的操作和数据的计算现在都不再自己做了，而是交由对象store来做了。</p>
<h4 id="用了vuex感觉更复杂了？"><a href="#用了vuex感觉更复杂了？" class="headerlink" title="用了vuex感觉更复杂了？"></a>用了<code>vuex</code>感觉更复杂了？</h4><p>你的感觉没错，这就是为什么官网再次会提到Vuex构建大型应用的价值。 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex 。</p>
<h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/24/vuex/" class="archive-article-date">
  	<time datetime="2017-01-24T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vuex/">vuex</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-扒一扒jquery的几个技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/21/扒一扒jquery的几个技巧/">扒一扒JQuery的几个技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-jQuery方法-实际上是拥有两个参数的"><a href="#1-jQuery方法-实际上是拥有两个参数的" class="headerlink" title="1.jQuery方法$()实际上是拥有两个参数的"></a>1.jQuery方法$()实际上是拥有两个参数的</h3><h5 id="Create-an-element-The-second-argument-is-an-object-with-jQuery-methods-to-be-called"><a href="#Create-an-element-The-second-argument-is-an-object-with-jQuery-methods-to-be-called" class="headerlink" title="Create an element. The second argument is an object with jQuery methods to be called"></a>Create an element. The second argument is an object with jQuery methods to be called</h5><pre><code>var div = $(&apos;&lt;div&gt;&apos;,{
    &quot;class&quot;: &quot;bigBlue&quot;,
    &quot;css&quot;: {
        &quot;background-color&quot;:&quot;purple&quot;,
        &quot;width&quot; : 20,
        &quot;height&quot;: 20,
    },
    &quot;animate&quot; : {   // You can use any jQuery method as a property!
        &quot;width&quot;: 200,
        &quot;height&quot;:50
    }
});

div.appendTo(&apos;#eleID&apos;);
</code></pre><h3 id="2-使用js给多个元素添加样式时更好的做法是创建一个style元素。"><a href="#2-使用js给多个元素添加样式时更好的做法是创建一个style元素。" class="headerlink" title="2.使用js给多个元素添加样式时更好的做法是创建一个style元素。"></a>2.使用js给多个元素添加样式时更好的做法是创建一个style元素。</h3><pre><code>var style = $(&apos;&lt;style&gt;&apos;);
// Try commenting out this line, or change the color:
style.text(&apos;.div{ color:red;}&apos;);
style.prependTo(&apos;body&apos;);
</code></pre><h3 id="3-阻止contextmenu默认事件。（右键菜单）"><a href="#3-阻止contextmenu默认事件。（右键菜单）" class="headerlink" title="3.阻止contextmenu默认事件。（右键菜单）"></a>3.阻止contextmenu默认事件。（右键菜单）</h3><pre><code>$(document).on(&quot;contextmenu&quot;,function(e){
    e.preventDefault();
});
</code></pre><h3 id="4-监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。"><a href="#4-监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。" class="headerlink" title="4.监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。"></a>4.监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。</h3><pre><code>var list = $(&apos;#testList&apos;);
// Binding an event on the list, but listening for events on the li items:
list.on(&apos;click&apos;,&apos;li&apos;,function(){
    $(this).remove();
});
// This allows us to create li elements at a later time,
// while keeping the functionality(功能) in the event listener
list.append(&apos;&lt;li&gt;New item (click me!)&lt;/li&gt;&apos;);
</code></pre><h3 id="5-使用trigger模拟触发一个click等事件或其他自定义事件。"><a href="#5-使用trigger模拟触发一个click等事件或其他自定义事件。" class="headerlink" title="5.使用trigger模拟触发一个click等事件或其他自定义事件。"></a>5.使用trigger模拟触发一个click等事件或其他自定义事件。</h3><pre><code>// Just a regular event listener:
press.on(&apos;click&apos;,function(e, how){
    how = how || &apos;&apos;;
    alert(&apos;The buton was clicked &apos; + how + &apos;!&apos;);
});

// Trigger the click event
press.trigger(&apos;click&apos;);

// Trigger it with an argument   也可以自定义事件
press.trigger(&apos;click&apos;,[&apos;fast&apos;]);
</code></pre><h3 id="6-传递参数到e-data执行供执行的函数使用"><a href="#6-传递参数到e-data执行供执行的函数使用" class="headerlink" title="6.传递参数到e.data执行供执行的函数使用"></a>6.传递参数到e.data执行供执行的函数使用</h3><pre><code>//参数只会之心过一次，所以下面的random不管自行几次都是相同的结果
$(document).on(&apos;click&apos;, Math.round(Math.random()*20), function(e){
    // This will print the same number over and over again,
    // as the random number above is generated only once:
    console.log(&apos;Random number: &apos; + e.data,e.target);
});
</code></pre><h3 id="7-Using-event-delegation-事件代理"><a href="#7-Using-event-delegation-事件代理" class="headerlink" title="7.Using event delegation 事件代理"></a>7.Using event delegation 事件代理</h3><pre><code>$(&apos;#holder&apos;).on(&apos;click&apos;, &apos;#clear&apos;, function(){
    clear();
});
</code></pre><h3 id="8-绑定多个事件"><a href="#8-绑定多个事件" class="headerlink" title="8.绑定多个事件"></a>8.绑定多个事件</h3><pre><code>clear.on(&apos;mouseup click&apos;,function(){
    //...
})

clear.on({
    &apos;mousedown&apos;:function(){
       // ...
    },
    &apos;mouseup&apos;:function(){
        // ...
    }
});
</code></pre><h3 id="9-阻止默认事件"><a href="#9-阻止默认事件" class="headerlink" title="9.阻止默认事件"></a>9.阻止默认事件</h3><h5 id="更快地阻止默认事件行为。"><a href="#更快地阻止默认事件行为。" class="headerlink" title="更快地阻止默认事件行为。"></a>更快地阻止默认事件行为。</h5><pre><code>$(&apos;#goToGoogle&apos;).click(false);
</code></pre><h5 id="函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，-链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。"><a href="#函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，-链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。" class="headerlink" title="函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，\链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。"></a>函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，\<a>链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。</a></h5><pre><code>$(&apos;#goToGoogle&apos;).click(function(){
    return false;
});
</code></pre><h3 id="10-平行的运行多个Ajax请求。"><a href="#10-平行的运行多个Ajax请求。" class="headerlink" title="10.平行的运行多个Ajax请求。"></a>10.平行的运行多个Ajax请求。</h3><h5 id="当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。"><a href="#当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。" class="headerlink" title="当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。"></a>当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。</h5><pre><code>// The trick is in the $.when() function:
$.when($.get(&apos;assets/misc/1.json&apos;), $.get(&apos;assets/misc/2.json&apos;)).then(function(r1, r2){
    log(r1[0].message + &quot; &quot; + r2[0].message);
});
</code></pre><h3 id="11-jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。"><a href="#11-jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。" class="headerlink" title="11.jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。"></a>11.jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。</h3><pre><code>&lt;p class=&quot;content&quot;&gt;&lt;/p&gt; &lt;p class=&quot;content&quot;&gt;&lt;/p&gt;
var contentDivs = $(&apos;.content&apos;);
// Fetch the contents of a text file:
contentDivs.eq(0).load(&apos;1.txt&apos;);
// Fetch the contents of a HTML file, and display a specific element:
contentDivs.eq(1).load(&apos;1.html #header&apos;);
</code></pre><h3 id="12-JQuery扩展"><a href="#12-JQuery扩展" class="headerlink" title="12.JQuery扩展"></a>12.JQuery扩展</h3><h5 id="jQuery-prototype-jQuery-fn-jQuery-fn-init-prototype"><a href="#jQuery-prototype-jQuery-fn-jQuery-fn-init-prototype" class="headerlink" title="jQuery.prototype = jQuery.fn = jQuery.fn.init.prototype"></a>jQuery.prototype = jQuery.fn = jQuery.fn.init.prototype</h5><pre><code>$.fn.abs=function(){
    console.log(&apos;abs&apos;)
}
$(document).abs();
</code></pre><h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/21/扒一扒jquery的几个技巧/" class="archive-article-date">
  	<time datetime="2017-01-21T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/扒一扒JQuery的几个技巧/">扒一扒JQuery的几个技巧</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-开启一个简单的cdn加速" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/开启一个简单的cdn加速/">开启一个简单的CDN加速</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>cdn加速是通过一个服务器集群对网站内容建立缓存和镜像，并且通过对网页静态资源的压缩来加快网站的最终访问速度，但是对于大部分的个人网站或者普通企业网站来说，自己建立cdn加速的服务器集群是一笔较高的费用，而且需要专业的技术。这里说一种最简单的网站cdn加速方法。</p>
</blockquote>
<p><img src="http://a.hiphotos.baidu.com/exp/w=500/sign=c93d5757c15c1038247ecec28210931c/d4628535e5dde711b08214bba0efce1b9d16612e.jpg" alt=""></p>
<p><strong>备注：CDN只是在你的服务器给出数据之后，进行加快传输。举个例子，你的服务器响应是10秒，网络传输占2秒，整体是12秒响应。而CDN可以将你的网络传输2秒加速到1秒，但是你的服务器吐出查询数据还是10秒，整体时间是11秒。</strong></p>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><h4 id="1-登陆百度云加速网站：su-baidu-com-也可以直接百度搜索“百度云加速”找到官网地址。"><a href="#1-登陆百度云加速网站：su-baidu-com-也可以直接百度搜索“百度云加速”找到官网地址。" class="headerlink" title="1.登陆百度云加速网站：su.baidu.com 也可以直接百度搜索“百度云加速”找到官网地址。"></a>1.登陆百度云加速网站：su.baidu.com 也可以直接百度搜索“百度云加速”找到官网地址。</h4><p><img src="http://d.hiphotos.baidu.com/exp/w=500/sign=3f0b53d0ccef76093c0b999f1edca301/9825bc315c6034a86d20efcccc134954082376b8.jpg" alt=""></p>
<h4 id="2-然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。"><a href="#2-然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。" class="headerlink" title="2.然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。"></a>2.然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。</h4><p><img src="http://g.hiphotos.baidu.com/exp/w=500/sign=a65259542af5e0feee1889016c6134e5/6609c93d70cf3bc7c9709ba1d600baa1cd112a0e.jpg" alt=""></p>
<h4 id="3-进入我的网站管理界面后，点击“添加网站”按钮。"><a href="#3-进入我的网站管理界面后，点击“添加网站”按钮。" class="headerlink" title="3.进入我的网站管理界面后，点击“添加网站”按钮。"></a>3.进入我的网站管理界面后，点击“添加网站”按钮。</h4><p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=4729466292cad1c8d0bbfc274f3f67c4/0824ab18972bd407429d85b07c899e510fb30920.jpg" alt=""></p>
<h4 id="4-在添加网站页面，输入你的网址（不带http-和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”"><a href="#4-在添加网站页面，输入你的网址（不带http-和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”" class="headerlink" title="4.在添加网站页面，输入你的网址（不带http://和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”"></a>4.在添加网站页面，输入你的网址（不带<a href="http://和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”" target="_blank" rel="external">http://和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”</a></h4><p><img src="http://f.hiphotos.baidu.com/exp/w=500/sign=6d4dfc5f750e0cf3a0f74efb3a47f23d/9213b07eca806538f1c8f55e90dda144ad348259.jpg" alt=""></p>
<h4 id="5-如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。"><a href="#5-如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。" class="headerlink" title="5.如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。"></a>5.如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。</h4><p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=c6afe4b63edbb6fd255be5263925aba6/cefc1e178a82b901dde5937e748da9773912ef37.jpg" alt=""></p>
<h4 id="6-登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。"><a href="#6-登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。" class="headerlink" title="6.登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。"></a>6.登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。</h4><p><img src="http://b.hiphotos.baidu.com/exp/w=500/sign=053f52d559df8db1bc2e7c643922dddb/d000baa1cd11728b1e4fdf6fcffcc3cec3fd2c18.jpg" alt=""></p>
<h4 id="7-把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。"><a href="#7-把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。" class="headerlink" title="7.把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。"></a>7.把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。</h4><p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=827831339558d109c4e3a9b2e159ccd0/c2cec3fdfc03924589a4b3428094a4c27d1e256d.jpg" alt=""></p>
<h4 id="8-等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。"><a href="#8-等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。" class="headerlink" title="8.等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。"></a>8.等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。</h4><p><img src="http://g.hiphotos.baidu.com/exp/w=500/sign=29a31cb60d46f21fc9345e53c6256b31/0dd7912397dda144535d3effb5b7d0a20cf48623.jpg" alt=""></p>
<h4 id="9-生效后，我们就可以点击“配置选项”来配置网站的CDN加速-和-网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！"><a href="#9-生效后，我们就可以点击“配置选项”来配置网站的CDN加速-和-网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！" class="headerlink" title="9.生效后，我们就可以点击“配置选项”来配置网站的CDN加速 和 网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！"></a>9.生效后，我们就可以点击“配置选项”来配置网站的CDN加速 和 网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！</h4><p><img src="http://e.hiphotos.baidu.com/exp/w=500/sign=b7de0a5f484a20a4311e3cc7a0539847/342ac65c103853430f3ad56c9413b07ecb808882.jpg" alt=""></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>网站域名备案后才能使用百度云加速的国内CDN加速节点。</li>
<li>在dns修改并等待生效的时间内，不会影响网站的正常访问。</li>
</ul>
<h5 id="转自百度经验"><a href="#转自百度经验" class="headerlink" title="转自百度经验"></a>转自<a href="http://jingyan.baidu.com/article/fedf0737ac414f35ac897704.html" target="_blank" rel="external">百度经验</a></h5>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/16/开启一个简单的cdn加速/" class="archive-article-date">
  	<time datetime="2017-01-16T14:11:14.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开启一个简单的CDN加速/">开启一个简单的CDN加速</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-jQuery对象之deferred" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/08/jQuery对象之deferred/">jQuery对象之deferred</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>什么是deferred对象？简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。从而优雅的编写回调函数.</p>
</blockquote>
<h2 id="1-ajax操作写法"><a href="#1-ajax操作写法" class="headerlink" title="1,ajax操作写法"></a>1,ajax操作写法</h2><h3 id="非链式"><a href="#非链式" class="headerlink" title="非链式"></a>非链式</h3><pre><code>$.ajax({
   type:&apos;get&apos;
   url: &quot;test.html&quot;,
   success: function(){
          alert(&quot;哈哈，成功了！&quot;);
      },
      error:function(){
          alert(&quot;出错啦！&quot;);
      }
});
</code></pre><h3 id="链式"><a href="#链式" class="headerlink" title="链式"></a>链式</h3><p>高于1.5.0版本的jq，<code>ajax()返回的是deferred对象</code>，可以直接进行链式操作。</p>
<pre><code>$.ajax(&quot;test.html&quot;)
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><p>可以看到，<code>done()</code>相当于<code>success</code>方法，<code>fail()</code>相当于<code>error</code>方法。采用链式写法以后，代码的可读性大大提高。</p>
<p>如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？直接在结尾追加就好了，回调函数可以添加任意多个，它们按照添加顺序执行。像酱紫：</p>
<pre><code>$.ajax(&quot;test.html&quot;)
.done(function(){ alert(&quot;哈哈，成功了！&quot;);} )
.fail(function(){ alert(&quot;出错啦！&quot;); } )
.done(function(){ alert(&quot;第二个回调函数！&quot;);} );
.done(function(){ alert(&quot;第三个回调函数！&quot;);} );
</code></pre><h2 id="2-为多个操作指定回调函数"><a href="#2-为多个操作指定回调函数" class="headerlink" title="2,为多个操作指定回调函数"></a>2,为多个操作指定回调函数</h2><pre><code>$.when($.ajax(&quot;test1.html&quot;), $.ajax(&quot;test2.html&quot;))
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><p>这段代码的意思是，先执行两个操作<code>$.ajax(&quot;test1.html&quot;)</code>和<code>$.ajax(&quot;test2.html&quot;)</code>，如果都成功了，就运行<code>done()</code>指定的回调函数；如果有一个失败或都失败了，就执行<code>fail()</code>指定的回调函数。</p>
<h2 id="3-回调函数接口实现"><a href="#3-回调函数接口实现" class="headerlink" title="3,回调函数接口实现"></a>3,回调函数接口实现</h2><p>deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。</p>
<p>假定有一个很耗时的操作wait：</p>
<pre><code>function wait(){
    var tasks = function(){
        alert(&quot;执行完毕！&quot;);
    };
    setTimeout(tasks,5000);
};

为它指定回调函数: 错误❌的写法如下

$.when(wait())
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><p>上述写法，done()方法会立即执行，起不到回调函数的作用。原因在于<code>$.when()的参数只能是deferred对象</code>，所以必须对wait()进行改写：<br>​<br>    var dtd = $.Deferred(); // 新建一个deferred对象<br>    var wait = function(){<br>        var tasks = function(){<br>            alert(“执行完毕！”);<br>            dtd.resolve(); // 改变deferred对象的执行状态为已完成<br>        };<br>        setTimeout(tasks,5000);<br>        return dtd.promise();<br>    };<br>现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。<br>​<br>    $.when(wait())<br>    .done(function(){ alert(“哈哈，成功了！”); })<br>    .fail(function(){ alert(“出错啦！”); });</p>
<blockquote>
<p>jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待.<br>deferred.reject()方法，作用是将dtd对象的执行状态从”未完成”改为”已失败”，从而触发fail()方法。<br>jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被外界改变造成干扰。</p>
</blockquote>
<p><code>**********************************</code></p>
<h2 id="上面说些原理，下面是2种经常使用的回调接口方法"><a href="#上面说些原理，下面是2种经常使用的回调接口方法" class="headerlink" title="上面说些原理，下面是2种经常使用的回调接口方法"></a>上面说些原理，下面是2种经常使用的回调接口方法</h2><p><code>**********************************</code></p>
<h4 id="1，将deferred对象变成wait-）函数的内部对象。"><a href="#1，将deferred对象变成wait-）函数的内部对象。" class="headerlink" title="1，将deferred对象变成wait(）函数的内部对象。"></a>1，将deferred对象变成wait(）函数的内部对象。</h4><pre><code>function wait(){
    var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象
    var tasks = function(){
        alert(&quot;执行完毕！&quot;);
        dtd.resolve(); // 改变Deferred对象的执行状态
    };
    setTimeout(tasks,5000);
    return dtd.promise(); // 返回promise对象
};
$.when(wait())
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><h4 id="2，使用deferred对象的建构函数-Deferred"><a href="#2，使用deferred对象的建构函数-Deferred" class="headerlink" title="2，使用deferred对象的建构函数$.Deferred()"></a>2，使用deferred对象的建构函数$.Deferred()</h4><p>jQuery规定，$.Deferred()可以接受一个函数名<code>（注意，是函数名）--当然也是立即执行该函数</code>作为参数，<code>$.Deferred()所生成的deferred对象将作为这个函数的默认参数</code>。<br>​<br>    function wait(dtd){<br>        var tasks = function(){<br>            alert(“执行完毕！”);<br>            dtd.resolve(); // 改变Deferred对象的执行状态<br>        };<br>        setTimeout(tasks,5000);<br>        return dtd.promise(); // 返回promise对象<br>    };<br>    $.Deferred(wait)<br>    .done(function(){ alert(“哈哈，成功了！”); })<br>    .fail(function(){ alert(“出错啦！”); });</p>
<h3 id="小结：deferred对象的方法"><a href="#小结：deferred对象的方法" class="headerlink" title="小结：deferred对象的方法"></a>小结：deferred对象的方法</h3><ol>
<li>$.Deferred() 生成一个deferred对象。    </li>
<li>deferred.done() 指定操作成功时的回调函数</li>
<li>deferred.fail() 指定操作失败时的回调函数</li>
<li>deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。</li>
<li>deferred.resolve() 手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。</li>
<li>deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。</li>
<li>$.when() 为多个操作指定回调函数。<br><br><h4 id="除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。"><a href="#除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。" class="headerlink" title="除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。"></a>除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。</h4></li>
<li><p>deferred.then()有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。<br><br><code>$.when($.ajax( &quot;/main.php&quot; ))</code><br><br><code>.then(successFunc, failureFunc );</code><br><br>如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。</p>
</li>
<li><p>deferred.always()<br>这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。<br><br><code>$.ajax( &quot;test.html&quot; )</code><br></p>
<p><code>.always( function() { alert(&quot;已执行！&quot;);} );</code></p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/08/jQuery对象之deferred/" class="archive-article-date">
  	<time datetime="2017-01-08T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery对象之deferred/">jQuery对象之deferred</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-微信小程序实战，从入门到弃坑（转）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/03/微信小程序实战，从入门到弃坑（转）/">微信小程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="微信小程序实战，从入门到弃坑（转）"><a href="#微信小程序实战，从入门到弃坑（转）" class="headerlink" title="微信小程序实战，从入门到弃坑（转）"></a>微信小程序实战，从入门到弃坑（转）</h1><p><a href="http://www.jianshu.com/p/4433d46e6235" target="_blank" rel="external">原文链接</a></p>
<p>最近集中开发了两款微信小程序，分别是好奇心日历（每天一条辞典+一个小投票）和好奇心日报（轻量版），直接上图：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-6c7ccf0f8e3019b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>本文将结合具体的实战经验，主要介绍微信小程序的基础知识、开发中遇到的难点、项目的架构设计、最佳实践以及踩过的坑。<strong>文章内容较多，如果想看架构设计和躲坑技巧，请直接浏览后面的正文</strong>，简书没有目录，也挺伤感的。</p>
<p>值得再次声明的是：<strong>微信小程序的内容部分是hybrid模式，并非原生</strong>，所以性能并不好，绑定的tap事件也有明显的延迟。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-ef6d4c647e8b188c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图<em><code>每一个由边框围起来的部分，都是一个最小粒度的原生view</code></em>可以看出，整个微信小程序的内容部分，就是一个原生view。</p>
<h2 id="小程序有哪些基础知识？"><a href="#小程序有哪些基础知识？" class="headerlink" title="小程序有哪些基础知识？"></a>小程序有哪些基础知识？</h2><p>一个完整的微信小程序是由一个App实例和多个Page实例构成，其中App实例表示该小程序应用，多个Page表示该小程序的多个页面。<br>此外，微信小程序并没有提供自定义组件的方式，这就导致微信小程序在开发较复杂应用时，可能会比较艰难。</p>
<p>微信小程序本身很简单，和一个模板语言的难度几乎相当，翻翻官方教程就可以开始动手搞。</p>
<p>我也建议大家先动起来，然后再细致啃啃官方文档。由于微信官方文档仍在不断大幅更新中，所以务必查看最新官方文档。</p>
<p>微信小程序的基础知识主要分为以下几个部分：</p>
<ul>
<li>两种配置文件 &amp;&amp; 两个核心函数</li>
<li>WXML模板语法，页面渲染</li>
<li>页面间的跳转</li>
<li>交互事件</li>
<li>官方组件和官方API</li>
</ul>
<h3 id="两种配置文件-amp-amp-两个核心函数"><a href="#两种配置文件-amp-amp-两个核心函数" class="headerlink" title="两种配置文件 &amp;&amp; 两个核心函数"></a>两种配置文件 &amp;&amp; 两个核心函数</h3><p><code>app.json</code><strong>应用的全局配置文件</strong></p>
<p><code>app.json</code>是针对微信小程序的全局配置，主要包含以下几个配置：</p>
<ul>
<li>pages：页面路径的数组，表示小程序要加载的所有页面，其中数组第一项代表小程序的初始页面。</li>
<li>window：微信原生功能，定制化不强。可设置小程序的状态栏、导航条、标题以及窗口背景色。</li>
<li>tabBar：微信原生功能，定制化不强。适用于常规的Tab应用，Tab栏可置于顶部或底部；tabBar是一个数组，仅支持2-5个tab。</li>
<li>networkTimeout：配置小程序网络请求的超时时间。</li>
<li>debug：调试模式开关，开发模式下建议开启，正式发布别忘了关闭。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1158202-719f23c56cd215ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>page.json</code> <strong>页面的全局配置文件</strong></p>
<p>除了上面提到的全局配置，每个页面还可以单独配置page.json，page.json会覆盖app.json中的配置，并只对当前页面生效。</p>
<p>page.json只能对window配置，有两个比较有用的配置项分别是：</p>
<ul>
<li>enablePullDownRefresh：是否开启下拉刷新</li>
<li>disableScroll：只能在page.json配置，禁止页面上下滚动，猜测可以实现完美滑屏滑动（未验证）</li>
</ul>
<p><code>App()</code> <strong>小程序注册入口，全局唯一</strong></p>
<p>App()用来注册一个小程序，全局只有一个，全局的数据也可以放到这里面来操作。</p>
<pre><code>// 注册微信小程序，全局只有一个
let appConfig = {
    // 小程序生命周期的各个阶段
    onLaunch: function(){},
    onShow: function(){},
    onHide: function(){},
    onError: function(){},

    // 自定义函数或者属性
    ...
};
App(appConfig);

// 在别的地方可以获取这个全局唯一的小程序实例
const app = getApp();
</code></pre><p>小程序并没有提供销毁的方式，所以只有当小程序进入后台一定时间、或者系统资源占用过高的时候，才会被真正的销毁。</p>
<p><code>Page()</code> <strong>页面注册入口</strong></p>
<p>Page()用来注册一个页面，维护该页面的生命周期以及数据。</p>
<pre><code>// 注册微信小程序，全局只有一个
let pageConfig = {
    data: {},
    // 页面生命周期的各个阶段
    onLoad: function(){},
    onShow: function(){},
    onReady: function(){},
    onHide: function(){},
    onUnload: function(){},
    onPullDownRefresh: function(){},
    onReachBottom: function(){},
    onShareAppMessage: function(){},

    // 自定义函数或者属性
    ...
};
Page(pageConfig);

// 获取页面堆栈，表示历史访问过的页面，最后一个元素为当前页面
const page = getCurrentPages();
</code></pre><p>关于各个生命周期的细节以及流程，参考下图，可以细细品味：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-481a42f6d299528e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>app.json</code> 和 <code>page.json</code> 维护了应用和页面的配置属性。<code>App()</code> 和 <code>Page()</code> 维护了应用和页面的各个生命周期以及数据。</p>
<p>那么，<code>APP</code> 和 <code>Page</code> 如何将数据传递到页面呢？页面又是如何渲染呢？</p>
<h3 id="WXML模板语法，页面渲染"><a href="#WXML模板语法，页面渲染" class="headerlink" title="WXML模板语法，页面渲染"></a>WXML模板语法，页面渲染</h3><p>小程序虽然是hybrid模式，但并不使用HTML渲染，而是全部通过自定义标签来渲染页面。这样做的好处我不清楚，但问题却不少：不能跨浏览器、富文本解析困难，iframe视频不支持，没办法外链跳转。<br>和所有的模板语言一样，WXML支持数据绑定、条件渲染、循环、模块化等功能。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>在 WXML 中可以使用<code>双大括号</code>将 <code>Page</code> 的变量或者表达式包裹起来，实现数据绑定，举个例子：</p>
<pre><code>// 将message的值渲染到view中
&lt;view&gt; {{ message }} &lt;/view&gt;

// 将id的值渲染到view的id属性中
&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;

// 根据isSelected的值，输出不同的class
&lt;view class=&quot;{{isSelected ? 'selected' : ''}}&quot;&gt; HelloWorld &lt;/view&gt;

// 结合template，可以传入更复杂的数据
&lt;template is=&quot;objectCombine&quot; data=&quot;{{...article, categoty, tag: '埃隆马斯克'}}&quot;&gt;&lt;/template&gt;
</code></pre><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>循环渲染，适合遍历数据输出多段 WXML，举个例子：</p>
<pre><code>// wx:for 表示需要遍历的数据
// wx:key 使用唯一的字段来标识，有利于提升性能
// wx:for-index 表示数组的下标
// wx:for-item 表示数组的元素
&lt;view wx:for=&quot;{{[{id:1, message: 'HelloWorld1'}, {id:2, message: 	'HelloWorld2'}]}}&quot; 
    wx:key=&quot;id&quot; 
    wx:for-index=&quot;idx&quot; 
    wx:for-item=&quot;item&quot;&gt;
    {{idx}}: {{item.message}}
&lt;/view&gt;
</code></pre><p><code>wx:key</code> 有利于提升重新渲染时的效率，建议添加</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>WXML的模块化，可以让我们复用一些wxml片段，还挺重要的，举个例子：</p>
<pre><code>// 引入wxml模块
&lt;import src=&quot;../../components/grid-article/index&quot;&gt;&lt;/import&gt;

&lt;block wx:for=&quot;{{posts}}&quot; wx:for-item=&quot;post&quot; wx:key=&quot;id&quot;&gt;
    // 调用wxml模块，同时可传入数据
    &lt;template is=&quot;grid-article&quot; data=&quot;{{post}}&quot;&gt;&lt;/template&gt;
&lt;/block&gt;
</code></pre><p>数据和页面的状态是一一对应的，微信小程序中，设计一份好的数据结构，对于Page和页面的代码都有很大的帮助。<br>微信小程序并不支持a标签，那么多个页面之间如何跳转呢？</p>
<h3 id="页面间的跳转"><a href="#页面间的跳转" class="headerlink" title="页面间的跳转"></a>页面间的跳转</h3><p>小程序以栈的形式维护了历史访问的所有页面，并提供了多种页面间的跳转方式；结合前文提到的App()和Page()的各个生命周期，不同的跳转方式和不同的生命周期关联，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-cf7de8f472d6a147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>举个例子，Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）<br><img src="http://upload-images.jianshu.io/upload_images/1158202-80ab7b1ea2766468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>好了，APP和Page负责维护小程序的生命周期和数据，模板负责接受数据完成页面渲染，页面间的跳转负责将多个页面贯穿起来，那么，如何发生交互呢？接下来我们简单说一下事件。</p>
<h3 id="交互事件"><a href="#交互事件" class="headerlink" title="交互事件"></a>交互事件</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><pre><code>// bindtap 和 catchtap的区别在于
// bindtap 不会阻止事件冒泡
// catchtap会冒泡事件冒泡
&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;
&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; catchtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;

// 绑定的函数tapName只是一个函数名称，默认接受一个event对象作为参数
Page({
    tapName: function(event) {
        console.log(event)
        }
    })
</code></pre><p>接下来，另一个问题是：<code>tapName()</code> 如何接受自定义参数呢？</p>
<h4 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h4><p>传递自定义参数主要有两种方式：</p>
<p>第一种：将参数绑定到wxml标签上，然后通过event.target.dataset获取</p>
<p>第二种：直接使用Page.data或其他数据</p>
<p>到目前为止，一个完整的小程序框架已经实现</p>
<ul>
<li>小程序只有逻辑和视图两部分，而且不提供组件化解决方案</li>
<li>逻辑主要包含四个东西：两个配置文件 &amp;&amp; 两个核心函数</li>
<li>视图很简单，模板语法稍微有点不完善</li>
<li>逻辑层的数据绑定到视图层是由小程序框架自动支持，数据变化，视图自动变化</li>
<li>视图层到逻辑层的，主要通过事件的方式来实现</li>
<li>视图之间的跳转，小程序也提供了它自己的方式，并不支持a标签</li>
</ul>
<p>框架有了，小程序还提供了官方组件以便快速开发，提供了API以增强应用能力。</p>
<p>这块就不具体介绍了，也需要注意小程序的官方文档还在大规模的更新中，务必查看最新版</p>
<p>官方组件：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161222" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161222</a></p>
<p>官方API：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222</a></p>
<p>微信小程序的基础知识就是以上的内容，并不复杂，边查边写都可以。</p>
<p>接下来会介绍更进阶一些的内容，内容主要结合好奇心日报这个小程序项目，先看效果：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-50ade533c922cb0d.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h2 id="如何设计微信小程序？"><a href="#如何设计微信小程序？" class="headerlink" title="如何设计微信小程序？"></a>如何设计微信小程序？</h2><h3 id="构建系统-amp-amp-目录结构"><a href="#构建系统-amp-amp-目录结构" class="headerlink" title="构建系统 &amp;&amp; 目录结构"></a>构建系统 &amp;&amp; 目录结构</h3><h4 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h4><p>由于微信小程序本身对工程化几乎没有任何的支持，所以动手搭建一份：<a href="https://github.com/qixiuss/wxapp-redux-starter" target="_blank" rel="external">wxapp-redux-starter</a>。</p>
<p><strong>使用gulp进行编译构建，主要功能包括：</strong></p>
<ul>
<li>集成了<code>Redux</code>，数据管理更方便</li>
<li>开发过程中，使用<code>xml</code>取代<code>wxml</code>，对开发工具更友好</li>
<li>开发过程中，使用<code>less</code>取代<code>wxss</code>，功能更强大</li>
<li>引入<code>es-promise</code>，以便可以创建并使用<code>Promise</code></li>
<li>添加<code>promisify</code>工具函数，可以便捷的将官方<code>Api</code>转换成<code>Pormise</code>模式</li>
<li>引入<code>normalizr</code>，可以将数据扁平化，更方便进行数据管理</li>
<li>引入<code>babel</code>自动进行<code>ES2015</code>特性转换</li>
<li>对<code>wxml/wxss/js/img</code>压缩，相对开发者工具提供的压缩，会减小一丢丢体积。<h4 id="目录结构设计"><a href="#目录结构设计" class="headerlink" title="目录结构设计"></a>目录结构设计</h4>按照pages、components、redux、vendors/libs、images几个核心部分拆分，直接上目录。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-6583ba0c0928481c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>dist目录：构建输出的文件存放到这个目录。</li>
<li>src目录：开发模式的文件，包括app、页面、组件、图片等静态资源、辅助函数库、Redux数据管理器、第三方工具库。</li>
<li>gulpfile.js：不用多说，gulp构建任务的入口文件。</li>
<li>package.json：不用多说，管理者构建任务的依赖。</li>
<li>thirdPlugins：由于小程序并不支持直接使用npm，我们可以自主拉取构建，然后拷贝到vendors里，有时候需要简单修改。</li>
</ul>
<p>构建系统会将src目录下的代码，编译处理后输出到dist目录，小程序开发工具只需要引入dist目录即可。</p>
<p>有了构建工具，代码开发起来更舒心，但很快就遇到另外一个糟心的问题，那就是如何管理散布在各处的数据？<br>要知道，微信小程序并没有提供组件化方案，所以<strong>把组件写成无状态组件</strong>特别适合，但是页面管理太多数据很凌乱，有什么办法可以将数据集中管理呢？</p>
<h3 id="引入Redux进行数据集中管理"><a href="#引入Redux进行数据集中管理" class="headerlink" title="引入Redux进行数据集中管理"></a>引入Redux进行数据集中管理</h3><p>关于Redux相关的内容，之前有三篇博客详细介绍，有兴趣的建议先移步：</p>
<ul>
<li>Redux整体介绍：<a href="http://www.jianshu.com/p/d296a8c34936" target="_blank" rel="external">Redux 入门教程，应用的状态管理器</a></li>
<li>对State进行横向和纵向拆分设计：<a href="http://www.jianshu.com/p/ba8654cb77b6" target="_blank" rel="external">State设计，Redux 开发第一步</a></li>
<li>Reducer的最佳实践：<a href="http://www.jianshu.com/p/938f8121ba0f" target="_blank" rel="external">Reducer 最佳实践，Redux 开发最重要的部分</a></li>
</ul>
<p>这儿就简单介绍一下，如何在微信小程序中引入Redux 以及 如何将微信小程序和Redux连接起来。</p>
<h4 id="引入Redux"><a href="#引入Redux" class="headerlink" title="引入Redux"></a>引入Redux</h4><p>直接在 <code>thirdPlugins</code>目录 运行 <code>yarn add redux / npm install redux</code>，等<code>redux</code>安装好了之后，将 <code>dist</code>目录 的 <code>redux.js/redux.min.js</code> 拷贝到<code>vendors</code>目录中。<br>需要进行简单的修改才能使用，将压缩版208行代码 <code>(i)</code> 改成 <code>(i || {})</code>即可。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-143fad06f8c52bca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="连接微信小程序和Redux"><a href="#连接微信小程序和Redux" class="headerlink" title="连接微信小程序和Redux"></a>连接微信小程序和Redux</h4><p>将Redux和微信小程序连接起来才会真的有用处。找了个现成的方案<a href="https://github.com/charleyw/wechat-weapp-redux" target="_blank" rel="external">charleyw/wechat-weapp-redux</a>，可以直接使用。</p>
<p>一个完整的Redux方案如下，包括：将Store注入到App中、将state的数据和reducer的方法映射到Page中。一旦state发生变化，Page.data也会更新，进而触发页面的重新渲染。</p>
<pre><code>// APP的逻辑
import { createStore, applyMiddleware, combineReducers } from &apos;./vendors/redux.js&apos;;
import thunk from &apos;./vendors/redux-thunk.js&apos;;
import { Provider } from &apos;./vendors/weapp-redux.js&apos;;

// import reducers
import { rootReducer } from &apos;./redux/reducer.js&apos;;

// 从Storage读取数据
let entities = wx.getStorageSync(&apos;entities&apos;) || {};

const store = createStore(
    rootReducer, {
        // 将读取的数据注入到store中
        entities: entities
    },
    applyMiddleware(
        thunk
    )
);

let appConfig = {
    onLaunch: function() {},

    onHide: function() {
        let state = store.getState(),
            cacheEntities = {};

        // 体积大于2M，直接清空，防止缓存占用过大体积
        if (sizeof(state.entities) &lt;= 2 * 1024 * 1024) {
            cacheEntities = state.entities;
        }

        // 退出时将entities缓存下来
        wx.setStorageSync(&apos;entities&apos;, cacheEntities);
    }
};

App(Provider(store)(appConfig));
// Page的逻辑
import { connect } from &apos;../../vendors/weapp-redux.js&apos;;

import { fetchArticleDetail } from &apos;../../redux/models/articles.js&apos;;

let pageConfig = {
    data: {
        id: 0,
        postsHash: {}
    },
    onLoad: function(params) {
        var me = this,
            { id, postsHash } = me.data;

        me.fetchArticleDetail(id, function() {}, function() {});
    }
}

// 考虑到列表页已经获取到部分数据
// 为了在详情页第一时间利用这些数据，我们将params传入
// 防止以后需要用data的数据，我们将data也一并传入
let mapStateToData = (state, params, data) =&gt; {
    return {
        id: params.id,
        postsHash: state.entities.posts
    }
};

let mapDispatchToPage = dispatch =&gt; ({
    fetchArticleDetail: (id, callback, errorCallback) =&gt; dispatch(fetchArticleDetail(id, callback, errorCallback)),
});

pageConfig = connect(mapStateToData, mapDispatchToPage)(pageConfig)
Page(pageConfig);
</code></pre><p>需要注意的是，为了保证第一时间能拿到数据，我们对<code>wechat-weapp-redux/src/connect.js</code>做了优化调整，修改的地方如下</p>
<pre><code>// 修改了以下两个函数
// 可以对照原项目修改，也可以直接拿我的模板项目使用
function handleChange(options) {
    if (!this.unsubscribe) {
        return
    }

    const state = this.store.getState();
    // 将data也一并传入
    const mappedState = mapState(state, options, this.data);
    if (!this.data || shallowEqual(this.data, mappedState)) {
        return;
    }
    this.setData(mappedState)
}

function onLoad(options) {
    this.store = app.store;
    if (!this.store) {
        warning(&quot;Store对象不存在!&quot;)
    }
    if (shouldSubscribe) {
        this.unsubscribe = this.store.subscribe(handleChange.bind(this, options))
        // 第一次处理的时候也传入options
        handleChange.apply(this, [options])
    }
    if (typeof _onLoad === &apos;function&apos;) {
        _onLoad.call(this, options)
    }
}
</code></pre><h4 id="引入Redux的优势"><a href="#引入Redux的优势" class="headerlink" title="引入Redux的优势"></a>引入Redux的优势</h4><p>引入Redux的好处在于可以集中管理数据，并且让Page的代码保持绝对简单，让所有的组件都变成简单可复用的无状态组件。<br>此外，Redux还让离线缓存更方便，数据复用更简单。</p>
<p>引入Redux解决了数据散布各处的问题，参考Redux的管理思路，我们构思了一套简单组件化解决方案：假设我们把所有的组件都设计成无状态组件，而组件的数据来源是Page.data，那么我们是否也可以将组件数据的管理抽离到一个单独的文件中呢？接下来讲讲我们使用的简单的组件化解决方案。</p>
<h4 id="简单的组件化解决方案"><a href="#简单的组件化解决方案" class="headerlink" title="简单的组件化解决方案"></a>简单的组件化解决方案</h4><p>这份组件化解决方案的核心就在于把组件的关联数据集中起来管理，只暴露出默认数据和数据的操作函数。</p>
<p>比如好奇心日报的详情页有个Toolbar，该Toolbar并不复杂，主要提供返回和点赞功能，其中点赞功能只对文章详情有效，研究所详情页会将点赞功能隐藏。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-2d1dc48a1ecaf25b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>// components/toolbar/index.js 文件
// 仅提供默认值，不需要和page中的数据保持同步
let defaultData = {
    isPraised: false,
    praiseCount: 0,
    showPraiseIcon: false,
};
// 切换点赞状态
function togglePraise() {
    // 本质上是修改Page.data中的toolbarData
}
// 返回上一级
function navigateToBack(wx) {
    wx.navigateBack({ delta: 1 });
}
module.exports = {
    defaultData,

    togglePraise,
    navigateToBack
}

// pages/articles/show.js 文件
import Toolbar from &apos;../../components/toolbar/index.js&apos;;

let pageConfig = {
    data: {
        // 其他数据
        id: 0,
        // Toolbar数据，单独的一份数据，便于维护
        toolbarData: Toolbar.defaultData
    },
    // 点赞或者取消赞
    togglePraise: function() {
        let me = this;

        Toolbar.togglePraise.call(me);
    }
}

// 这儿的组件化并不是真正的组件化
// 而是将组件相关的逻辑和函数抽离到单独的文件中，保证Page代码清晰。
// 同时也为这部分组件逻辑复用提供了可能。
// 本质上来说，抽离出的组件都是“操作Page.data的工具函数”，他们也是纯函数，和“操作state的reducer”类似。
</code></pre><p>这种Redux的组件化解决方案既简单又好用，保持一定的代码规范即可。这样设计当然是为了复用，同时也让Page的逻辑保持极度精简。</p>
<h2 id="开发中遇到了哪些难点-amp-amp-微信小程序有多少坑？"><a href="#开发中遇到了哪些难点-amp-amp-微信小程序有多少坑？" class="headerlink" title="开发中遇到了哪些难点 &amp;&amp; 微信小程序有多少坑？"></a>开发中遇到了哪些难点 &amp;&amp; 微信小程序有多少坑？</h2><p>微信小程序目前的确算不上公测的版本，开发者工具不完善、真机表现和开发环境差异很大、部分组件性能较差、部分功能有缺陷，只有经历了这些大坑，才会真的知道你有多“爱”微信小程序。这儿总结了开发中的难点以及微信小程序中遇到的比较明显的坑。</p>
<h3 id="富文本解析"><a href="#富文本解析" class="headerlink" title="富文本解析"></a>富文本解析</h3><p>微信小程序并不支持HTML标签，所以对于富文本解析来说，难度较大，而且有些功能还没有办法实现，比如：iframe视频、连接跳转等<br>这块功能建议由后台统一转换，如果非得前端转换，建议参考下面的思路。</p>
<p>非常感谢 <a href="https://github.com/icindy/wxParse" target="_blank" rel="external">wxParse</a> 这款组件，替我省了不少时间。推荐大家使用，期间遇到一些问题，也分享给大家。</p>
<ul>
<li>wxParse 默认层级只支持10层html嵌套，如果想要支持更深的层级，在wxParse.xml复制几份template即可。</li>
<li>wxParse 提供了图片加载成功的回调<code>wxParseImgLoad</code>，很好用。但如果富文本中的图片已经预设宽高比，那么可以不用依赖该回调，在html2jons.js中根据屏幕宽度直接计算出图片高度，先占位，可以避免页面频繁抖动的问题。</li>
<li>如果你的富文本中有自定义模块，对wxParse.xml中的template进行改造即可。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-52ce324bcc9879bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="数据扁平化"><a href="#数据扁平化" class="headerlink" title="数据扁平化"></a>数据扁平化</h3>具体如何扁平化，请移步上一篇博客 <a href="http://www.jianshu.com/p/ba8654cb77b6" target="_blank" rel="external">State设计，Redux 开发第一步</a>。<br>这儿只简单介绍下扁平化应用场景：<br>好奇心日报的研究所是三级表结构：<code>papers &gt; questions &gt; options</code>，后台返回的数据是三级嵌套数据，如果想要修改option.selected字段，需要三级嵌套循环！如果想要获取所有选中的option，需要三级嵌套循环！<h3 id="页面展现速度优化"><a href="#页面展现速度优化" class="headerlink" title="页面展现速度优化"></a>页面展现速度优化</h3>数据复用，比如复用列表页的数据，可以让详情页的标题等字段第一时间呈现出来。<br>离线缓存，同样可以让列表页和详情页第一时间呈现出来，甚至有可能减少请求数量。</li>
</ul>
<p>无论是数据复用还是离线缓存，配合数据扁平化，都非常好用。</p>
<h3 id="小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）"><a href="#小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）" class="headerlink" title="小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）"></a>小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）</h3><p>解决方法很简单，设置微信小程序不使用代理；或者临时关闭VPN即可。<br>最新版开发者工具已经解决该问题。</p>
<h3 id="最新版微信小程序移除了对Promise的支持。"><a href="#最新版微信小程序移除了对Promise的支持。" class="headerlink" title="最新版微信小程序移除了对Promise的支持。"></a>最新版微信小程序移除了对Promise的支持。</h3><p>开发者自行引入兼容库即可，推荐<a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="external">es6-promise</a>。使用的时候，直接引入Promise即可。</p>
<pre><code>// 引入Promise
import Promise from &apos;../vendors/es6-promise.js&apos;;

// 用Promise封装wx.request网络请求
function request(method = &apos;GET&apos;) {
    return function(url, data = {}) {
        return new Promise(function(resolve, reject) {
            wx.request({
                url,
                data,
                method,
                header: {
                    &apos;Content-Type&apos;: &apos;application/json&apos;
                },
                success: function(res) {
                    let { statusCode, errMsg, data } = res;

                    if (statusCode == 200 &amp;&amp; data.meta &amp;&amp; data.meta.status == 200) {
                        resolve(data.response);
                    } else {
                        reject(&apos;网路请求错误，请稍后再试~&apos;);
                    }
                },
                fail: function(err) {
                    reject(&apos;网路请求不符合规范，请检查域名是否符合要求~&apos;);
                }
            });
        })
    }
}
export const GET = request(&apos;GET&apos;);
export const POST = request(&apos;POST&apos;);
export const PUT = request(&apos;PUT&apos;);
export const DELETE = request(&apos;DELETE&apos;);

// 用Promise封装小程序的其他API
export const promisify = (api) =&gt; {
    return (options, ...params) =&gt; {
        return new Promise((resolve, reject) =&gt; {
            api(Object.assign({}, options, { success: resolve, fail: reject }), ...params);
        });
    }
}
// 使用
const getLocation = promisify(wx.getLocation);
</code></pre><p>不清楚微信为何会临时移除Promise，统一内置不也挺好？</p>
<h3 id="小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。"><a href="#小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。" class="headerlink" title="小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。"></a>小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。</h3><p>小程序一旦滚动顶部或者底部，继续滑动的时候，就会出现拉扯现象。而这个拉扯现象还无法禁止。<br>最新版可以对页面配置disableScroll，预计可以修复这个问题，待实际验证。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-691d39e8e75dc7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）"><a href="#swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）" class="headerlink" title="swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）"></a>swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）</h4><ul>
<li>swiper组件之前并不支持轮播，最新版已修复</li>
<li>swiper组件之前是通过设置left属性来实现动画，在小米5、华为V8等高端等安卓机上能够感受到明显的卡顿，当然原因是X5内核引起的。最新版已修复，换成了transform，性能有一定的提升。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-942330479da5c884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><p>文档并未标记可以垂直轮播，但其实是可以的。</p>
<pre><code>// 简单设置vertical即可，但由于官方文档并未备注，尽量不要使用。可以自己开发一个swiper组件。
&lt;swiper vertical=&quot;true&quot;&gt;&lt;/swiper&gt;
</code></pre></li>
<li>swiper组件的小圆点其实是可以定制化的，但是官方文档并未说明，而且开发者工具也看不出来，只有鼠标hover到元素上的时候可以看到相关的class，简单猜测一下，最后分析出来它的实现方式。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1158202-70f78f4950ce9817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>// 圆点的父元素，用来控制圆点间的间距
.wx-swiper-dot {
    width: 30rpx;
    // 圆点，可以通过font-size修改圆点的大小，color修改圆点的颜色
    &amp;:before {
        width: 100%;
        display: inline-block;
        font-size: 56rpx;
        content: &apos;圆点编码&apos;;
    }
    // active状态的圆点
    &amp;.wx-swiper-dot-active {
        &amp;:before {
            color: #ffc81f;
        }
    }
}
</code></pre><h3 id="小程序WXSS的font-face的url不接受路径作为参数"><a href="#小程序WXSS的font-face的url不接受路径作为参数" class="headerlink" title="小程序WXSS的font-face的url不接受路径作为参数"></a>小程序WXSS的font-face的url不接受路径作为参数</h3><p>可以将字体文件转换为base64，然后引用。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-4d8cf6721984b58c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>同样，如果想要使用iconfont，也可以使用类似的方案，将iconfont字体文件base64之后再引入。</p>
<h4 id="小程序的margin表现有问题（最新版已经修复）"><a href="#小程序的margin表现有问题（最新版已经修复）" class="headerlink" title="小程序的margin表现有问题（最新版已经修复）"></a>小程序的margin表现有问题（最新版已经修复）</h4><p>之前发生margin折叠的时候，会取小的那个值。会导致底部留白等设置失效。</p>
<h4 id="canvas问题"><a href="#canvas问题" class="headerlink" title="canvas问题"></a>canvas问题</h4><p>canvas并没有深入研究，目前的发现的问题主要是两个，如下图标记：</p>
<ul>
<li>层级问题，canvas总是会盖在其他元素上面。</li>
<li>支持度不好，在小米5、iPhone5s画图会出现畸形。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-aaea239242906e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>最后通过CSS3的方式绘制饼图</p>
<pre><code>&lt;template name=&quot;pie&quot;&gt;
    &lt;view class=&quot;com-pie&quot;&gt;
        &lt;!-- 小于50% --&gt;
        &lt;view class=&quot;percent-1&quot; style=&quot;transform: rotate(0.4turn);&quot;&gt;&lt;/view&gt;
        &lt;view class=&quot;percent-2&quot;&gt;&lt;/view&gt;
        &lt;!-- 大于50% --&gt;
        &lt;view class=&quot;percent-1&quot; style=&quot;transform: rotate(0.5turn);&quot;&gt;&lt;/view&gt;
        &lt;view class=&quot;percent-2&quot; style=&quot;opacity:1; transform: rotate(0.3turn);&quot;&gt;&lt;/view&gt;
    &lt;/view&gt;
&lt;/template&gt;

.com-pie {
    position: relative;
    z-index: 0;
    display: inline-block;
    width: 100rpx;
    height: 100rpx;
    line-height: 100rpx;
    border-radius: 50%;
    color: #000;
    background-color: #ebebeb;
    background-image: linear-gradient(to right, transparent 50%, #cccccc 0);
    overflow: hidden;
    .percent-1,
    .percent-2 {
        position: absolute;
        top: 0;
        width: 60%;
        height: 100%;
        left: 50%;
        transform-origin: center left;
    }
    .percent-1 {
        background-color: inherit;
        z-index: -2;
    }
    .percent-2 {
        height: 110%;
        opacity: 0;
        z-index: -1;
        background-color: #cccccc;
    }
    &amp;.selected {
        background-color: #ffe9a5;
        background-image: linear-gradient(to right, transparent 50%, #ffc81f 0);
        .percent-2 {
            background-color: #ffc81f;
        }
    }
}
</code></pre><h3 id="微信小程序的rpx会出现精度问题"><a href="#微信小程序的rpx会出现精度问题" class="headerlink" title="微信小程序的rpx会出现精度问题"></a>微信小程序的rpx会出现精度问题</h3><p>设置margin-left/margin-right负值，可能导致页面能够左右晃动。猜测 是rpx导致的精度问题。<br>rpx本质上会转换为px，在不同宽度的设备上，实际的rpx值会转换为带小数的px值，四舍五入可能出现问题，之前使用rem布局的时候在QQ浏览器遇到过类似的问题。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-83e69b31a569928f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="wx-request表现不合理，并且携带特殊字符会报错"><a href="#wx-request表现不合理，并且携带特殊字符会报错" class="headerlink" title="wx.request表现不合理，并且携带特殊字符会报错"></a>wx.request表现不合理，并且携带特殊字符会报错</h4><ul>
<li>请求返回404错误，也会触发success回调。<br>不要想当然的认为会触发fail回调，判断一个请求成功或失败，请使用wx.request返回的状态来判断。只有不符合规范的请求，才会触发fail。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-ebad0e91ac279124.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></li>
<li>请求的数据中，如果有特殊字符（比如\u2820），会报错。<br>只会在真机上出现，开发者工具没毛病。估计会有更多的特殊字符会导致这个问题。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-9110f7d78b3fb4aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="开发者工具，切换页面的时候，有时候wxml不会同步切换"><a href="#开发者工具，切换页面的时候，有时候wxml不会同步切换" class="headerlink" title="开发者工具，切换页面的时候，有时候wxml不会同步切换"></a>开发者工具，切换页面的时候，有时候wxml不会同步切换</h3>希望微信什么时候能解决一下。<h3 id="微信小程序给wxml模板赋值的时候，解构放到前面可能会报错"><a href="#微信小程序给wxml模板赋值的时候，解构放到前面可能会报错" class="headerlink" title="微信小程序给wxml模板赋值的时候，解构放到前面可能会报错"></a>微信小程序给wxml模板赋值的时候，解构放到前面可能会报错</h3>最新版会遇到这个问题，老版本虽然不会报错，但是在部分真机上会出现问题。<br>原因未知，遇到这个问题的朋友可以考虑绕过去。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-e379fd7fca1b99cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="微信小程序的scroll-view暴露的bindscroll函数并不能实时监听"><a href="#微信小程序的scroll-view暴露的bindscroll函数并不能实时监听" class="headerlink" title="微信小程序的scroll-view暴露的bindscroll函数并不能实时监听"></a>微信小程序的scroll-view暴露的bindscroll函数并不能实时监听</h3>依赖实时获取滚动位置的功能不能实现。比如滚动时toolbar的动态隐藏和显示。<h3 id="最新版开发工具不能关掉自动刷新"><a href="#最新版开发工具不能关掉自动刷新" class="headerlink" title="最新版开发工具不能关掉自动刷新"></a>最新版开发工具不能关掉自动刷新</h3>微信小程序的会默认监听文件变化，然后自动刷新。<br>但不足的是每次都是全量刷新，而不是模块的热替换，反而会影响开发速度，尤其对于喜欢频繁Command + S的开发者，你会发现你的小程序在不断的刷新。建议关闭。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-1418bc0e4b307f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但最新版开发者工具，不勾选也会自动刷新。</li>
</ul>
<h3 id="微信小程序不支持requestAnimationFrame"><a href="#微信小程序不支持requestAnimationFrame" class="headerlink" title="微信小程序不支持requestAnimationFrame"></a>微信小程序不支持<code>requestAnimationFrame</code></h3><p>微信小程序不支持<code>requestAnimationFrame</code>，所以部分性能优化做不了。不支持的原因未知。</p>
<h3 id="Page-onload函数可以接受参数"><a href="#Page-onload函数可以接受参数" class="headerlink" title="Page.onload函数可以接受参数"></a>Page.onload函数可以接受参数</h3><p>该参数是有URL决定的，也就是URL携带的参数。<br>官方文档这块写的有点混淆，特意拿出来说一下。举个例子：url中传递的时候<code>id=1</code>，那么<code>option.id=1</code>，而不是什么<code>option.query</code>。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-8135e6e4e97b2ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="真机上有概率卡死，目前不确定是代码问题还是小程序的问题。"><a href="#真机上有概率卡死，目前不确定是代码问题还是小程序的问题。" class="headerlink" title="真机上有概率卡死，目前不确定是代码问题还是小程序的问题。"></a>真机上有概率卡死，目前不确定是代码问题还是小程序的问题。</h3><p>有遇到类似问题的朋友欢迎指出。</p>
<h4 id="总结说点啥？"><a href="#总结说点啥？" class="headerlink" title="总结说点啥？"></a>总结说点啥？</h4><p>本文主要围绕微信小程序的基础知识、如何设计微信小程序、开发过程中遇到的问题三个方面介绍。<br>微信小程序的基础知识主要包括：</p>
<ul>
<li>两种配置文件 &amp;&amp; 两个核心函数</li>
<li>WXML模板语法，页面渲染</li>
<li>页面间的跳转</li>
<li>交互事件</li>
<li>官方组件和官方API</li>
</ul>
<p>如何设计微信小程序的内容主要包括：</p>
<ul>
<li>构建系统 &amp;&amp; 目录结构</li>
<li>引入Redux进行数据集中管理</li>
<li>简单的组件化解决方案</li>
</ul>
<p>最后还介绍开发过程中遇到的难点 以及 微信小程序的大小坑。</p>
<p>微信小程序本身并不复杂，开发过程却比较艰辛，尤其是第一次在真机上运行的时候，觉得这个世界恶意满满。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/03/微信小程序实战，从入门到弃坑（转）/" class="archive-article-date">
  	<time datetime="2017-01-03T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信小程序/">微信小程序</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-mobiscroll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/02/mobiscroll/">mobiscroll</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>mobiscroll一款使用简单而强大的JQ插件，依赖文件可以在我的<a href="https://github.com/Jasonellen/relyOn/tree/master/timepicker" target="_blank" rel="external">github</a>中找到，这种timepicker在手机端还是非常常见的，实用！</p>
</blockquote>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code>引入依赖文件
&lt;link rel=&quot;stylesheet&quot; href=&quot;mobiscroll.custom-2.17.0.min.css&quot;&gt;
&lt;script src=&apos;jquery.min.js&apos;&gt;&lt;/script&gt;
&lt;script src=&apos;mobiscroll.custom-2.17.0.min.js&apos;&gt;&lt;/script&gt;
</code></pre><p><br>    </p>
<pre><code>目标对象
&lt;input id=&quot;demo&quot; placeholder=&quot;Please Select...&quot; /&gt;
&lt;button id=&quot;show&quot;&gt;show&lt;/button&gt;
&lt;button id=&quot;clear&quot;&gt;clear&lt;/button&gt;
</code></pre><p><br></p>
<pre><code>初始化，及调用mobiscroll方法
$(function () {
    var now = new Date(),
        minDate = new Date(now.getFullYear() - 10, now.getMonth(), now.getDate()),
        maxDate = new Date(now.getFullYear() + 10, now.getMonth(), now.getDate());

    $(&apos;#demo&apos;).mobiscroll().datetime({
        theme: &apos;mobiscroll&apos;,
        lang: &apos;zh&apos;,
        display: &apos;bottom&apos;,
        min: minDate,
        max: maxDate,
        stepMinute: 1 , //设置分钟间隔

        dateFormat: &apos;yy-mm-dd&apos;, //日期格式
        // timeFormat: &apos;HH:ii&apos;, //事件格式 大写24H 小写12H
           // timeWheels: &apos;HHii&apos;
           //dateOrder: &apos;ddyymm&apos;, //面板中日期排列格式

    });

    $(&apos;#show&apos;).click(function () {  
        $(&apos;#demo&apos;).mobiscroll(&apos;show&apos;);
        return false;  
    }); 

    $(&apos;#clear&apos;).click(function () {  
        $(&apos;#demo&apos;).mobiscroll(&apos;clear&apos;);  
        return false;  
    });
});
</code></pre><blockquote>
<p>样式肯定不止这一种啦，更多使用demo请直接转官网<a href="https://demo.mobiscroll.com/v3/jquery/datetime#demo=rtl" target="_blank" rel="external">demo.mobiscroll.com</a>    </p>
<h2 id="修改基本样式"><a href="#修改基本样式" class="headerlink" title="修改基本样式"></a>修改基本样式</h2><pre><code>如果你愿意，当然后找一找还是能找到很多样式接口：
&lt;style&gt;
    .mbsc-mobiscroll .dwb0{
        color: red;
        /*确定按钮的颜色*/
    }
    .dw-ul{
        color: lightgrey;  
        /*所有字体的颜色*/
    }
    .dw-sel{
        color: brown;
        /*当前选中字体的颜色*/
    }
    ....    
&lt;/style&gt;
</code></pre></blockquote>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>不要下手太重，<a href="http://htmlpreview.github.io/?https://github.com/Jasonellen/relyOn/blob/master/timepicker/timepicker.html" target="_blank" rel="external">轻轻戳我预览</a>😁</p>
<h2 id="不只是timepicker"><a href="#不只是timepicker" class="headerlink" title="不只是timepicker"></a>不只是timepicker</h2><p>看一个完整的例子</p>
<h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width:device-width,initial-scale=1.0&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;content/Content/mobiscroll-2.13.2.full.min.css&quot;&gt;
&lt;script src=&apos;jquery.min.js&apos;&gt;&lt;/script&gt;
&lt;script src=&apos;content/Scripts/mobiscroll-2.13.2.full.min.js&apos;&gt;&lt;/script&gt;
</code></pre><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><pre><code>&lt;style&gt;  
.mbsc-android-holo .dwv { text-align:left;text-indent:.8em; }  
&lt;/style&gt;  
&lt;ul id=&quot;treelist&quot;&gt; 
  &lt;li&gt;  
      &lt;span&gt;奥迪&lt;/span&gt;  
      &lt;ul&gt;  
          &lt;li&gt;奥迪A3&lt;/li&gt;  
          &lt;li&gt;奥迪A4L&lt;/li&gt;  
          &lt;li&gt;奥迪A6L&lt;/li&gt;  
          &lt;li&gt;奥迪Q3&lt;/li&gt;  
          &lt;li&gt;奥迪Q5&lt;/li&gt;  
          &lt;li&gt;奥迪A4&lt;/li&gt;  
          &lt;li&gt;奥迪A6&lt;/li&gt;  
          &lt;li&gt;奥迪A1&lt;/li&gt;  
          &lt;li&gt;奥迪A3(进口)&lt;/li&gt;  
      &lt;/ul&gt;  
  &lt;/li&gt;  
  &lt;li&gt;  
      &lt;span&gt;宝马&lt;/span&gt;  
      &lt;ul&gt;  
          &lt;li&gt;宝马X1&lt;/li&gt;  
          &lt;li&gt;宝马i3&lt;/li&gt;  
          &lt;li&gt;宝马1系&lt;/li&gt;  
          &lt;li&gt;宝马3系&lt;/li&gt;  
          &lt;li&gt;宝马5系&lt;/li&gt;  
      &lt;/ul&gt;  
  &lt;/li&gt;  
  &lt;li&gt;  
      &lt;span&gt;奔驰&lt;/span&gt;  
      &lt;ul&gt;  
          &lt;li&gt;奔驰A级&lt;/li&gt;  
          &lt;li&gt;奔驰C级&lt;/li&gt;  
          &lt;li&gt;奔驰E级&lt;/li&gt;  
          &lt;li&gt;奔驰S级&lt;/li&gt;  
          &lt;li&gt;奔驰GLK级&lt;/li&gt;  
          &lt;li&gt;奔驰CLA级&lt;/li&gt;  
          &lt;li&gt;奔驰CLS级&lt;/li&gt;  
      &lt;/ul&gt;  
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><pre><code>$(function () {
  var i = Math.floor($(&apos;#treelist&gt;li&apos;).length / 2),  
      j = Math.floor($(&apos;#treelist&gt;li&apos;).eq(i).find(&apos;ul li&apos;).length / 2);  
  $(&quot;#treelist&quot;).mobiscroll().treelist({  
      theme: &quot;android-ics light&quot;,  
      lang: &quot;zh&quot;,  
      defaultValue: [i,j],  
      cancelText: &apos;取消&apos;,  
      placeholder: &apos;选择车型&apos;,  
      headerText: function (valueText) { return &quot;选择车型&quot;; },  
      formatResult: function (array) { //返回自定义格式结果  
          return $(&apos;#treelist&gt;li&apos;).eq(array[0]).children(&apos;span&apos;).text() +&apos; --&apos;+ $(&apos;#treelist&gt;li&apos;).eq(array[0]).find(&apos;ul li&apos;).eq(array[1]).text().trim(&apos; &apos;);  
      }  
  }); 
}) 
</code></pre><h3 id="效果预览-1"><a href="#效果预览-1" class="headerlink" title="效果预览"></a>效果预览</h3><p><a href="http://htmlpreview.github.io/?https://github.com/Jasonellen/relyOn/blob/master/timepicker/%E8%87%AA%E5%AE%9A%E4%B9%89picker.html" target="_blank" rel="external">轻轻戳我预览</a>😁，注意这个自定义用的文件上是<code>mobiscroll-2.13.2.full.min</code>文件哦。</p>
<h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code>theme: &apos;android-ics light&apos;, //皮肤样式
display: &apos;modal&apos;, //显示方式
mode:&apos;scroller&apos;,
dateFormat: &apos;yy-mm-dd&apos;, // 日期格式
setText: &apos;确定&apos;, //确认按钮名称
cancelText: &apos;取消&apos;,//取消按钮
dateOrder: &apos;yymmdd&apos;, //面板中日期排列格式
headerText: function (valueText) { array = valueText.split(&apos;-&apos;); return array[0] + &quot;年&quot; + array[1] + &quot;月&quot;+array[2]+&quot;日&quot;; }, //自定义弹出框头部格式
rows:5,//滚动区域内的行数 
</code></pre><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><pre><code>（1）onBeforeClose(valueText, btn, inst)
描述：在list关闭之前执行，如果返回false则不会关闭list。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onBeforeClose: function (valueText, btn, inst) {
    }
});

（2）onBeforeShow(inst)
描述：在list显示之前执行的事件，一样如果返回false则list不会显示。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onBeforeShow: function (inst) {
    }
});

（3）onCancel(valueText, inst)
描述：当取消按钮被点击的时候执行的事件。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onCancel: function (valueText, inst) {
    }
});

（4）onChange(valueText, inst)
描述：当value值改变的时候执行
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onChange: function (valueText, inst) {
    }
});

（5）onClosed(valueText, inst)
描述：当list关闭的时候执行的回调函数
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onClosed: function (valueText, inst) {
    }
});

（6）onDestroy(inst)
描述：当miboscroll实例被destoroy的时候回调
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onDestroy: function (inst) {
    }
});

（7）onHide(inst)
描述：list 关闭的动画执行完毕后回调
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onHide: function (inst) {
    }
});

（8）onInit(inst)
描述：mobiscroll实例初始化完成后执行
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onInit: function (inst) {
    }
});

（9）onMarkupReady(html, inst)
描述：list的html代码已经生成，但是还没有显示到页面中的时候，这个时候可以进行标签的修改。例如添加自定义元素。它会在定位完成前执行。
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onMarkupReady: function (html, inst) {
    }
});

（10）onPosition(html, windowWidth, windowHeight, inst)
描述：list定位完成后调用（包括初始化完成以及大小/方向调整之后）
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onPosition: function (html, windowWidth, windowHeight, inst) {
    }
});

（11）onSelect(valueText, inst)
描述：当value被设置的时候，简单理解就是选择好了原始点击确定之后
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onSelect: function (valueText, inst) {
    }
});
（12）onShow(html, valueText, inst)
描述：当list出现的时候
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onShow: function (html, valueText, inst) {
    }
});

（13）onValueTap(item, inst)
描述：当用户点击list上面的值是调用
demo：
$(&apos;#mobiscroll&apos;).mobiscroll().list({
    onValueTap: function (item, inst) {
    }
});
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/02/mobiscroll/" class="archive-article-date">
  	<time datetime="2017-01-02T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobiscroll/">mobiscroll</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-彻底弄懂事件委托" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/23/彻底弄懂事件委托/">彻底弄懂事件委托</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>事件委托又叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理<code>某一类型</code>的所有事件。何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>
</blockquote>
<h2 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h2><p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个<code>优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收</code>。</p>
<h2 id="Why-we-use❓"><a href="#Why-we-use❓" class="headerlink" title="Why we use❓"></a>Why we use❓</h2><h4 id="先看一段代码"><a href="#先看一段代码" class="headerlink" title="先看一段代码"></a>先看一段代码</h4><pre><code>&lt;ul id=&quot;ul1&quot;&gt;
    &lt;li&gt;111&lt;/li&gt;
    &lt;li&gt;222&lt;/li&gt;
    &lt;li&gt;333&lt;/li&gt;
    &lt;li&gt;444&lt;/li&gt;
&lt;/ul&gt;

window.onload = function(){
    var oUl = document.getElementById(&quot;ul1&quot;);
    var aLi = oUl.getElementsByTagName(&apos;li&apos;);
    for(var i=0;i&lt;aLi.length;i++){
        aLi[i].onclick = function(){
            alert(123);
        }
    }
}
</code></pre><p>看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li</p>
<p><hr><br>当然，这是常规的做法，一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，1000个li,每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p>
<blockquote>
<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
</blockquote>
<h4 id="事件委托触发相同事件"><a href="#事件委托触发相同事件" class="headerlink" title="事件委托触发相同事件"></a>事件委托触发相同事件</h4><pre><code>window.onload = function(){
    var oUl = document.getElementById(&quot;ul1&quot;);
    oUl.onclick = function(){
        alert(123);
    }
}
</code></pre><p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，这里是用ul的点击达到同样的效果<code>那么问题来了，如果单纯的点击ul也会触发li本该触发的事件，更精确点，我们只想要li点击时才触发事件怎么办？继续往下走...</code><br><br></p>
<blockquote>
<p>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称为事件源，也就是说，target就可以表示为当前的事件操作的dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较(强迫症是很难改的…)</p>
</blockquote>
<pre><code>window.onload = function(){
    var oUl = document.getElementById(&quot;ul1&quot;);
    oUl.onclick = function(ev){
        var ev = ev || window.event;
        var target = ev.target || ev.srcElement;
        if(target.nodeName.toLowerCase() == &apos;li&apos;){
            alert(123);
            alert(target.innerHTML);
        }
    }
}
</code></pre><p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p>
<hr>

<h4 id="事件委托触发不同事件"><a href="#事件委托触发不同事件" class="headerlink" title="事件委托触发不同事件"></a>事件委托触发不同事件</h4><p>上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？答案是肯定的，如果有标记的话😁<br>​<br><code>未使用委托：4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，</code></p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt;
    &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt;
&lt;/div&gt;

window.onload = function(){
   var Add = document.getElementById(&quot;add&quot;);
   var Remove = document.getElementById(&quot;remove&quot;);
   var Move = document.getElementById(&quot;move&quot;);
   var Select = document.getElementById(&quot;select&quot;);

   Add.onclick = function(){
       alert(&apos;添加&apos;);
   };
   Remove.onclick = function(){
       alert(&apos;删除&apos;);
   };
   Move.onclick = function(){
       alert(&apos;移动&apos;);
   };
   Select.onclick = function(){
       alert(&apos;选择&apos;);
   }

}
</code></pre><p><code>使用委托：可以只用一次dom操作就能实现所有的效果</code></p>
<pre><code>window.onload = function(){
        var oBox = document.getElementById(&quot;box&quot;);
        oBox.onclick = function (ev) {
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if(target.nodeName.toLocaleLowerCase() == &apos;input&apos;){
                switch(target.id){
                    case &apos;add&apos; :
                        alert(&apos;添加&apos;);
                        break;
                    case &apos;remove&apos; :
                        alert(&apos;删除&apos;);
                        break;
                    case &apos;move&apos; :
                        alert(&apos;移动&apos;);
                        break;
                    case &apos;select&apos; :
                        alert(&apos;选择&apos;);
                        break;
                }
            }
        }

    }
</code></pre><h3 id="关于动态添加新元素"><a href="#关于动态添加新元素" class="headerlink" title="关于动态添加新元素"></a>关于动态添加新元素</h3><p><code>未使用事件委托</code></p>
<pre><code>for(var i=0; i&lt;aLi.length;i++){
    aLi[i].onclick = function(){
        this.style.background = &apos;red&apos;;
    };
}
//添加新节点
oBtn.onclick = function(){
    var oLi = document.createElement(&apos;li&apos;);
    oLi.innerHTML = 111*num;
    oUl.appendChild(oLi);
};
</code></pre><p>这是一般的做法，你会发现，新增的li是没有点击事件的</p>
<p><code>使用事件委托</code></p>
<pre><code>oUl.onclick = function(ev){
  var ev = ev || window.event;
  var target = ev.target || ev.srcElement;
  if(target.nodeName.toLowerCase() == &apos;li&apos;){
      target.style.background = &quot;red&quot;;
  }
};
oBtn.onclick = function(){
  var oLi = document.createElement(&apos;li&apos;);
  oLi.innerHTML = 111*num;
  oUl.appendChild(oLi);
};
</code></pre><p>这里你会发现，新添加的li元素无需做其他操作，已有点击事件</p>
<hr>


<h1 id="事件委托适用场景"><a href="#事件委托适用场景" class="headerlink" title="事件委托适用场景"></a>事件委托适用场景</h1><ul>
<li>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</li>
<li>不适合使用的事件：mouseover,mouseout和mousemove,因为不是单纯地点击等操作，每次触发都需要重新计算一下位置，处理起来也不是很方便，就不用喽</li>
<li>focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</li>
</ul>
<h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/23/彻底弄懂事件委托/" class="archive-article-date">
  	<time datetime="2016-12-23T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/彻底弄懂事件委托/">彻底弄懂事件委托</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Jasonellen
    	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>

  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/CSS布局之Stickyfooters/" style="font-size: 10px;">CSS布局之Stickyfooters</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JS经典题解析/" style="font-size: 10px;">JS经典题解析</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/RN启动屏/" style="font-size: 10px;">RN启动屏</a> <a href="/tags/Redux进阶/" style="font-size: 10px;">Redux进阶</a> <a href="/tags/SVG图标使用/" style="font-size: 10px;">SVG图标使用</a> <a href="/tags/Vue之路由和请求/" style="font-size: 10px;">Vue之路由和请求</a> <a href="/tags/Vue单例组件/" style="font-size: 10px;">Vue单例组件</a> <a href="/tags/Vue数据绑定/" style="font-size: 10px;">Vue数据绑定</a> <a href="/tags/Vue表单与组件/" style="font-size: 10px;">Vue表单与组件</a> <a href="/tags/fetch-faild-in-reactnative/" style="font-size: 10px;">fetch faild in reactnative</a> <a href="/tags/imgClipUpload/" style="font-size: 10px;">imgClipUpload</a> <a href="/tags/import/" style="font-size: 10px;">import</a> <a href="/tags/jQuery对象之deferred/" style="font-size: 10px;">jQuery对象之deferred</a> <a href="/tags/js坐标/" style="font-size: 10px;">js坐标</a> <a href="/tags/mobiscroll/" style="font-size: 10px;">mobiscroll</a> <a href="/tags/php入门/" style="font-size: 10px;">php入门</a> <a href="/tags/php文件操作/" style="font-size: 10px;">php文件操作</a> <a href="/tags/php缓存文件/" style="font-size: 10px;">php缓存文件</a> <a href="/tags/redux入门/" style="font-size: 10px;">redux入门</a> <a href="/tags/saga-begining/" style="font-size: 10px;">saga-begining</a> <a href="/tags/this用法/" style="font-size: 10px;">this用法</a> <a href="/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/tags/webpack2/" style="font-size: 10px;">webpack2</a> <a href="/tags/博观而约取，厚积而薄发/" style="font-size: 10px;">博观而约取，厚积而薄发</a> <a href="/tags/图片预览上传/" style="font-size: 10px;">图片预览上传</a> <a href="/tags/开启一个简单的CDN加速/" style="font-size: 10px;">开启一个简单的CDN加速</a> <a href="/tags/弹性球/" style="font-size: 10px;">弹性球</a> <a href="/tags/彻底弄懂事件委托/" style="font-size: 10px;">彻底弄懂事件委托</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/手机端自适应单位换算/" style="font-size: 10px;">手机端自适应单位换算</a> <a href="/tags/扒一扒JQuery的几个技巧/" style="font-size: 10px;">扒一扒JQuery的几个技巧</a> <a href="/tags/数据库基本操作（一）/" style="font-size: 10px;">数据库基本操作（一）</a> <a href="/tags/数据库基本操作（二）/" style="font-size: 10px;">数据库基本操作（二）</a> <a href="/tags/文件拖拽/" style="font-size: 10px;">文件拖拽</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/滤镜/" style="font-size: 10px;">滤镜</a> <a href="/tags/移动端布局-事件/" style="font-size: 10px;">移动端布局+事件</a> <a href="/tags/简版日历/" style="font-size: 10px;">简版日历</a> <a href="/tags/粒子运动/" style="font-size: 10px;">粒子运动</a> <a href="/tags/聊天室/" style="font-size: 10px;">聊天室</a> <a href="/tags/配置相关-eslint/" style="font-size: 10px;">配置相关-eslint</a> <a href="/tags/配置相关—npm/" style="font-size: 10px;">配置相关—npm</a> <a href="/tags/配置相关—package-json/" style="font-size: 10px;">配置相关—package.json</a> <a href="/tags/面向对象编程/" style="font-size: 20px;">面向对象编程</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cn.bing.com/">必应</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://gold.xitu.io/">掘金</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="//vuefe.cn/guide/">Vue</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">百度</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://yaomengyyu.github.io/">家浩</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://wangyalijas.github.io/">王雅丽</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;我只是想学记录点东西&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>


    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>
</div>
  </div>
</body>
</html>