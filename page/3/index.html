<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <meta name="baidu-site-verification" content="ggTdcuuNh2" />
  <link rel="dns-prefetch" href="http://Jasonellen.github.io">
  <title>奋斗蚁🐜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="奋斗蚁🐜">
<meta property="og:url" content="http://Jasonellen.github.io/page/3/index.html">
<meta property="og:site_name" content="奋斗蚁🐜">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="奋斗蚁🐜">
  
    <link rel="alternative" href="/atom.xml" title="奋斗蚁🐜" type="application/atom+xml">
  
  
    <link rel="icon" href="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jasonellen</a></h1>
		</hgroup>

		
		<p class="header-subtitle">前端拼搏中的小小蚁🐜</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">文章列表</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="//github.com/Jasonellen/" title="github">github</a>
		        
			</div>
		</nav>
	</header>			
</div>



      <div class="ball" style=' width:100px;
            height:100px;
            position: absolute;
            bottom:0;
            left:200px;
            background: url(http://img3.imgtn.bdimg.com/it/u=2342940863,4159168232&fm=23&gp=0.jpg) no-repeat;
            background-size:contain;
            border-radius:50%;
      '>
      </div>

        <script>
            var ball = document.querySelector(".ball");
            gravBall(ball);

            function gravBall(obj){
                var timer = null;
                var speedX =0, speedY=0,x=0,y=0;
                var gapX =0, gapY=0;

                // obj.onmousedown = down;
                addHandler(obj,'mousedown',down);
                addHandler(obj,'mouseup',up);

                function down(ev){           
                    clearInterval(timer); 
                    var ev = ev || window.event;
                    gapX = ev.clientX - obj.offsetLeft;
                    gapY = ev.clientY - obj.offsetTop;
                    addHandler(document,'mousemove',move);    
                }
                function up(){
                    var currentX=0,currentY=0,l=0,t=0;
                    removeHandler(document,'mousemove',move)
                    clearInterval(timer); 
                    timer = setInterval(function(){
                        speedY +=3;  //一直有一个Y方向的增加，仿重力
                        currentX = window.innerWidth - obj.offsetWidth;
                        currentY = window.innerHeight - obj.offsetHeight;
                        l = obj.offsetLeft + speedX;
                        t = obj.offsetTop + speedY;
                        //speedY +=3;  //放在这里就是先判断再+3，根本停不下来
                        if(l > currentX){
                            speedX *= -0.8;
                            l =currentX;
                        }
                        if(l < 0){
                            speedX *= -0.8;
                            l = 0;
                        }
                        if(t > currentY){
                            speedY *= -0.8;
                            speedX *= 0.8;
                            t = currentY;
                        }
                        if(t < 0){
                            speedY *= -0.8;
                            speedX *= 0.8;
                            t = 0;
                        }
                        if( Math.abs(t-currentY)<1 && Math.abs(speedY)<1.5 && Math.abs(speedX)<1.5){
                            clearInterval(timer);
                        }
                        obj.style.left = l  + "px";
                        obj.style.top = t  + "px";
                    },30)
                }

                function move(ev){
                    var ev = ev || window.event;
                    //难点一，记录当前速度 是最后一次的offsetLeft减去上一次的offsetLeft
                    speedX = ev.clientX - x - gapX;
                    speedY = ev.clientY - y - gapY;
                    //记录本次的offsetLeft作为下一次移动的的上一次的offsetLeft；
                    x = obj.offsetLeft;
                    y = obj.offsetTop;
                    var evX = ev.clientX;
                    var evY = ev.clientY;
                    if(ev.clientX<gapX || ev.clientX>window.innerWidth-gapX || ev.clientY<0 || ev.clientY>window.innerHeight){
                        up();
                    }
                    obj.style.left = evX - gapX  + "px";
                    obj.style.top = evY - gapY  + "px";
                }
            }


            function addHandler(element,type,handler){
                if(element.addEventListener){//检测是否为DOM2级方法
                    element.addEventListener(type, handler, false);
                }else if (element.attachEvent){//检测是否为IE级方法
                    element.attachEvent("on" + type, handler);
                } else {//检测是否为DOM0级方法
                    element["on" + type] = handler;
                }
            }
             function removeHandler(element, type, handler){
                if (element.removeEventListener){
                    element.removeEventListener(type, handler, false);
                } else if (element.detachEvent){
                    element.detachEvent("on" + type, handler);
                } else {
                    element["on" + type] = null;
                }
            }  
        </script>  
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Jasonellen</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://ww1.sinaimg.cn/small/908edb0ejw8fa0vrjx3bbj2050050jrg.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Jasonellen</h1>
			</hgroup>
			
			<p class="header-subtitle">前端拼搏中的小小蚁🐜</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="//github.com/Jasonellen/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-配置相关—npm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/配置相关—npm/">配置相关—npm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>npm</code>有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为<a href="http://npmjs.org" target="_blank" rel="external">npmjs.org</a>。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。</p>
<p><code>npm</code>不需要单独安装。在安装Node的时候，会连带一起安装<code>npm</code>。但是，Node附带的<code>npm</code>可能不是最新版本，最好用下面的命令，更新到最新版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install npm@latest -g</div></pre></td></tr></table></figure>
<p>上面的命令中，<code>@latest</code>表示最新版本，<code>-g</code>表示全局安装。所以，命令的主干是<code>npm install npm</code>，也就是使用<code>npm</code>安装自己。之所以可以这样，是因为<code>npm</code>本身与Node的其他模块没有区别。</p>
<p>然后，运行下面的命令，查看各种信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 查看 npm 命令列表</div><div class="line">$ npm help</div><div class="line"></div><div class="line"># 查看各个命令的简单用法</div><div class="line">$ npm -l</div><div class="line"></div><div class="line"># 查看 npm 的版本</div><div class="line">$ npm -v</div><div class="line"></div><div class="line"># 查看 npm 的配置</div><div class="line">$ npm config list -l</div></pre></td></tr></table></figure>
<h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><p><code>npm init</code>用来初始化生成一个新的<code>package.json</code>文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。</p>
<p>如果使用了<code>-f</code>（代表force）、<code>-y</code>（代表yes），则跳过提问阶段，直接生成一个新的<code>package.json</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init -y</div></pre></td></tr></table></figure>
<h2 id="npm-set"><a href="#npm-set" class="headerlink" title="npm set"></a>npm set</h2><p><code>npm set</code>用来设置环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm set init-author-name &apos;Your name&apos;</div><div class="line">$ npm set init-author-email &apos;Your email&apos;</div><div class="line">$ npm set init-author-url &apos;http://yourdomain.com&apos;</div><div class="line">$ npm set init-license &apos;MIT&apos;</div></pre></td></tr></table></figure>
<p>上面命令等于为<code>npm init</code>设置了默认值，以后执行<code>npm init</code>的时候，<code>package.json</code>的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 <code>~/.npmrc</code>文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行<code>npm config</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm set save-exact true</div></pre></td></tr></table></figure>
<p>上面命令设置加入模块时，<code>package.json</code>将记录模块的确切版本，而不是一个可选的版本范围。</p>
<h2 id="npm-config"><a href="#npm-config" class="headerlink" title="npm config"></a>npm config</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config set prefix $dir</div></pre></td></tr></table></figure>
<p>上面的命令将指定的<code>$dir</code>目录，设为模块的全局安装目录。如果当前有这个目录的写权限，那么运行<code>npm install</code>的时候，就不再需要<code>sudo</code>命令授权了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config set save-prefix ~</div></pre></td></tr></table></figure>
<p>上面的命令使得<code>npm install --save</code>和<code>npm install --save-dev</code>安装新模块时，允许的版本范围从克拉符号（<code>^</code>）改成波浪号（<code>~</code>），即从允许小版本升级，变成只允许补丁包的升级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm config set init.author.name $name</div><div class="line">$ npm config set init.author.email $email</div></pre></td></tr></table></figure>
<p>上面命令指定使用<code>npm init</code>时，生成的<code>package.json</code>文件的字段默认值。</p>
<h2 id="npm-info"><a href="#npm-info" class="headerlink" title="npm info"></a>npm info</h2><p><code>npm info</code>命令可以查看每个模块的具体信息。比如，查看underscore模块的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ npm info underscore</div><div class="line">&#123; name: &apos;underscore&apos;,</div><div class="line">  description: &apos;JavaScript\&apos;s functional programming helper library.&apos;,</div><div class="line">  &apos;dist-tags&apos;: &#123; latest: &apos;1.5.2&apos;, stable: &apos;1.5.2&apos; &#125;,</div><div class="line">  repository:</div><div class="line">   &#123; type: &apos;git&apos;,</div><div class="line">     url: &apos;git://github.com/jashkenas/underscore.git&apos; &#125;,</div><div class="line">  homepage: &apos;http://underscorejs.org&apos;,</div><div class="line">  main: &apos;underscore.js&apos;,</div><div class="line">  version: &apos;1.5.2&apos;,</div><div class="line">  devDependencies: &#123; phantomjs: &apos;1.9.0-1&apos; &#125;,</div><div class="line">  licenses:</div><div class="line">   &#123; type: &apos;MIT&apos;,</div><div class="line">     url: &apos;https://raw.github.com/jashkenas/underscore/master/LICENSE&apos; &#125;,</div><div class="line">  files:</div><div class="line">   [ &apos;underscore.js&apos;,</div><div class="line">     &apos;underscore-min.js&apos;,</div><div class="line">     &apos;LICENSE&apos; ],</div><div class="line">  readmeFilename: &apos;README.md&apos;&#125;</div></pre></td></tr></table></figure>
<p>上面命令返回一个JavaScript对象，包含了underscore模块的详细信息。这个对象的每个成员，都可以直接从info命令查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ npm info underscore description</div><div class="line">JavaScript&apos;s functional programming helper library.</div><div class="line"></div><div class="line">$ npm info underscore homepage</div><div class="line">http://underscorejs.org</div><div class="line"></div><div class="line">$ npm info underscore version</div><div class="line">1.5.2</div></pre></td></tr></table></figure>
<h2 id="npm-search"><a href="#npm-search" class="headerlink" title="npm search"></a>npm search</h2><p><code>npm search</code>命令用于搜索npm仓库，它后面可以跟字符串，也可以跟正则表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm search &lt;搜索词&gt;</div></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ npm search node-gyp</div><div class="line">// NAME                  DESCRIPTION</div><div class="line">// autogypi              Autogypi handles dependencies for node-gyp projects.</div><div class="line">// grunt-node-gyp        Run node-gyp commands from Grunt.</div><div class="line">// gyp-io                Temporary solution to let node-gyp run `rebuild` under…</div><div class="line">// ...</div></pre></td></tr></table></figure>
<h2 id="npm-list"><a href="#npm-list" class="headerlink" title="npm list"></a>npm list</h2><p><code>npm list</code>命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm list</div></pre></td></tr></table></figure>
<p>加上global参数，会列出全局安装的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm list -global</div></pre></td></tr></table></figure>
<p><code>npm list</code>命令也可以列出单个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm list underscore</div></pre></td></tr></table></figure>
<h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Node模块采用<code>npm install</code>命令安装。</p>
<p>每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如<code>eslint</code>和<code>gulp</code>。“本地安装”指的是将一个模块下载到当前项目的<code>node_modules</code>子目录，然后只有在项目目录之中，才能调用这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 本地安装</div><div class="line">$ npm install &lt;package name&gt;</div><div class="line"></div><div class="line"># 全局安装</div><div class="line">$ sudo npm install -global &lt;package name&gt;</div><div class="line">$ sudo npm install -g &lt;package name&gt;</div></pre></td></tr></table></figure>
<p><code>npm install</code>也支持直接输入Github代码库地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install git://github.com/package/path.git</div><div class="line">$ npm install git://github.com/package/path.git#0.1.0</div></pre></td></tr></table></figure>
<p>安装之前，<code>npm install</code>会先检查，<code>node_modules</code>目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p>
<p>如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用<code>-f</code>或<code>--force</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install &lt;packageName&gt; --force</div></pre></td></tr></table></figure>
<p>如果你希望，所有模块都要强制重新安装，那就删除<code>node_modules</code>目录，重新执行<code>npm install</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rm -rf node_modules</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<h3 id="安装不同版本"><a href="#安装不同版本" class="headerlink" title="安装不同版本"></a>安装不同版本</h3><p>install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install sax@latest</div><div class="line">$ npm install sax@0.1.1</div><div class="line">$ npm install sax@&quot;&gt;=0.1.0 &lt;0.2.0&quot;</div></pre></td></tr></table></figure>
<p>如果使用<code>--save-exact</code>参数，会在package.json文件指定安装模块的确切版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install readable-stream --save --save-exact</div></pre></td></tr></table></figure>
<p>install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。</p>
<ul>
<li>–save：模块名将被添加到dependencies，可以简化为参数<code>-S</code>。</li>
<li>–save-dev: 模块名将被添加到devDependencies，可以简化为参数<code>-D</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ npm install sax --save</div><div class="line">$ npm install node-tap --save-dev</div><div class="line"># 或者</div><div class="line">$ npm install sax -S</div><div class="line">$ npm install node-tap -D</div></pre></td></tr></table></figure>
<p>如果要安装beta版本的模块，需要使用下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 安装最新的beta版</div><div class="line">$ npm install &lt;module-name&gt;@beta (latest beta)</div><div class="line"></div><div class="line"># 安装指定的beta版</div><div class="line">$ npm install &lt;module-name&gt;@1.3.1-beta.3</div></pre></td></tr></table></figure>
<p><code>npm install</code>默认会安装<code>dependencies</code>字段和<code>devDependencies</code>字段中的所有模块，如果使用<code>--production</code>参数，可以只安装<code>dependencies</code>字段的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install --production</div><div class="line"># 或者</div><div class="line">$ NODE_ENV=production npm install</div></pre></td></tr></table></figure>
<p>一旦安装了某个模块，就可以在代码中用<code>require</code>命令加载这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var backbone = require(&apos;backbone&apos;)</div><div class="line">console.log(backbone.VERSION)</div></pre></td></tr></table></figure>
<h2 id="避免系统权限"><a href="#避免系统权限" class="headerlink" title="避免系统权限"></a>避免系统权限</h2><p>默认情况下，Npm全局模块都安装在系统目录（比如<code>/usr/local/lib/</code>），普通用户没有写入权限，需要用到<code>sudo</code>命令。这不是很方便，我们可以在没有root权限的情况下，安装全局模块。</p>
<p>首先，在主目录下新建配置文件<code>.npmrc</code>，然后在该文件中将<code>prefix</code>变量定义到主目录下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prefix = /home/yourUsername/npm</div></pre></td></tr></table></figure>
<p>然后在主目录下新建<code>npm</code>子目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/npm</div></pre></td></tr></table></figure>
<p>此后，全局安装的模块都会安装在这个子目录中，npm也会到<code>~/npm/bin</code>目录去寻找命令。</p>
<p>最后，将这个路径在<code>.bash_profile</code>文件（或<code>.bashrc</code>文件）中加入PATH变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=~/npm/bin:$PATH</div></pre></td></tr></table></figure>
<h2 id="npm-update，npm-uninstall"><a href="#npm-update，npm-uninstall" class="headerlink" title="npm update，npm uninstall"></a>npm update，npm uninstall</h2><p><code>npm update</code>命令可以更新本地安装的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 升级当前项目的指定模块</div><div class="line">$ npm update [package name]</div><div class="line"></div><div class="line"># 升级全局安装的模块</div><div class="line">$ npm update -global [package name]</div></pre></td></tr></table></figure>
<p>它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。</p>
<p>使用<code>-S</code>或<code>--save</code>参数，可以在安装的时候更新<code>package.json</code>里面模块的版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 更新之前的package.json</div><div class="line">dependencies: &#123;</div><div class="line">  dep1: &quot;^1.1.1&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 更新之后的package.json</div><div class="line">dependencies: &#123;</div><div class="line">  dep1: &quot;^1.2.2&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，从npm v2.6.1 开始，<code>npm update</code>只更新顶层模块，而不更新依赖的依赖，以前版本是递归更新的。如果想取到老版本的效果，要使用下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm --depth 9999 update</div></pre></td></tr></table></figure>
<p><code>npm uninstall</code>命令，卸载已安装的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm uninstall [package name]</div><div class="line"></div><div class="line"># 卸载全局模块</div><div class="line">$ npm uninstall [package name] -global</div></pre></td></tr></table></figure>
<h2 id="npm-run"><a href="#npm-run" class="headerlink" title="npm run"></a>npm run</h2><p><code>npm</code>不仅可以用于模块管理，还可以用于执行脚本。<code>package.json</code>文件有一个<code>scripts</code>字段，可以用于指定脚本命令，供<code>npm</code>直接调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;myproject&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;jshint&quot;: &quot;latest&quot;,</div><div class="line">    &quot;browserify&quot;: &quot;latest&quot;,</div><div class="line">    &quot;mocha&quot;: &quot;latest&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;lint&quot;: &quot;jshint **.js&quot;,</div><div class="line">    &quot;test&quot;: &quot;mocha test/&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>scripts</code>字段指定了两项命令<code>lint</code>和<code>test</code>。命令行输入<code>npm run-script lint</code>或者<code>npm run lint</code>，就会执行<code>jshint **.js</code>，输入<code>npm run-script test</code>或者<code>npm run test</code>，就会执行<code>mocha test/</code>。<code>npm run</code>是<code>npm run-script</code>的缩写，一般都使用前者，但是后者可以更好地反应这个命令的本质。</p>
<p><code>npm run</code>命令会自动在环境变量<code>$PATH</code>添加<code>node_modules/.bin</code>目录，所以<code>scripts</code>字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。</p>
<p><code>npm run</code>如果不加任何参数，直接运行，会列出<code>package.json</code>里面所有可以执行的脚本命令。</p>
<p>npm内置了两个命令简写，<code>npm test</code>等同于执行<code>npm run test</code>，<code>npm start</code>等同于执行<code>npm run start</code>。</p>
<p><code>npm run</code>会创建一个Shell，执行指定的命令，并临时将<code>node_modules/.bin</code>加入PATH变量，这意味着本地模块可以直接运行。</p>
<p>举例来说，你执行ESLint的安装命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i eslint --save-dev</div></pre></td></tr></table></figure>
<p>运行上面的命令以后，会产生两个结果。首先，ESLint被安装到当前目录的<code>node_modules</code>子目录；其次，<code>node_modules/.bin</code>目录会生成一个符号链接<code>node_modules/.bin/eslint</code>，指向ESLint模块的可执行脚本。</p>
<p>然后，你就可以在<code>package.json</code>的<code>script</code>属性里面，不带路径的引用<code>eslint</code>这个脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;Test Project&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;eslint&quot;: &quot;^1.10.3&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;lint&quot;: &quot;eslint .&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等到运行<code>npm run lint</code>的时候，它会自动执行<code>./node_modules/.bin/eslint .</code>。</p>
<p>如果直接运行<code>npm run</code>不给出任何参数，就会列出<code>scripts</code>属性下所有命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ npm run</div><div class="line">Available scripts in the user-service package:</div><div class="line">  lint</div><div class="line">     jshint **.js</div><div class="line">  test</div><div class="line">    mocha test/</div></pre></td></tr></table></figure>
<p>下面是另一个<code>package.json</code>文件的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;watch&quot;: &quot;watchify client/main.js -o public/app.js -v&quot;,</div><div class="line">  &quot;build&quot;: &quot;browserify client/main.js -o public/app.js&quot;,</div><div class="line">  &quot;start&quot;: &quot;npm run watch &amp; nodemon server.js&quot;,</div><div class="line">  &quot;test&quot;: &quot;node test/all.js&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面代码在<code>scripts</code>项，定义了四个别名，每个别名都有对应的脚本命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm run watch</div><div class="line">$ npm run build</div><div class="line">$ npm run start</div><div class="line">$ npm run test</div></pre></td></tr></table></figure>
<p>其中，<code>start</code>和<code>test</code>属于特殊命令，可以省略<code>run</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm start</div><div class="line">$ npm test</div></pre></td></tr></table></figure>
<p>如果希望一个操作的输出，是另一个操作的输入，可以借用Linux系统的管道命令，将两个操作连在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;build-js&quot;: &quot;browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js&quot;</div></pre></td></tr></table></figure>
<p>但是，更方便的写法是引用其他<code>npm run</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;build&quot;: &quot;npm run build-js &amp;&amp; npm run build-css&quot;</div></pre></td></tr></table></figure>
<p>上面的写法是先运行<code>npm run build-js</code>，然后再运行<code>npm run build-css</code>，两个命令中间用<code>&amp;&amp;</code>连接。如果希望两个命令同时平行执行，它们中间可以用<code>&amp;</code>连接。</p>
<p>下面是一个流操作的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;devDependencies&quot;: &#123;</div><div class="line">  &quot;autoprefixer&quot;: &quot;latest&quot;,</div><div class="line">  &quot;cssmin&quot;: &quot;latest&quot;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;build:css&quot;: &quot;autoprefixer -b &apos;last 2 versions&apos; &lt; assets/styles/main.css | cssmin &gt; dist/main.css&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写在<code>scripts</code>属性中的命令，也可以在<code>node_modules/.bin</code>目录中直接写成bash脚本。下面是一个bash脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">cd site/main</div><div class="line">browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js</div></pre></td></tr></table></figure>
<p>假定上面的脚本文件名为build.sh，并且权限为可执行，就可以在scripts属性中引用该文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;build-js&quot;: &quot;bin/build.sh&quot;</div></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>npm run</code>命令还可以添加参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;test&quot;: &quot;mocha test/&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码指定<code>npm test</code>，实际运行<code>mocha test/</code>。如果要通过<code>npm test</code>命令，将参数传到mocha，则参数之前要加上两个连词线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm run test -- anothertest.js</div><div class="line"># 等同于</div><div class="line">$ mocha test/ anothertest.js</div></pre></td></tr></table></figure>
<p>上面命令表示，mocha要运行所有<code>test</code>子目录的测试脚本，以及另外一个测试脚本<code>anothertest.js</code>。</p>
<p><code>npm run</code>本身有一个参数<code>-s</code>，表示关闭npm本身的输出，只输出脚本产生的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 输出npm命令头</div><div class="line">$ npm run test</div><div class="line"></div><div class="line">// 不输出npm命令头</div><div class="line">$ npm run -s test</div></pre></td></tr></table></figure>
<h3 id="scripts脚本命令最佳实践"><a href="#scripts脚本命令最佳实践" class="headerlink" title="scripts脚本命令最佳实践"></a>scripts脚本命令最佳实践</h3><p><code>scripts</code>字段的脚本命令，有一些最佳实践，可以方便开发。首先，安装<code>npm-run-all</code>模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install npm-run-all --save-dev</div></pre></td></tr></table></figure>
<p>这个模块用于运行多个<code>scripts</code>脚本命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 继发执行</div><div class="line">$ npm-run-all build:html build:js</div><div class="line"># 等同于</div><div class="line">$ npm run build:html &amp;&amp; npm run build:js</div><div class="line"></div><div class="line"># 并行执行</div><div class="line">$ npm-run-all --parallel watch:html watch:js</div><div class="line"># 等同于</div><div class="line">$ npm run watch:html &amp; npm run watch:js</div><div class="line"></div><div class="line"># 混合执行</div><div class="line">$ npm-run-all clean lint --parallel watch:html watch:js</div><div class="line"># 等同于</div><div class="line">$ npm-run-all clean lint</div><div class="line">$ npm-run-all --parallel watch:html watch:js</div><div class="line"></div><div class="line"># 通配符</div><div class="line">$ npm-run-all --parallel watch:*</div></pre></td></tr></table></figure>
<p>（1）start脚本命令</p>
<p><code>start</code>脚本命令，用于启动应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;start&quot;: &quot;npm-run-all --parallel dev serve&quot;</div></pre></td></tr></table></figure>
<p>上面命令并行执行<code>dev</code>脚本命令和<code>serve</code>脚本命令，等同于下面的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run dev &amp; npm run serve</div></pre></td></tr></table></figure>
<p>如果start脚本没有配置，<code>npm start</code>命令默认执行下面的脚本，前提是模块的根目录存在一个server.js文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node server.js</div></pre></td></tr></table></figure>
<p>（2）dev脚本命令</p>
<p><code>dev</code>脚本命令，规定开发阶段所要做的处理，比如构建网页资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;dev&quot;: &quot;npm-run-all dev:*&quot;</div></pre></td></tr></table></figure>
<p>上面命令用于继发执行所有<code>dev</code>的子命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;predev:sass&quot;: &quot;node-sass --source-map src/css/hoodie.css.map --output-style nested src/sass/base.scss src/css/hoodie.css&quot;</div></pre></td></tr></table></figure>
<p>上面命令将sass文件编译为css文件，并生成source map文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;dev:sass&quot;: &quot;node-sass --source-map src/css/hoodie.css.map --watch --output-style nested src/sass/base.scss src/css/hoodie.css&quot;</div></pre></td></tr></table></figure>
<p>上面命令会监视sass文件的变动，只要有变动，就自动将其编译为css文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;dev:autoprefix&quot;: &quot;postcss --use autoprefixer --autoprefixer.browsers \&quot;&gt; 5%\&quot; --output src/css/hoodie.css src/css/hoodie.css&quot;</div></pre></td></tr></table></figure>
<p>上面命令为css文件加上浏览器前缀，限制条件是只考虑市场份额大于5%的浏览器。</p>
<p>（3）serve脚本命令</p>
<p><code>serve</code>脚本命令用于启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;serve&quot;: &quot;live-server dist/ --port=9090&quot;</div></pre></td></tr></table></figure>
<p>上面命令启动服务，用的是<a href="http://npmjs.com/package/live-server" target="_blank" rel="external">live-server</a>模块，将服务启动在9090端口，展示<code>dist</code>子目录。</p>
<p><code>live-server</code>模块有三个功能。</p>
<ul>
<li>启动一个HTTP服务器，展示指定目录的<code>index.html</code>文件，通过该文件加载各种网络资源，这是<code>file://</code>协议做不到的。</li>
<li>添加自动刷新功能。只要指定目录之中，文件有任何变化，它就会刷新页面。</li>
<li><code>npm run serve</code>命令执行以后，自动打开浏览器。、</li>
</ul>
<p>以前，上面三个功能需要三个模块来完成：<code>http-server</code>、<code>live-reload</code>和<code>opener</code>，现在只要<code>live-server</code>一个模块就够了。</p>
<p>（4）test脚本命令</p>
<p><code>test</code>脚本命令用于执行测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;test&quot;: &quot;npm-run-all test:*&quot;,</div><div class="line">&quot;test:lint&quot;: &quot;sass-lint --verbose --config .sass-lint.yml src/sass/*&quot;</div></pre></td></tr></table></figure>
<p>上面命令规定，执行测试时，运行<code>lint</code>脚本，检查脚本之中的语法错误。</p>
<p>（5）prod脚本命令</p>
<p><code>prod</code>脚本命令，规定进入生产环境时需要做的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;prod&quot;: &quot;npm-run-all prod:*&quot;,</div><div class="line">&quot;prod:sass&quot;: &quot;node-sass --output-style compressed src/sass/base.scss src/css/prod/hoodie.min.css&quot;,</div><div class="line">&quot;prod:autoprefix&quot;: &quot;postcss --use autoprefixer --autoprefixer.browsers &quot;&gt; 5%&quot; --output src/css/prod/hoodie.min.css src/css/prod/hoodie.min.css&quot;</div></pre></td></tr></table></figure>
<p>上面命令将sass文件转为css文件，并加上浏览器前缀。</p>
<p>（6）help脚本命令</p>
<p><code>help</code>脚本命令用于展示帮助信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;help&quot;: &quot;markdown-chalk --input DEVELOPMENT.md&quot;</div></pre></td></tr></table></figure>
<p>上面命令之中，<code>markdown-chalk</code>模块用于将指定的markdown文件，转为彩色文本显示在终端之中。</p>
<p>（7）docs脚本命令</p>
<p><code>docs</code>脚本命令用于生成文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;docs&quot;: &quot;kss-node --source src/sass --homepage ../../styleguide.md&quot;</div></pre></td></tr></table></figure>
<p>上面命令使用<code>kss-node</code>模块，提供源码的注释生成markdown格式的文档。</p>
<h3 id="pre-和-post-脚本"><a href="#pre-和-post-脚本" class="headerlink" title="pre- 和 post- 脚本"></a>pre- 和 post- 脚本</h3><p><code>npm run</code>为每条命令提供了<code>pre-</code>和<code>post-</code>两个钩子（hook）。以<code>npm run lint</code>为例，执行这条命令之前，npm会先查看有没有定义prelint和postlint两个钩子，如果有的话，就会先执行<code>npm run prelint</code>，然后执行<code>npm run lint</code>，最后执行<code>npm run postlint</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;myproject&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;eslint&quot;: &quot;latest&quot;</div><div class="line">    &quot;karma&quot;: &quot;latest&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;lint&quot;: &quot;eslint --cache --ext .js --ext .jsx src&quot;,</div><div class="line">    &quot;test&quot;: &quot;karma start --log-leve=error karma.config.js --single-run=true&quot;,</div><div class="line">    &quot;pretest&quot;: &quot;npm run lint&quot;,</div><div class="line">    &quot;posttest&quot;: &quot;echo &apos;Finished running tests&apos;&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码是一个<code>package.json</code>文件的例子。如果执行<code>npm test</code>，会按下面的顺序执行相应的命令。</p>
<ol>
<li><code>pretest</code></li>
<li><code>test</code></li>
<li><code>posttest</code></li>
</ol>
<p>如果执行过程出错，就不会执行排在后面的脚本，即如果prelint脚本执行出错，就不会接着执行lint和postlint脚本。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;test&quot;: &quot;karma start&quot;,</div><div class="line">  &quot;test:lint&quot;: &quot;eslint . --ext .js --ext .jsx&quot;,</div><div class="line">  &quot;pretest&quot;: &quot;npm run test:lint&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，在运行<code>npm run test</code>之前，会自动检查代码，即运行<code>npm run test:lint</code>命令。</p>
<p>下面是一些常见的<code>pre-</code>和<code>post-</code>脚本。</p>
<ul>
<li><code>prepublish</code>：发布一个模块前执行。</li>
<li><code>postpublish</code>：发布一个模块后执行。</li>
<li><code>preinstall</code>：用户执行<code>npm install</code>命令时，先执行该脚本。</li>
<li><code>postinstall</code>：用户执行<code>npm install</code>命令时，安装结束后执行该脚本，通常用于将下载的源码编译成用户需要的格式，比如有些模块需要在用户机器上跟本地的C++模块一起编译。</li>
<li><code>preuninstall</code>：卸载一个模块前执行。</li>
<li><code>postuninstall</code>：卸载一个模块后执行。</li>
<li><code>preversion</code>：更改模块版本前执行。</li>
<li><code>postversion</code>：更改模块版本后执行。</li>
<li><code>pretest</code>：运行<code>npm test</code>命令前执行。</li>
<li><code>posttest</code>：运行<code>npm test</code>命令后执行。</li>
<li><code>prestop</code>：运行<code>npm stop</code>命令前执行。</li>
<li><code>poststop</code>：运行<code>npm stop</code>命令后执行。</li>
<li><code>prestart</code>：运行<code>npm start</code>命令前执行。</li>
<li><code>poststart</code>：运行<code>npm start</code>命令后执行。</li>
<li><code>prerestart</code>：运行<code>npm restart</code>命令前执行。</li>
<li><code>postrestart</code>：运行<code>npm restart</code>命令后执行。</li>
</ul>
<p>对于最后一个<code>npm restart</code>命令，如果没有设置<code>restart</code>脚本，<code>prerestart</code>和<code>postrestart</code>会依次执行stop和start脚本。</p>
<p>另外，不能在<code>pre</code>脚本之前再加<code>pre</code>，即<code>prepretest</code>脚本不起作用。</p>
<p>注意，即使Npm可以自动运行<code>pre</code>和<code>post</code>脚本，也可以手动执行它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run prepublish</div></pre></td></tr></table></figure>
<p>下面是<code>post install</code>的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;postinstall&quot;: &quot;node lib/post_install.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的这个命令，主要用于处理从Git仓库拉下来的源码。比如，有些源码是用TypeScript写的，可能需要转换一下。</p>
<p>下面是<code>publish</code>钩子的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;dist:modules&quot;: &quot;babel ./src --out-dir ./dist-modules&quot;,</div><div class="line">  &quot;gh-pages&quot;: &quot;webpack&quot;,</div><div class="line">  &quot;gh-pages:deploy&quot;: &quot;gh-pages -d gh-pages&quot;,</div><div class="line">  &quot;prepublish&quot;: &quot;npm run dist:modules&quot;,</div><div class="line">  &quot;postpublish&quot;: &quot;npm run gh-pages &amp;&amp; npm run gh-pages:deploy&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面命令在运行<code>npm run publish</code>时，会先执行Babel编译，然后调用Webpack构建，最后发到Github Pages上面。</p>
<p>以上都是npm相关操作的钩子，如果安装某些模块，还能支持Git相关的钩子。下面以<a href="https://github.com/typicode/husky" target="_blank" rel="external">husky</a>模块为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install husky --save-dev</div></pre></td></tr></table></figure>
<p>安装以后，就能在<code>package.json</code>添加<code>precommit</code>、<code>prepush</code>等钩子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;scripts&quot;: &#123;</div><div class="line">        &quot;lint&quot;: &quot;eslint yourJsFiles.js&quot;,</div><div class="line">        &quot;precommit&quot;: &quot;npm run test &amp;&amp; npm run lint&quot;,</div><div class="line">        &quot;prepush&quot;: &quot;npm run test &amp;&amp; npm run lint&quot;,</div><div class="line">        &quot;...&quot;: &quot;...&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似作用的模块还有<code>pre-commit</code>、<code>precommit-hook</code>等。</p>
<h3 id="内部变量-script字段和config字段"><a href="#内部变量-script字段和config字段" class="headerlink" title="内部变量(script字段和config字段)"></a>内部变量(script字段和config字段)</h3><p>scripts字段可以使用一些内部变量，主要是package.json的各种字段。</p>
<p>比如，package.json的内容是<code>{&quot;name&quot;:&quot;foo&quot;, &quot;version&quot;:&quot;1.2.5&quot;}</code>，那么变量<code>npm_package_name</code>的值是<code>foo</code>，变量<code>npm_package_version</code>的值是1.2.5。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;scripts&quot;:&#123;</div><div class="line">    &quot;bundle&quot;: &quot;mkdir -p build/$npm_package_version/&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行<code>npm run bundle</code>以后，将会生成<code>build/1.2.5/</code>子目录。</p>
<p><code>config</code>字段也可以用于设置内部字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;name&quot;: &quot;fooproject&quot;,</div><div class="line">&quot;config&quot;: &#123;</div><div class="line">  &quot;reporter&quot;: &quot;xunit&quot;</div><div class="line">&#125;,</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;test&quot;: &quot;mocha test/ --reporter $npm_package_config_reporter&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，变量<code>npm_package_config_reporter</code>对应的就是reporter。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>npm的通配符的规则如下。</p>
<ul>
<li><code>*</code> 匹配0个或多个字符</li>
<li><code>?</code> 匹配1个字符</li>
<li><code>[...]</code> 匹配某个范围的字符。如果该范围的第一个字符是<code>!</code>或<code>^</code>，则匹配不在该范围的字符。</li>
<li><code>!(pattern|pattern|pattern)</code> 匹配任何不符合给定的模式</li>
<li><code>?(pattern|pattern|pattern)</code> 匹配0个或1个给定的模式</li>
<li><code>+(pattern|pattern|pattern)</code> 匹配1个或多个给定的模式</li>
<li><code>*(a|b|c)</code> 匹配0个或多个给定的模式</li>
<li><code>@(pattern|pat*|pat?erN)</code> 只匹配给定模式之一</li>
<li><code>**</code> 如果出现在路径部分，表示0个或多个子目录。</li>
</ul>
<h2 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h2><p>开发NPM模块的时候，有时我们会希望，边开发边试用，比如本地调试的时候，<code>require(&#39;myModule&#39;)</code>会自动加载本机开发中的模块。Node规定，使用一个模块时，需要将其安装到全局的或项目的<code>node_modules</code>目录之中。对于开发中的模块，解决方法就是在全局的<code>node_modules</code>目录之中，生成一个符号链接，指向模块的本地目录。</p>
<p><code>npm link</code>就能起到这个作用，会自动建立这个符号链接。</p>
<p>请设想这样一个场景，你开发了一个模块<code>myModule</code>，目录为<code>src/myModule</code>，你自己的项目<code>myProject</code>要用到这个模块，项目目录为<code>src/myProject</code>。首先，在模块目录（<code>src/myModule</code>）下运行<code>npm link</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/myModule$ npm link</div></pre></td></tr></table></figure>
<p>上面的命令会在NPM的全局模块目录内，生成一个符号链接文件，该文件的名字就是<code>package.json</code>文件中指定的模块名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/path/to/global/node_modules/myModule -&gt; src/myModule</div></pre></td></tr></table></figure>
<p>这个时候，已经可以全局调用<code>myModule</code>模块了。但是，如果我们要让这个模块安装在项目内，还要进行下面的步骤。</p>
<p>切换到项目目录，再次运行<code>npm link</code>命令，并指定模块名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/myProject$ npm link myModule</div></pre></td></tr></table></figure>
<p>上面命令等同于生成了本地模块的符号链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/myProject/node_modules/myModule -&gt; /path/to/global/node_modules/myModule</div></pre></td></tr></table></figure>
<p>然后，就可以在你的项目中，加载该模块了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myModule = require(&apos;myModule&apos;);</div></pre></td></tr></table></figure>
<p>这样一来，<code>myModule</code>的任何变化，都可以直接反映在<code>myProject</code>项目之中。但是，这样也出现了风险，任何在<code>myProject</code>目录中对<code>myModule</code>的修改，都会反映到模块的源码中。</p>
<p>如果你的项目不再需要该模块，可以在项目目录内使用<code>npm unlink</code>命令，删除符号链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/myProject$ npm unlink myModule</div></pre></td></tr></table></figure>
<h2 id="npm-bin"><a href="#npm-bin" class="headerlink" title="npm bin"></a>npm bin</h2><p><code>npm bin</code>命令显示相对于当前目录的Node模块的可执行脚本所在的目录（即<code>.bin</code>目录）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 项目根目录下执行</div><div class="line">$ npm bin</div><div class="line">./node_modules/.bin</div></pre></td></tr></table></figure>
<h2 id="npm-adduser"><a href="#npm-adduser" class="headerlink" title="npm adduser"></a>npm adduser</h2><p><code>npm adduser</code>用于在npmjs.com注册一个用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm adduser</div><div class="line">Username: YOUR_USER_NAME</div><div class="line">Password: YOUR_PASSWORD</div><div class="line">Email: YOUR_EMAIL@domain.com</div></pre></td></tr></table></figure>
<h2 id="npm-publish"><a href="#npm-publish" class="headerlink" title="npm publish"></a>npm publish</h2><p><code>npm publish</code>用于将当前模块发布到<code>npmjs.com</code>。执行之前，需要向<code>npmjs.com</code>申请用户名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm adduser</div></pre></td></tr></table></figure>
<p>如果已经注册过，就使用下面的命令登录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm login</div></pre></td></tr></table></figure>
<p>登录以后，就可以使用<code>npm publish</code>命令发布。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm publish</div></pre></td></tr></table></figure>
<p>如果当前模块是一个beta版，比如<code>1.3.1-beta.3</code>，那么发布的时候需要使用<code>tag</code>参数，将其发布到指定标签，默认的发布标签是<code>latest</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm publish --tag beta</div></pre></td></tr></table></figure>
<p>如果发布私有模块，模块初始化的时候，需要加上<code>scope</code>参数。只有npm的付费用户才能发布私有模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init --scope=&lt;yourscope&gt;</div></pre></td></tr></table></figure>
<p>如果你的模块是用ES6写的，那么发布的时候，最好转成ES5。首先，需要安装Babel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-cli@6 babel-preset-es2015@6</div></pre></td></tr></table></figure>
<p>然后，在<code>package.json</code>里面写入<code>build</code>脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;build&quot;: &quot;babel source --presets babel-preset-es2015 --out-dir distribution&quot;,</div><div class="line">  &quot;prepublish&quot;: &quot;npm run build&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的脚本，会将<code>source</code>目录里面的ES6源码文件，转为<code>distribution</code>目录里面的ES5源码文件。然后，在项目根目录下面创建两个文件<code>.npmignore</code>和<code>.gitignore</code>，分别写入以下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// .npmignore</div><div class="line">source</div><div class="line"></div><div class="line">// .gitignore</div><div class="line">node_modules</div><div class="line">distribution</div></pre></td></tr></table></figure>
<h2 id="npm-deprecate"><a href="#npm-deprecate" class="headerlink" title="npm deprecate"></a>npm deprecate</h2><p>如果想废弃某个版本的模块，可以使用<code>npm deprecate</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm deprecate my-thing@&quot;&lt; 0.2.3&quot; &quot;critical bug fixed in v0.2.3&quot;</div></pre></td></tr></table></figure>
<p>运行上面的命令以后，小于<code>0.2.3</code>版本的模块的<code>package.json</code>都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示。</p>
<h2 id="npm-owner"><a href="#npm-owner" class="headerlink" title="npm owner"></a>npm owner</h2><p>模块的维护者可以发布新版本。<code>npm owner</code>命令用于管理模块的维护者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 列出指定模块的维护者</div><div class="line">$ npm owner ls &lt;package name&gt;</div><div class="line"></div><div class="line"># 新增维护者</div><div class="line">$ npm owner add &lt;user&gt; &lt;package name&gt;</div><div class="line"></div><div class="line"># 删除维护者</div><div class="line">$ npm owner rm &lt;user&gt; &lt;package name&gt;</div></pre></td></tr></table></figure>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="npm-home，npm-repo"><a href="#npm-home，npm-repo" class="headerlink" title="npm home，npm repo"></a>npm home，npm repo</h3><p><code>npm home</code>命令可以打开一个模块的主页，<code>npm repo</code>命令则是打开一个模块的代码仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm home $package</div><div class="line">$ npm repo $package</div></pre></td></tr></table></figure>
<p>这两个命令不需要模块先安装。</p>
<h3 id="npm-outdated"><a href="#npm-outdated" class="headerlink" title="npm outdated"></a>npm outdated</h3><p><code>npm outdated</code>命令检查当前项目所依赖的模块，是否已经有新版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm outdated</div></pre></td></tr></table></figure>
<p>它会输出当前版本（current version）、应当安装的版本（wanted version）和最新发布的版本（latest version）。</p>
<h3 id="npm-prune"><a href="#npm-prune" class="headerlink" title="npm prune"></a>npm prune</h3><p><code>npm prune</code>检查当前项目的<code>node_modules</code>目录中，是否有<code>package.json</code>里面没有提到的模块，然后将所有这些模块输出在命令行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm prune</div></pre></td></tr></table></figure>
<h3 id="npm-shrinkwrap"><a href="#npm-shrinkwrap" class="headerlink" title="npm shrinkwrap"></a>npm shrinkwrap</h3><p><code>npm shrinkwrap</code>的作用是锁定当前项目的以来模块的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm shrinkwrap</div></pre></td></tr></table></figure>
<p>运行该命令后，会在当前项目的根目录下生成一个<code>npm-shrinkwrap.json</code>文件，内容是<code>node_modules</code>目录下所有已经安装模块的版本。</p>
<p>下次运行<code>npm install</code>命令时，<code>npm</code>发现当前目录下有<code>npm-shrinkwrap.json</code>文件，就会只安装里面提到的模块，且版本也会保持一致。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/09/配置相关—npm/" class="archive-article-date">
  	<time datetime="2017-03-09T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/配置文件/">配置文件</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-react-redux,applyMiddleware" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/react-redux,applyMiddleware/">react-redux,applyMiddleware</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>react-redux详细教程请参考阮一峰的文章:<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="external">react-redux</a>,这里只是介绍一些基本用法，及自己遇到的一点痛点，<code>applyMiddleware</code>先介绍 两个常用的<code>redux-thunk</code>和<code>redux-logger</code></p>
</blockquote>
<h2 id="统一整理-想到哪写到哪…"><a href="#统一整理-想到哪写到哪…" class="headerlink" title="统一整理(想到哪写到哪…)"></a>统一整理(想到哪写到哪…)</h2><p>项目源码在github上戳<a href="https://github.com/Jasonellen/react-plus" target="_blank" rel="external">react-plus</a></p>
<h3 id="一，react-redux有什么用？"><a href="#一，react-redux有什么用？" class="headerlink" title="一，react-redux有什么用？"></a>一，<code>react-redux</code>有什么用？</h3><p>​    React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component)。</p>
<ul>
<li><p>UI组件只负责 UI 的呈现，不带有任何业务逻辑</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">    /**</div><div class="line">     *state,add,del是哪里的？就是函数mapStateToProps和mapDispatchToProps返回的</div><div class="line">     **/</div><div class="line">    const &#123;state,add,del&#125;=this.props;</div><div class="line">    return (</div><div class="line">        &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">            &lt;View style=&#123;styles.item&#125;&gt;</div><div class="line">                &lt;Text style=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;&#123;state.sum&#125;&lt;/Text&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">            &lt;View style=&#123;[styles.item, &#123;top: 10&#125;]&#125;&gt;</div><div class="line">                &lt;TouchableWithoutFeedback onPress=&#123;add&#125; &gt;</div><div class="line">                    &lt;View style=&#123;styles.touch&#125;&gt;</div><div class="line">                        &lt;Text style=&#123;styles.but&#125;&gt;+&lt;/Text&gt;</div><div class="line">                    &lt;/View&gt;</div><div class="line">                &lt;/TouchableWithoutFeedback&gt;</div><div class="line">            &lt;View&gt;</div><div class="line">        &lt;View&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>所有数据都由参数（<code>this.props</code>）提供</p>
<ul>
<li><p>React-Redux 提供<code>Provider</code>组件，可以让容器组件拿到<code>state</code>。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt; </div><div class="line">    &lt;App /&gt;</div><div class="line">    //然后App组件就可以通过this.props获取`每个组件JS文件内部定义的mapStateToProps中返回的state和mapDispatchToProps中返回的回调方法</div><div class="line">  &lt;/Provider&gt;,</div><div class="line">  document.getElementById(&apos;root&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>React-Redux 提供<code>connect</code>方法，用于从 UI 组件生成容器组件</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function mapStateToProps(state)&#123;</div><div class="line">  return &#123;</div><div class="line">    state: state.Index1 </div><div class="line">    //state是全局的state,Index1是Index1(reducer)返回的state,因为state内部包含所有reducer返回的state,所以这里需要用.语法确定需要传递那个reducer返回的状态给UI组件使用</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function mapDispatchToProps(dispatch) &#123;</div><div class="line">  return&#123;</div><div class="line">	add: () =&gt;   dispatch(IndexAction.add())①</div><div class="line">	//IndexAction.add()执行Action中的一个函数，返回一个action对象</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*action add()函数下面这样</div><div class="line">  export function add() &#123;</div><div class="line">      return &#123;</div><div class="line">          type: &apos;INDEX_ADD&apos;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export default connect(  mapStateToProps,  mapDispatchToProps)(UIComponent)</div><div class="line">//导出容器组件</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>容器组件负责管理数据和业务逻辑</p>
</li>
<li><p>Reducer触发了mapDispatchToProps中的方法后自动执行</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import * as types from &apos;../constant/ActionTypes&apos;;</div><div class="line"></div><div class="line">const initialState = &#123;</div><div class="line">    sum:0</div><div class="line">&#125;;</div><div class="line">export default function IndexReducer(state = initialState, action = &#123;&#125;) &#123;</div><div class="line">    switch (action.type)&#123; </div><div class="line">        case types.INDEX_ADD: ②</div><div class="line">            return &#123;</div><div class="line">                ...state,</div><div class="line">                sum:state.sum+1</div><div class="line">            &#125;;</div><div class="line">            break;</div><div class="line">        case types.INDEX_DEL:</div><div class="line">            return &#123;</div><div class="line">                ...state,</div><div class="line">                sum:state.sum-1</div><div class="line">            &#125;;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return state;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//执行了上面①出的dispatch方法后②出的reducer就会执行并返回最新的状态，那么问题来了,如果我想再来一个➕1的UI，怎么实现呢？直接增加一个UI容器组件，然后加一个reducer像下面这样？</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import * as types from &apos;../constant/ActionTypes&apos;;</div><div class="line">const initialState = &#123;</div><div class="line">    sum:0</div><div class="line">&#125;;</div><div class="line">export default function IndexReducer2(state = initialState, action = &#123;&#125;) &#123;</div><div class="line">    switch (action.type)&#123;</div><div class="line">        case types.INDEX_ADD:</div><div class="line">            return &#123;</div><div class="line">                ...state,</div><div class="line">                sum:state.sum+1</div><div class="line">            &#125;;</div><div class="line">            break;</div><div class="line">        case types.INDEX_DEL:</div><div class="line">            return &#123;</div><div class="line">                ...state,</div><div class="line">                sum:state.sum-1</div><div class="line">            &#125;;</div><div class="line">            break;</div><div class="line">        case types.INDEX_INIT:</div><div class="line">            return &#123;</div><div class="line">                ...state,</div><div class="line">                sum:action.param!=undefined</div><div class="line">            &#125;;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return state;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果就是两个加操作会一起执行，点击第一个加按钮，第二个一起增加，原因是因为点击第一个加按钮和点击第二个加按钮执行的<code>mapDispatchToProps</code>方法都是触发相同的<code>action:{ type: &#39;INDEX_ADD&#39;}</code>所以会触发所有监听此<code>action</code>的所有的reducer,解决的办法就是每个<code>reducer</code>监听自己的<code>action</code>,只要在action增加一个function add2(){ return {  type: types.INDEX2_ADD} },然后设置IndexReducer2，</p>
<p> case types.INDEX2_ADD:<br>​            return {<br>​                …state,<br>​                sum:state.sum+1<br>​            };<br>​            break;</p>
<p>即可完各自reducer监听各自的action执行并返回各自的state</p>
</li>
</ul>
</li>
</ul>
<h3 id="二，redux-logger有什么用？"><a href="#二，redux-logger有什么用？" class="headerlink" title="二，redux-logger有什么用？"></a>二，<code>redux-logger</code>有什么用？</h3><p>就是说为了方便调试，<code>redux-logger</code>中间键会加入到<code>store</code>中后会<code>自动监听</code>状态更新，并在控制台打印出向相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">action @ 00:29:13.950 INDEX_ADD</div><div class="line"> prev state  Object</div><div class="line"> 			 IndexReduer:Object</div><div class="line"> 			 	sum:0</div><div class="line"> action Object</div><div class="line"> 		type:&apos;INDEX_ADD&apos;</div><div class="line"> next state  Object</div><div class="line"> 			 IndexReduer:Object</div><div class="line"> 			 	sum:1</div><div class="line">这样的相关信息...</div></pre></td></tr></table></figure>
<h3 id="三，加入中间键后store的创建方式"><a href="#三，加入中间键后store的创建方式" class="headerlink" title="三，加入中间键后store的创建方式"></a>三，加入中间键后store的创建方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// rootReducer.js</div><div class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</div><div class="line">import IndexReducer from &apos;./IndexReducer&apos;;</div><div class="line">import IndexReducer2 from &apos;./indexReducer2&apos;;</div><div class="line">const RootReducer = combineReducers(&#123;</div><div class="line">    IndexReducer,IndexReducer2  //通过combineReducers合成一个总rootReducer</div><div class="line">&#125;);</div><div class="line">export default RootReducer;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// configure-store.js  //用于生成store</div><div class="line">import &#123;createStore, applyMiddleware&#125; from &apos;redux&apos;;</div><div class="line">import  rootReducer from &apos;../reducer/RootReducer&apos;;</div><div class="line">import thunk from &apos;redux-thunk&apos;;</div><div class="line">const middlewares = [thunk];</div><div class="line"></div><div class="line">const createLogger = require(&apos;redux-logger&apos;);</div><div class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</div><div class="line">    const logger = createLogger();</div><div class="line">    //redux 日志打印</div><div class="line">    middlewares.push(logger);</div><div class="line">&#125;</div><div class="line">// store生成方式一，网上好像这样方式还比较多</div><div class="line">const createStoreWithMiddleware = applyMiddleware(...middlewares)(createStore);</div><div class="line">export default function configureStore(initialState) &#123;</div><div class="line">    const store = createStoreWithMiddleware(rootReducer, initialState);</div><div class="line">    return store;</div><div class="line">&#125;</div><div class="line">// store生成方式二，还是感觉这种比较简单(可以直接在主界面使用)</div><div class="line">export default function configureStore(initialState) &#123;</div><div class="line">   const store = createStore(rootReducer, initialState, applyMiddleware(...middlewares));</div><div class="line">    return store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三，redux-thunk有什么用？"><a href="#三，redux-thunk有什么用？" class="headerlink" title="三，redux-thunk有什么用？"></a>三，<code>redux-thunk</code>有什么用？</h3><p>redux-thunk,是为了异步使用dispatch方法而使用的，和<code>redux-logger</code>一样，由store加入后自动生效，使用场景？我来小举一例：</p>
<p>例如上面的点击加一操作是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1，  const &#123;state,add,del&#125;=this.props;</div><div class="line">2， &lt;Text style=&#123;styles.but&#125; onPress=&#123;add&#125;&gt;+&lt;/Text&gt;</div><div class="line">3， function mapDispatchToProps(dispatch) &#123;</div><div class="line">  		return&#123;</div><div class="line">			add: () =&gt;   dispatch(&#123;type:&apos;INDEX_ADD&apos;&#125;)</div><div class="line">  		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>那么我现在我需要实现点击第一个加一按钮3秒才执行加一，</p>
<p>不用<code>redux-thunk</code>我们可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1， const &#123;state,add,del&#125;=this.props;</div><div class="line">2， startAdd()&#123;</div><div class="line">		setTimeout(function()&#123;</div><div class="line">          add();</div><div class="line">		&#125;,3000)</div><div class="line">	&#125;</div><div class="line">3， &lt;Text style=&#123;styles.but&#125; onPress=&#123;this.startAdd&#125;&gt;+&lt;/Text&gt;</div><div class="line">4， function mapDispatchToProps(dispatch) &#123;</div><div class="line">  		return&#123;</div><div class="line">			add: () =&gt;   dispatch(&#123;type:&apos;INDEX_ADD&apos;&#125;)</div><div class="line">  		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>使用了<code>redux-thunk</code>后可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1， const &#123;state,add,del&#125;=this.props;</div><div class="line">2， &lt;Text style=&#123;styles.but&#125; onPress=&#123;add&#125;&gt;+&lt;/Text&gt;</div><div class="line">3， function mapDispatchToProps(dispatch) &#123;</div><div class="line">  		return&#123;</div><div class="line">			add: () =&gt; dispatch(function(dispatch,getState)&#123;</div><div class="line">			  console.log(getState())</div><div class="line">              setTimeout(function()&#123;</div><div class="line">                dispatch(&#123;type:&apos;INDEX_ADD&apos;&#125;)</div><div class="line">              &#125;,3000)</div><div class="line">			&#125;)</div><div class="line">  		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>也就是说本来只能传入<code>{}</code>作为参数的dispatch用了<code>redux-thunk</code>后可以传一个函数作为参数，然后再这个函数内部执行dispatch就可以了，所有可以在函数内部执行setTimeout和fetch等方法了，实现异步的redux操作，同时thunk还支持第二个参数，用来获取全局state!</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/27/react-redux,applyMiddleware/" class="archive-article-date">
  	<time datetime="2017-02-26T17:09:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-27</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-import" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/import/">import</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>作为一个初学者，在如何导入/导出自己写的组件时，有时也是摸不着头脑，想我当年一样喽☺</p>
</blockquote>
<h1 id="下面列举几个常见的栗子🌰"><a href="#下面列举几个常见的栗子🌰" class="headerlink" title="下面列举几个常见的栗子🌰"></a>下面列举几个常见的栗子🌰</h1><h3 id="1-import-React-Component-from-‘react’"><a href="#1-import-React-Component-from-‘react’" class="headerlink" title="1. import React ,{ Component } from ‘react’;"></a>1. import React ,{ Component } from ‘react’;</h3><pre><code>这是RN 0.26后导入React的方式，这意思是，导入‘react’文件里export的一个默认的组件，将其命名为React以及Component这个非默认组件
</code></pre><p>​    </p>
<h3 id="2-import-Home-from-‘-Home’"><a href="#2-import-Home-from-‘-Home’" class="headerlink" title="2.import Home from ‘./Home’;"></a>2.import Home from ‘./Home’;</h3><pre><code>这是导入‘Home’文件里export的带default关键字的组件，即默认组件,将其命名为Home(可以自定义命名)
</code></pre><p><img src="http://wx4.sinaimg.cn/mw690/908edb0egy1fckd559kn5j20ea0b43z3.jpg" alt=""></p>
<h3 id="3-import-Home-from-‘-Home’"><a href="#3-import-Home-from-‘-Home’" class="headerlink" title="3.import { Home } from ‘./Home’;"></a>3.import { Home } from ‘./Home’;</h3><pre><code>导入‘Home’文件里export的叫Home的 非默认组件，注意，非默认，非默认，非默认，以及命名Home,命名Home,命名Home
</code></pre><p>​    </p>
<h3 id="4-import-Home-Discover-from-‘-Home’"><a href="#4-import-Home-Discover-from-‘-Home’" class="headerlink" title="4.import { Home , Discover } from ‘/Home’;"></a>4.import { Home , Discover } from ‘/Home’;</h3><pre><code>跟3的差不多，不过是{  },可以导入多个组件，用，隔开就可以
</code></pre><p>​    </p>
<h3 id="5-import-as-Home-from’-compoments-Home’"><a href="#5-import-as-Home-from’-compoments-Home’" class="headerlink" title="5.import * as Home from’./compoments/Home’;"></a>5.import * as Home from’./compoments/Home’;</h3><pre><code>意思是将./compoments/Home&apos;文件里的所有非默认组件，全部集结成一个Home模型组件，命名可以自定义，然后可以通过点语法，来使用组件里面的所有export的组件，例如：
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/908edb0egy1fckda4pc8gj20hx0bgmy0.jpg" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/21/import/" class="archive-article-date">
  	<time datetime="2017-02-21T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/import/">import</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-redux入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/redux入门/">redux入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>个人只是把redux和vuex当做进行统一状态管理的工具，那个和上一篇vuex一样，这里还是举个相同的加减栗子来对redux做个入门介绍</p>
</blockquote>
<h1 id="Redux-基础概念"><a href="#Redux-基础概念" class="headerlink" title="Redux 基础概念"></a>Redux 基础概念</h1><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><pre><code>State 描述一个应用程序的全部状态,所有需要控制的状态都应设计到 state 对象中
</code></pre><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><pre><code>Action 用来描述一个行为，并负载相应的信息。
</code></pre><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><pre><code>Reducer 接收两个参数，第一个参数是当前状态，而第二参数是 action, 返回更新后的状态。
用来执行store触发的Action对应的方法
</code></pre><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><pre><code>Store 是管理应用程序 state 的容器

store = {
    getState,
    dispatch,
    subscribe,
    replaceReducer
}
</code></pre><h4 id="如上，store共有4个API"><a href="#如上，store共有4个API" class="headerlink" title="如上，store共有4个API,"></a>如上，store共有4个API,</h4><pre><code>getState: (数据接口)
使用方式: store.getState()
功能点: redux对外导出数据的接口(getter)

subscribe: (订阅接口)
使用方式: store.subscribe(回调函数)
功能点: 在每次执行dispatch的时候，用于执行自定义的回调函数操作

dispatch: (执行接口)
使用方式: store.dispatch(action)
功能点: 在执行redux的state更新的同时，执行所有subscribe过的回调函数

replaceReducer: (重置store接口)
使用方式: store.replaceReducer(nextReducer)
功能点: 重置redux的reducer，重新启动store流程
</code></pre><h3 id="流程图如下"><a href="#流程图如下" class="headerlink" title="流程图如下"></a>流程图如下</h3><p><img src="http://wx4.sinaimg.cn/mw690/908edb0egy1fchwn37a5fj20jf0d5mx6.jpg" alt=""></p>
<h2 id="项目实战："><a href="#项目实战：" class="headerlink" title="项目实战："></a>项目实战：</h2><p><strong>首先安装redux到项目中</strong></p>
<pre><code>npm install --save redux
</code></pre><p><strong>代码编写</strong></p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><pre><code>&lt;p&gt;
    Clicked: &lt;span id=&quot;value&quot;&gt;0&lt;/span&gt;
    &lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt;
    &lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt;
&lt;/p&gt;
</code></pre><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><pre><code>//导入createStroe
import { createStore } from &apos;redux&apos;

//初始化状态
let initState = {
      count: 0,
      score: 0,
      description:&apos;描述&apos;
}

//创建一个Reducer
function counter(state = initState, action) {
    switch (action.type) {
        case &apos;INCREMENT&apos;:
              return{
                  count:state.count + 1,
                score:state.score + 2,
                description:action.data
              } 
        case &apos;DECREMENT&apos;:
              return{
                  count:state.count - 1,
                score:state.score - 2,
                description:action.data
              } 
        default:
              return state;
          }
    }

//将创建好的Reducer传入创建Store
let store = Redux.createStore(counter);

//获取元素节点，并绑定点击事件，点击后store将触发相应的动作Action
let valueEl = document.getElementById(&apos;value&apos;);
document.getElementById(&apos;increment&apos;).addEventListener(&apos;click&apos;, function() {
    store.dispatch({
          type: &apos;INCREMENT&apos;,
          data:&apos;增加的&apos;
    })
})
document.getElementById(&apos;decrement&apos;).addEventListener(&apos;click&apos;, function() {
    store.dispatch({
          type: &apos;DECREMENT&apos;,
          data:&apos;减少的&apos;,
    })
})

//写一个render方法，在这里动态改变元素的内容
function render() {
    valueEl.innerHTML = &apos;点击&apos;+store.getState().count.toString()+&apos;次-得        分&apos;+store.getState().score.toString()+store.getState().description;
}

//执行render方法
render();

//绑定subscribe回调
store.subscribe(render);
</code></pre><h5 id="上述JS文件，当按钮点击的时候-redux的状态管理者store调用dispatch-API触发相应type的Action-然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl-innerHTML的值并没有改变，此时需要调用store-subscribe-render-函数执行回调函数render"><a href="#上述JS文件，当按钮点击的时候-redux的状态管理者store调用dispatch-API触发相应type的Action-然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl-innerHTML的值并没有改变，此时需要调用store-subscribe-render-函数执行回调函数render" class="headerlink" title="上述JS文件，当按钮点击的时候 redux的状态管理者store调用dispatch API触发相应type的Action,然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl.innerHTML的值并没有改变，此时需要调用store.subscribe(render)函数执行回调函数render()"></a>上述JS文件，当按钮点击的时候 redux的状态管理者store调用dispatch API触发相应type的Action,然后Reducer就会通过对应的Acton执行对应的方法，改变Redux的状态，此时虽然状态改变了，但是valueEl.innerHTML的值并没有改变，此时需要调用store.subscribe(render)函数执行回调函数render()</h5><h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/21/redux入门/" class="archive-article-date">
  	<time datetime="2017-02-21T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-fetch_faild_in_reactnative" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/fetch_faild_in_reactnative/">fetch faild in reactnative</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>fetch在ReactNative中可能会报错如下：Possible unhandled promise rejection (id:0: Network request failed</p>
</blockquote>
<h3 id="According-to-this-post-you-should-enable-it-in-XCode"><a href="#According-to-this-post-you-should-enable-it-in-XCode" class="headerlink" title="According to this post, you should enable it in XCode."></a>According to this post, you should enable it in XCode.</h3><ol>
<li>Click on your project in the Project Navigator</li>
<li>Open the Info tab</li>
<li>Click on the down arrow left to the “App Transport Security Settings”</li>
<li>Right click on “App Transport Security Settings” and select Add Row</li>
<li>For created row set the key “Allow Arbitrary Loads“, type to boolean and value to YES.</li>
</ol>
<p><img src="http://wx4.sinaimg.cn/mw690/908edb0egy1fd057agsrdj20hk07yjuv.jpg" alt=""></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/14/fetch_faild_in_reactnative/" class="archive-article-date">
  	<time datetime="2017-02-14T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/">ReactNative</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/24/vuex/">vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>关于vuex到底是什么，看到眼热就去查了下资料，然后扯出来一堆flux、redux、state、state之类的概念，以及大型工程必要性之类的，我只想说，整这么复杂干什么？走远了..</p>
</blockquote>
<h1 id="什么是vuex-作用又是什么？"><a href="#什么是vuex-作用又是什么？" class="headerlink" title="什么是vuex,作用又是什么？"></a>什么是vuex,作用又是什么？</h1><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态 。这里的关键在于 集中式存储管理 。这意味着本来需要共享状态的更新是需要组件之间通讯的，而现在有了vuex，就组件就都和store通讯了</p>
<h3 id="简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件"><a href="#简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件" class="headerlink" title="简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件"></a>简言之就是，当我们的应用遇到多个组件共享状态时解决这一问题的一个状态管理中间件</h3><p><code>应用场景：</code><br></p>
<ul>
<li>多个组件依赖于同一状态。传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</li>
<li>来自不同组件的行为需要变更同一状态。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><strong>当我们需要制作一个加一，减一操作按钮的时候，用下面两个demo做一个演示</strong><h3 id="未使用vuex"><a href="#未使用vuex" class="headerlink" title="未使用vuex"></a>未使用vuex</h3></li>
<li>单纯依赖于vue.js</li>
</ul>
</blockquote>
<p>   <script src="https://unpkg.com/vue/dist/vue.js"></script><br>       <div id="app"><br>             <p><br>                   <button @click="inc">+</button><br>                   <button @click="dec">-</button><br>             </p><br>         </div><br>         <script><br>         new Vue({<br>           el:’#app’,<br>           data () {<br>             return {<br>               count: 0<br>             }<br>           },<br>           methods: {<br>             inc () {<br>               this.count++<br>             },<br>             dec () {<br>               this.count–<br>             }<br>           }<br>         })<br>         </script><br>   整个代码结构非常清晰，代码是代码，数据是数据，代码就是放在methods数组内的两个函数inc、dec，被指令@click关联到button上。而data内返回一个属性count，此属性通过绑定到标签p内。从而可以动态的改为count的值。</p>
<h2 id="使用vuex"><a href="#使用vuex" class="headerlink" title="使用vuex"></a>使用vuex</h2><ul>
<li><p>依赖vue.js，也使用了vuex技术</p>
<p> <script src="https://unpkg.com/vue/dist/vue.js"></script></p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vuex@next&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{count}}
        &lt;button @click=&quot;inc&quot;&gt;+&lt;/button&gt;
        &lt;button @click=&quot;dec&quot;&gt;-&lt;/button&gt;
    &lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    const store = new Vuex.Store({
        state: {
          count: 0
        },
        mutations: {
            inc: state =&gt; state.count++,
          dec: state =&gt; state.count--
        }
    })
      const app = new Vue({
        el: &apos;#app&apos;,
        computed: {
          count () {
             return store.state.count
          }
        },
        methods: {
          inc () {
                store.commit(&apos;inc&apos;) //执行store.inc放大
          },
          dec () {
              store.commit(&apos;dec&apos;)
          }
        }
    })
&lt;/script&gt;
</code></pre><h4 id="我们先看到有哪些重要的变化："><a href="#我们先看到有哪些重要的变化：" class="headerlink" title="我们先看到有哪些重要的变化："></a>我们先看到有哪些重要的变化：</h4></li>
</ul>
<ol>
<li>新的代码添加了对vuex@next脚本的依赖。这是当然的，因为你需要使用vuex的技术，当然需要引用它</li>
<li>methods数组还是这两个方法，这和demo1是一样的；但是方法内的计算逻辑，不再是在函数内进行，而是提交给store对象！这是一个新的对象！</li>
<li>count数据也不再是一个data函数返回的对象的属性；而是通过计算字段来返回，并且在计算字段内的代码也不是自己算的，而是转发给store对象</li>
<li>store对象是Vuex.Store的实例。在store内有分为state对象和mutations对象，其中的state放置 状态 ,mutations则是一个会引发状态改变的所有方法。正如我们看到的，目前的state对象，其中的状态就只有一个count。而mutations有两个成员，它们参数为state，在函数体内对state内的count成员做加1和减1的操作。</li>
</ol>
<p><strong>总结：</strong>就是说，之前在vue实例内做的操作和数据的计算现在都不再自己做了，而是交由对象store来做了。</p>
<h4 id="用了vuex感觉更复杂了？"><a href="#用了vuex感觉更复杂了？" class="headerlink" title="用了vuex感觉更复杂了？"></a>用了<code>vuex</code>感觉更复杂了？</h4><p>你的感觉没错，这就是为什么官网再次会提到Vuex构建大型应用的价值。 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex 。</p>
<h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/24/vuex/" class="archive-article-date">
  	<time datetime="2017-01-24T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-扒一扒jquery的几个技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/21/扒一扒jquery的几个技巧/">扒一扒JQuery的几个技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-jQuery方法-实际上是拥有两个参数的"><a href="#1-jQuery方法-实际上是拥有两个参数的" class="headerlink" title="1.jQuery方法$()实际上是拥有两个参数的"></a>1.jQuery方法$()实际上是拥有两个参数的</h3><h5 id="Create-an-element-The-second-argument-is-an-object-with-jQuery-methods-to-be-called"><a href="#Create-an-element-The-second-argument-is-an-object-with-jQuery-methods-to-be-called" class="headerlink" title="Create an element. The second argument is an object with jQuery methods to be called"></a>Create an element. The second argument is an object with jQuery methods to be called</h5><pre><code>var div = $(&apos;&lt;div&gt;&apos;,{
    &quot;class&quot;: &quot;bigBlue&quot;,
    &quot;css&quot;: {
        &quot;background-color&quot;:&quot;purple&quot;,
        &quot;width&quot; : 20,
        &quot;height&quot;: 20,
    },
    &quot;animate&quot; : {   // You can use any jQuery method as a property!
        &quot;width&quot;: 200,
        &quot;height&quot;:50
    }
});

div.appendTo(&apos;#eleID&apos;);
</code></pre><h3 id="2-使用js给多个元素添加样式时更好的做法是创建一个style元素。"><a href="#2-使用js给多个元素添加样式时更好的做法是创建一个style元素。" class="headerlink" title="2.使用js给多个元素添加样式时更好的做法是创建一个style元素。"></a>2.使用js给多个元素添加样式时更好的做法是创建一个style元素。</h3><pre><code>var style = $(&apos;&lt;style&gt;&apos;);
// Try commenting out this line, or change the color:
style.text(&apos;.div{ color:red;}&apos;);
style.prependTo(&apos;body&apos;);
</code></pre><h3 id="3-阻止contextmenu默认事件。（右键菜单）"><a href="#3-阻止contextmenu默认事件。（右键菜单）" class="headerlink" title="3.阻止contextmenu默认事件。（右键菜单）"></a>3.阻止contextmenu默认事件。（右键菜单）</h3><pre><code>$(document).on(&quot;contextmenu&quot;,function(e){
    e.preventDefault();
});
</code></pre><h3 id="4-监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。"><a href="#4-监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。" class="headerlink" title="4.监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。"></a>4.监听不存在的元素上的事件。因为on方法可以传递一个元素的子元素选择器作为参数。</h3><pre><code>var list = $(&apos;#testList&apos;);
// Binding an event on the list, but listening for events on the li items:
list.on(&apos;click&apos;,&apos;li&apos;,function(){
    $(this).remove();
});
// This allows us to create li elements at a later time,
// while keeping the functionality(功能) in the event listener
list.append(&apos;&lt;li&gt;New item (click me!)&lt;/li&gt;&apos;);
</code></pre><h3 id="5-使用trigger模拟触发一个click等事件或其他自定义事件。"><a href="#5-使用trigger模拟触发一个click等事件或其他自定义事件。" class="headerlink" title="5.使用trigger模拟触发一个click等事件或其他自定义事件。"></a>5.使用trigger模拟触发一个click等事件或其他自定义事件。</h3><pre><code>// Just a regular event listener:
press.on(&apos;click&apos;,function(e, how){
    how = how || &apos;&apos;;
    alert(&apos;The buton was clicked &apos; + how + &apos;!&apos;);
});

// Trigger the click event
press.trigger(&apos;click&apos;);

// Trigger it with an argument   也可以自定义事件
press.trigger(&apos;click&apos;,[&apos;fast&apos;]);
</code></pre><h3 id="6-传递参数到e-data执行供执行的函数使用"><a href="#6-传递参数到e-data执行供执行的函数使用" class="headerlink" title="6.传递参数到e.data执行供执行的函数使用"></a>6.传递参数到e.data执行供执行的函数使用</h3><pre><code>//参数只会之心过一次，所以下面的random不管自行几次都是相同的结果
$(document).on(&apos;click&apos;, Math.round(Math.random()*20), function(e){
    // This will print the same number over and over again,
    // as the random number above is generated only once:
    console.log(&apos;Random number: &apos; + e.data,e.target);
});
</code></pre><h3 id="7-Using-event-delegation-事件代理"><a href="#7-Using-event-delegation-事件代理" class="headerlink" title="7.Using event delegation 事件代理"></a>7.Using event delegation 事件代理</h3><pre><code>$(&apos;#holder&apos;).on(&apos;click&apos;, &apos;#clear&apos;, function(){
    clear();
});
</code></pre><h3 id="8-绑定多个事件"><a href="#8-绑定多个事件" class="headerlink" title="8.绑定多个事件"></a>8.绑定多个事件</h3><pre><code>clear.on(&apos;mouseup click&apos;,function(){
    //...
})

clear.on({
    &apos;mousedown&apos;:function(){
       // ...
    },
    &apos;mouseup&apos;:function(){
        // ...
    }
});
</code></pre><h3 id="9-阻止默认事件"><a href="#9-阻止默认事件" class="headerlink" title="9.阻止默认事件"></a>9.阻止默认事件</h3><h5 id="更快地阻止默认事件行为。"><a href="#更快地阻止默认事件行为。" class="headerlink" title="更快地阻止默认事件行为。"></a>更快地阻止默认事件行为。</h5><pre><code>$(&apos;#goToGoogle&apos;).click(false);
</code></pre><h5 id="函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，-链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。"><a href="#函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，-链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。" class="headerlink" title="函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，\链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。"></a>函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，\<a>链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。</a></h5><pre><code>$(&apos;#goToGoogle&apos;).click(function(){
    return false;
});
</code></pre><h3 id="10-平行的运行多个Ajax请求。"><a href="#10-平行的运行多个Ajax请求。" class="headerlink" title="10.平行的运行多个Ajax请求。"></a>10.平行的运行多个Ajax请求。</h3><h5 id="当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。"><a href="#当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。" class="headerlink" title="当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。"></a>当我们需要发送多个Ajax请求是，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。</h5><pre><code>// The trick is in the $.when() function:
$.when($.get(&apos;assets/misc/1.json&apos;), $.get(&apos;assets/misc/2.json&apos;)).then(function(r1, r2){
    log(r1[0].message + &quot; &quot; + r2[0].message);
});
</code></pre><h3 id="11-jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。"><a href="#11-jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。" class="headerlink" title="11.jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。"></a>11.jQuery（使用ajax）提供了一个速记的方法来快速下载内容并添加在一个元素中。</h3><pre><code>&lt;p class=&quot;content&quot;&gt;&lt;/p&gt; &lt;p class=&quot;content&quot;&gt;&lt;/p&gt;
var contentDivs = $(&apos;.content&apos;);
// Fetch the contents of a text file:
contentDivs.eq(0).load(&apos;1.txt&apos;);
// Fetch the contents of a HTML file, and display a specific element:
contentDivs.eq(1).load(&apos;1.html #header&apos;);
</code></pre><h3 id="12-JQuery扩展"><a href="#12-JQuery扩展" class="headerlink" title="12.JQuery扩展"></a>12.JQuery扩展</h3><h5 id="jQuery-prototype-jQuery-fn-jQuery-fn-init-prototype"><a href="#jQuery-prototype-jQuery-fn-jQuery-fn-init-prototype" class="headerlink" title="jQuery.prototype = jQuery.fn = jQuery.fn.init.prototype"></a>jQuery.prototype = jQuery.fn = jQuery.fn.init.prototype</h5><pre><code>$.fn.abs=function(){
    console.log(&apos;abs&apos;)
}
$(document).abs();
</code></pre><h1 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/21/扒一扒jquery的几个技巧/" class="archive-article-date">
  	<time datetime="2017-01-21T08:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-开启一个简单的cdn加速" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/16/开启一个简单的cdn加速/">开启一个简单的CDN加速</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>cdn加速是通过一个服务器集群对网站内容建立缓存和镜像，并且通过对网页静态资源的压缩来加快网站的最终访问速度，但是对于大部分的个人网站或者普通企业网站来说，自己建立cdn加速的服务器集群是一笔较高的费用，而且需要专业的技术。这里说一种最简单的网站cdn加速方法。</p>
</blockquote>
<p><img src="http://a.hiphotos.baidu.com/exp/w=500/sign=c93d5757c15c1038247ecec28210931c/d4628535e5dde711b08214bba0efce1b9d16612e.jpg" alt=""></p>
<p><strong>备注：CDN只是在你的服务器给出数据之后，进行加快传输。举个例子，你的服务器响应是10秒，网络传输占2秒，整体是12秒响应。而CDN可以将你的网络传输2秒加速到1秒，但是你的服务器吐出查询数据还是10秒，整体时间是11秒。</strong></p>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><h4 id="1-登陆百度云加速网站：su-baidu-com-也可以直接百度搜索“百度云加速”找到官网地址。"><a href="#1-登陆百度云加速网站：su-baidu-com-也可以直接百度搜索“百度云加速”找到官网地址。" class="headerlink" title="1.登陆百度云加速网站：su.baidu.com 也可以直接百度搜索“百度云加速”找到官网地址。"></a>1.登陆百度云加速网站：su.baidu.com 也可以直接百度搜索“百度云加速”找到官网地址。</h4><p><img src="http://d.hiphotos.baidu.com/exp/w=500/sign=3f0b53d0ccef76093c0b999f1edca301/9825bc315c6034a86d20efcccc134954082376b8.jpg" alt=""></p>
<h4 id="2-然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。"><a href="#2-然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。" class="headerlink" title="2.然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。"></a>2.然后用自己的百度账号登陆百度云加速，登陆后在你的用户名左侧能看到一个“我的网站”文字链接，点击这个链接。</h4><p><img src="http://g.hiphotos.baidu.com/exp/w=500/sign=a65259542af5e0feee1889016c6134e5/6609c93d70cf3bc7c9709ba1d600baa1cd112a0e.jpg" alt=""></p>
<h4 id="3-进入我的网站管理界面后，点击“添加网站”按钮。"><a href="#3-进入我的网站管理界面后，点击“添加网站”按钮。" class="headerlink" title="3.进入我的网站管理界面后，点击“添加网站”按钮。"></a>3.进入我的网站管理界面后，点击“添加网站”按钮。</h4><p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=4729466292cad1c8d0bbfc274f3f67c4/0824ab18972bd407429d85b07c899e510fb30920.jpg" alt=""></p>
<h4 id="4-在添加网站页面，输入你的网址（不带http-和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”"><a href="#4-在添加网站页面，输入你的网址（不带http-和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”" class="headerlink" title="4.在添加网站页面，输入你的网址（不带http://和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”"></a>4.在添加网站页面，输入你的网址（不带<a href="http://和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”" target="_blank" rel="external">http://和www），然后点击“选择接入方式”的文字链接，建议选择“NS方式”这种方式可以同时免费使用百度提供的dns服务器。最后点击“下一步”</a></h4><p><img src="http://f.hiphotos.baidu.com/exp/w=500/sign=6d4dfc5f750e0cf3a0f74efb3a47f23d/9213b07eca806538f1c8f55e90dda144ad348259.jpg" alt=""></p>
<h4 id="5-如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。"><a href="#5-如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。" class="headerlink" title="5.如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。"></a>5.如果你的网站解析正常，百度云加速会自动检测你的域名解析IP并帮你添加好，我们只需要按照界面上的提示，把域名原本的dns服务器修改成百度云加速提供的dns服务器地址即可。</h4><p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=c6afe4b63edbb6fd255be5263925aba6/cefc1e178a82b901dde5937e748da9773912ef37.jpg" alt=""></p>
<h4 id="6-登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。"><a href="#6-登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。" class="headerlink" title="6.登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。"></a>6.登陆你的域名控制面板，修改域名的DNS设置，不同的域名注册商提供的域名管理面板可能不太一样，但是都有dns设置这一项，如果没有dns设置这一项，你就进入域名的“解析管理”找到ns解析项。</h4><p><img src="http://b.hiphotos.baidu.com/exp/w=500/sign=053f52d559df8db1bc2e7c643922dddb/d000baa1cd11728b1e4fdf6fcffcc3cec3fd2c18.jpg" alt=""></p>
<h4 id="7-把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。"><a href="#7-把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。" class="headerlink" title="7.把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。"></a>7.把dns解析的值替换成百度云加速提供的dns服务器地址即可。修改成功后，要等待2-24小时才能全面生效。</h4><p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=827831339558d109c4e3a9b2e159ccd0/c2cec3fdfc03924589a4b3428094a4c27d1e256d.jpg" alt=""></p>
<h4 id="8-等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。"><a href="#8-等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。" class="headerlink" title="8.等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。"></a>8.等待dns设置生效后，你的网站就会出现在“我的网站”列表中，并且右侧图标编程绿色的对勾。</h4><p><img src="http://g.hiphotos.baidu.com/exp/w=500/sign=29a31cb60d46f21fc9345e53c6256b31/0dd7912397dda144535d3effb5b7d0a20cf48623.jpg" alt=""></p>
<h4 id="9-生效后，我们就可以点击“配置选项”来配置网站的CDN加速-和-网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！"><a href="#9-生效后，我们就可以点击“配置选项”来配置网站的CDN加速-和-网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！" class="headerlink" title="9.生效后，我们就可以点击“配置选项”来配置网站的CDN加速 和 网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！"></a>9.生效后，我们就可以点击“配置选项”来配置网站的CDN加速 和 网站安全防护了，让你的网站打开速度更快，网站更安全，赶紧去体验吧！</h4><p><img src="http://e.hiphotos.baidu.com/exp/w=500/sign=b7de0a5f484a20a4311e3cc7a0539847/342ac65c103853430f3ad56c9413b07ecb808882.jpg" alt=""></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>网站域名备案后才能使用百度云加速的国内CDN加速节点。</li>
<li>在dns修改并等待生效的时间内，不会影响网站的正常访问。</li>
</ul>
<h5 id="转自百度经验"><a href="#转自百度经验" class="headerlink" title="转自百度经验"></a>转自<a href="http://jingyan.baidu.com/article/fedf0737ac414f35ac897704.html" target="_blank" rel="external">百度经验</a></h5>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/16/开启一个简单的cdn加速/" class="archive-article-date">
  	<time datetime="2017-01-16T14:11:14.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CDN加速/">CDN加速</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-jQuery对象之deferred" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/08/jQuery对象之deferred/">jQuery对象之deferred</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>什么是deferred对象？简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。从而优雅的编写回调函数.</p>
</blockquote>
<h2 id="1-ajax操作写法"><a href="#1-ajax操作写法" class="headerlink" title="1,ajax操作写法"></a>1,ajax操作写法</h2><h3 id="非链式"><a href="#非链式" class="headerlink" title="非链式"></a>非链式</h3><pre><code>$.ajax({
   type:&apos;get&apos;
   url: &quot;test.html&quot;,
   success: function(){
          alert(&quot;哈哈，成功了！&quot;);
      },
      error:function(){
          alert(&quot;出错啦！&quot;);
      }
});
</code></pre><h3 id="链式"><a href="#链式" class="headerlink" title="链式"></a>链式</h3><p>高于1.5.0版本的jq，<code>ajax()返回的是deferred对象</code>，可以直接进行链式操作。</p>
<pre><code>$.ajax(&quot;test.html&quot;)
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><p>可以看到，<code>done()</code>相当于<code>success</code>方法，<code>fail()</code>相当于<code>error</code>方法。采用链式写法以后，代码的可读性大大提高。</p>
<p>如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？直接在结尾追加就好了，回调函数可以添加任意多个，它们按照添加顺序执行。像酱紫：</p>
<pre><code>$.ajax(&quot;test.html&quot;)
.done(function(){ alert(&quot;哈哈，成功了！&quot;);} )
.fail(function(){ alert(&quot;出错啦！&quot;); } )
.done(function(){ alert(&quot;第二个回调函数！&quot;);} );
.done(function(){ alert(&quot;第三个回调函数！&quot;);} );
</code></pre><h2 id="2-为多个操作指定回调函数"><a href="#2-为多个操作指定回调函数" class="headerlink" title="2,为多个操作指定回调函数"></a>2,为多个操作指定回调函数</h2><pre><code>$.when($.ajax(&quot;test1.html&quot;), $.ajax(&quot;test2.html&quot;))
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><p>这段代码的意思是，先执行两个操作<code>$.ajax(&quot;test1.html&quot;)</code>和<code>$.ajax(&quot;test2.html&quot;)</code>，如果都成功了，就运行<code>done()</code>指定的回调函数；如果有一个失败或都失败了，就执行<code>fail()</code>指定的回调函数。</p>
<h2 id="3-回调函数接口实现"><a href="#3-回调函数接口实现" class="headerlink" title="3,回调函数接口实现"></a>3,回调函数接口实现</h2><p>deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。</p>
<p>假定有一个很耗时的操作wait：</p>
<pre><code>function wait(){
    var tasks = function(){
        alert(&quot;执行完毕！&quot;);
    };
    setTimeout(tasks,5000);
};

为它指定回调函数: 错误❌的写法如下

$.when(wait())
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><p>上述写法，done()方法会立即执行，起不到回调函数的作用。原因在于<code>$.when()的参数只能是deferred对象</code>，所以必须对wait()进行改写：<br>​<br>    var dtd = $.Deferred(); // 新建一个deferred对象<br>    var wait = function(){<br>        var tasks = function(){<br>            alert(“执行完毕！”);<br>            dtd.resolve(); // 改变deferred对象的执行状态为已完成<br>        };<br>        setTimeout(tasks,5000);<br>        return dtd.promise();<br>    };<br>现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。<br>​<br>    $.when(wait())<br>    .done(function(){ alert(“哈哈，成功了！”); })<br>    .fail(function(){ alert(“出错啦！”); });</p>
<blockquote>
<p>jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待.<br>deferred.reject()方法，作用是将dtd对象的执行状态从”未完成”改为”已失败”，从而触发fail()方法。<br>jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被外界改变造成干扰。</p>
</blockquote>
<p><code>**********************************</code></p>
<h2 id="上面说些原理，下面是2种经常使用的回调接口方法"><a href="#上面说些原理，下面是2种经常使用的回调接口方法" class="headerlink" title="上面说些原理，下面是2种经常使用的回调接口方法"></a>上面说些原理，下面是2种经常使用的回调接口方法</h2><p><code>**********************************</code></p>
<h4 id="1，将deferred对象变成wait-）函数的内部对象。"><a href="#1，将deferred对象变成wait-）函数的内部对象。" class="headerlink" title="1，将deferred对象变成wait(）函数的内部对象。"></a>1，将deferred对象变成wait(）函数的内部对象。</h4><pre><code>function wait(){
    var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象
    var tasks = function(){
        alert(&quot;执行完毕！&quot;);
        dtd.resolve(); // 改变Deferred对象的执行状态
    };
    setTimeout(tasks,5000);
    return dtd.promise(); // 返回promise对象
};
$.when(wait())
.done(function(){ alert(&quot;哈哈，成功了！&quot;); })
.fail(function(){ alert(&quot;出错啦！&quot;); });
</code></pre><h4 id="2，使用deferred对象的建构函数-Deferred"><a href="#2，使用deferred对象的建构函数-Deferred" class="headerlink" title="2，使用deferred对象的建构函数$.Deferred()"></a>2，使用deferred对象的建构函数$.Deferred()</h4><p>jQuery规定，$.Deferred()可以接受一个函数名<code>（注意，是函数名）--当然也是立即执行该函数</code>作为参数，<code>$.Deferred()所生成的deferred对象将作为这个函数的默认参数</code>。<br>​<br>    function wait(dtd){<br>        var tasks = function(){<br>            alert(“执行完毕！”);<br>            dtd.resolve(); // 改变Deferred对象的执行状态<br>        };<br>        setTimeout(tasks,5000);<br>        return dtd.promise(); // 返回promise对象<br>    };<br>    $.Deferred(wait)<br>    .done(function(){ alert(“哈哈，成功了！”); })<br>    .fail(function(){ alert(“出错啦！”); });</p>
<h3 id="小结：deferred对象的方法"><a href="#小结：deferred对象的方法" class="headerlink" title="小结：deferred对象的方法"></a>小结：deferred对象的方法</h3><ol>
<li>$.Deferred() 生成一个deferred对象。    </li>
<li>deferred.done() 指定操作成功时的回调函数</li>
<li>deferred.fail() 指定操作失败时的回调函数</li>
<li>deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。</li>
<li>deferred.resolve() 手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。</li>
<li>deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。</li>
<li>$.when() 为多个操作指定回调函数。<br><br><h4 id="除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。"><a href="#除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。" class="headerlink" title="除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。"></a>除了这些方法以外，deferred对象还有二个重要方法，上面的教程中没有涉及到。</h4></li>
<li><p>deferred.then()有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。<br><br><code>$.when($.ajax( &quot;/main.php&quot; ))</code><br><br><code>.then(successFunc, failureFunc );</code><br><br>如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。</p>
</li>
<li><p>deferred.always()<br>这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。<br><br><code>$.ajax( &quot;test.html&quot; )</code><br></p>
<p><code>.always( function() { alert(&quot;已执行！&quot;);} );</code></p>
</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/08/jQuery对象之deferred/" class="archive-article-date">
  	<time datetime="2017-01-08T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
    <article id="post-微信小程序实战，从入门到弃坑（转）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/03/微信小程序实战，从入门到弃坑（转）/">微信小程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="微信小程序实战，从入门到弃坑（转）"><a href="#微信小程序实战，从入门到弃坑（转）" class="headerlink" title="微信小程序实战，从入门到弃坑（转）"></a>微信小程序实战，从入门到弃坑（转）</h1><p><a href="http://www.jianshu.com/p/4433d46e6235" target="_blank" rel="external">原文链接</a></p>
<p>最近集中开发了两款微信小程序，分别是好奇心日历（每天一条辞典+一个小投票）和好奇心日报（轻量版），直接上图：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-6c7ccf0f8e3019b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>本文将结合具体的实战经验，主要介绍微信小程序的基础知识、开发中遇到的难点、项目的架构设计、最佳实践以及踩过的坑。<strong>文章内容较多，如果想看架构设计和躲坑技巧，请直接浏览后面的正文</strong>，简书没有目录，也挺伤感的。</p>
<p>值得再次声明的是：<strong>微信小程序的内容部分是hybrid模式，并非原生</strong>，所以性能并不好，绑定的tap事件也有明显的延迟。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-ef6d4c647e8b188c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图<em><code>每一个由边框围起来的部分，都是一个最小粒度的原生view</code></em>可以看出，整个微信小程序的内容部分，就是一个原生view。</p>
<h2 id="小程序有哪些基础知识？"><a href="#小程序有哪些基础知识？" class="headerlink" title="小程序有哪些基础知识？"></a>小程序有哪些基础知识？</h2><p>一个完整的微信小程序是由一个App实例和多个Page实例构成，其中App实例表示该小程序应用，多个Page表示该小程序的多个页面。<br>此外，微信小程序并没有提供自定义组件的方式，这就导致微信小程序在开发较复杂应用时，可能会比较艰难。</p>
<p>微信小程序本身很简单，和一个模板语言的难度几乎相当，翻翻官方教程就可以开始动手搞。</p>
<p>我也建议大家先动起来，然后再细致啃啃官方文档。由于微信官方文档仍在不断大幅更新中，所以务必查看最新官方文档。</p>
<p>微信小程序的基础知识主要分为以下几个部分：</p>
<ul>
<li>两种配置文件 &amp;&amp; 两个核心函数</li>
<li>WXML模板语法，页面渲染</li>
<li>页面间的跳转</li>
<li>交互事件</li>
<li>官方组件和官方API</li>
</ul>
<h3 id="两种配置文件-amp-amp-两个核心函数"><a href="#两种配置文件-amp-amp-两个核心函数" class="headerlink" title="两种配置文件 &amp;&amp; 两个核心函数"></a>两种配置文件 &amp;&amp; 两个核心函数</h3><p><code>app.json</code><strong>应用的全局配置文件</strong></p>
<p><code>app.json</code>是针对微信小程序的全局配置，主要包含以下几个配置：</p>
<ul>
<li>pages：页面路径的数组，表示小程序要加载的所有页面，其中数组第一项代表小程序的初始页面。</li>
<li>window：微信原生功能，定制化不强。可设置小程序的状态栏、导航条、标题以及窗口背景色。</li>
<li>tabBar：微信原生功能，定制化不强。适用于常规的Tab应用，Tab栏可置于顶部或底部；tabBar是一个数组，仅支持2-5个tab。</li>
<li>networkTimeout：配置小程序网络请求的超时时间。</li>
<li>debug：调试模式开关，开发模式下建议开启，正式发布别忘了关闭。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1158202-719f23c56cd215ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>page.json</code> <strong>页面的全局配置文件</strong></p>
<p>除了上面提到的全局配置，每个页面还可以单独配置page.json，page.json会覆盖app.json中的配置，并只对当前页面生效。</p>
<p>page.json只能对window配置，有两个比较有用的配置项分别是：</p>
<ul>
<li>enablePullDownRefresh：是否开启下拉刷新</li>
<li>disableScroll：只能在page.json配置，禁止页面上下滚动，猜测可以实现完美滑屏滑动（未验证）</li>
</ul>
<p><code>App()</code> <strong>小程序注册入口，全局唯一</strong></p>
<p>App()用来注册一个小程序，全局只有一个，全局的数据也可以放到这里面来操作。</p>
<pre><code>// 注册微信小程序，全局只有一个
let appConfig = {
    // 小程序生命周期的各个阶段
    onLaunch: function(){},
    onShow: function(){},
    onHide: function(){},
    onError: function(){},

    // 自定义函数或者属性
    ...
};
App(appConfig);

// 在别的地方可以获取这个全局唯一的小程序实例
const app = getApp();
</code></pre><p>小程序并没有提供销毁的方式，所以只有当小程序进入后台一定时间、或者系统资源占用过高的时候，才会被真正的销毁。</p>
<p><code>Page()</code> <strong>页面注册入口</strong></p>
<p>Page()用来注册一个页面，维护该页面的生命周期以及数据。</p>
<pre><code>// 注册微信小程序，全局只有一个
let pageConfig = {
    data: {},
    // 页面生命周期的各个阶段
    onLoad: function(){},
    onShow: function(){},
    onReady: function(){},
    onHide: function(){},
    onUnload: function(){},
    onPullDownRefresh: function(){},
    onReachBottom: function(){},
    onShareAppMessage: function(){},

    // 自定义函数或者属性
    ...
};
Page(pageConfig);

// 获取页面堆栈，表示历史访问过的页面，最后一个元素为当前页面
const page = getCurrentPages();
</code></pre><p>关于各个生命周期的细节以及流程，参考下图，可以细细品味：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-481a42f6d299528e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>app.json</code> 和 <code>page.json</code> 维护了应用和页面的配置属性。<code>App()</code> 和 <code>Page()</code> 维护了应用和页面的各个生命周期以及数据。</p>
<p>那么，<code>APP</code> 和 <code>Page</code> 如何将数据传递到页面呢？页面又是如何渲染呢？</p>
<h3 id="WXML模板语法，页面渲染"><a href="#WXML模板语法，页面渲染" class="headerlink" title="WXML模板语法，页面渲染"></a>WXML模板语法，页面渲染</h3><p>小程序虽然是hybrid模式，但并不使用HTML渲染，而是全部通过自定义标签来渲染页面。这样做的好处我不清楚，但问题却不少：不能跨浏览器、富文本解析困难，iframe视频不支持，没办法外链跳转。<br>和所有的模板语言一样，WXML支持数据绑定、条件渲染、循环、模块化等功能。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>在 WXML 中可以使用<code>双大括号</code>将 <code>Page</code> 的变量或者表达式包裹起来，实现数据绑定，举个例子：</p>
<pre><code>// 将message的值渲染到view中
&lt;view&gt; {{ message }} &lt;/view&gt;

// 将id的值渲染到view的id属性中
&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;

// 根据isSelected的值，输出不同的class
&lt;view class=&quot;{{isSelected ? 'selected' : ''}}&quot;&gt; HelloWorld &lt;/view&gt;

// 结合template，可以传入更复杂的数据
&lt;template is=&quot;objectCombine&quot; data=&quot;{{...article, categoty, tag: '埃隆马斯克'}}&quot;&gt;&lt;/template&gt;
</code></pre><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>循环渲染，适合遍历数据输出多段 WXML，举个例子：</p>
<pre><code>// wx:for 表示需要遍历的数据
// wx:key 使用唯一的字段来标识，有利于提升性能
// wx:for-index 表示数组的下标
// wx:for-item 表示数组的元素
&lt;view wx:for=&quot;{{[{id:1, message: 'HelloWorld1'}, {id:2, message: 	'HelloWorld2'}]}}&quot; 
    wx:key=&quot;id&quot; 
    wx:for-index=&quot;idx&quot; 
    wx:for-item=&quot;item&quot;&gt;
    {{idx}}: {{item.message}}
&lt;/view&gt;
</code></pre><p><code>wx:key</code> 有利于提升重新渲染时的效率，建议添加</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>WXML的模块化，可以让我们复用一些wxml片段，还挺重要的，举个例子：</p>
<pre><code>// 引入wxml模块
&lt;import src=&quot;../../components/grid-article/index&quot;&gt;&lt;/import&gt;

&lt;block wx:for=&quot;{{posts}}&quot; wx:for-item=&quot;post&quot; wx:key=&quot;id&quot;&gt;
    // 调用wxml模块，同时可传入数据
    &lt;template is=&quot;grid-article&quot; data=&quot;{{post}}&quot;&gt;&lt;/template&gt;
&lt;/block&gt;
</code></pre><p>数据和页面的状态是一一对应的，微信小程序中，设计一份好的数据结构，对于Page和页面的代码都有很大的帮助。<br>微信小程序并不支持a标签，那么多个页面之间如何跳转呢？</p>
<h3 id="页面间的跳转"><a href="#页面间的跳转" class="headerlink" title="页面间的跳转"></a>页面间的跳转</h3><p>小程序以栈的形式维护了历史访问的所有页面，并提供了多种页面间的跳转方式；结合前文提到的App()和Page()的各个生命周期，不同的跳转方式和不同的生命周期关联，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-cf7de8f472d6a147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>举个例子，Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）<br><img src="http://upload-images.jianshu.io/upload_images/1158202-80ab7b1ea2766468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>好了，APP和Page负责维护小程序的生命周期和数据，模板负责接受数据完成页面渲染，页面间的跳转负责将多个页面贯穿起来，那么，如何发生交互呢？接下来我们简单说一下事件。</p>
<h3 id="交互事件"><a href="#交互事件" class="headerlink" title="交互事件"></a>交互事件</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><pre><code>// bindtap 和 catchtap的区别在于
// bindtap 不会阻止事件冒泡
// catchtap会冒泡事件冒泡
&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;
&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; catchtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;

// 绑定的函数tapName只是一个函数名称，默认接受一个event对象作为参数
Page({
    tapName: function(event) {
        console.log(event)
        }
    })
</code></pre><p>接下来，另一个问题是：<code>tapName()</code> 如何接受自定义参数呢？</p>
<h4 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h4><p>传递自定义参数主要有两种方式：</p>
<p>第一种：将参数绑定到wxml标签上，然后通过event.target.dataset获取</p>
<p>第二种：直接使用Page.data或其他数据</p>
<p>到目前为止，一个完整的小程序框架已经实现</p>
<ul>
<li>小程序只有逻辑和视图两部分，而且不提供组件化解决方案</li>
<li>逻辑主要包含四个东西：两个配置文件 &amp;&amp; 两个核心函数</li>
<li>视图很简单，模板语法稍微有点不完善</li>
<li>逻辑层的数据绑定到视图层是由小程序框架自动支持，数据变化，视图自动变化</li>
<li>视图层到逻辑层的，主要通过事件的方式来实现</li>
<li>视图之间的跳转，小程序也提供了它自己的方式，并不支持a标签</li>
</ul>
<p>框架有了，小程序还提供了官方组件以便快速开发，提供了API以增强应用能力。</p>
<p>这块就不具体介绍了，也需要注意小程序的官方文档还在大规模的更新中，务必查看最新版</p>
<p>官方组件：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161222" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161222</a></p>
<p>官方API：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222</a></p>
<p>微信小程序的基础知识就是以上的内容，并不复杂，边查边写都可以。</p>
<p>接下来会介绍更进阶一些的内容，内容主要结合好奇心日报这个小程序项目，先看效果：<br><img src="http://upload-images.jianshu.io/upload_images/1158202-50ade533c922cb0d.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h2 id="如何设计微信小程序？"><a href="#如何设计微信小程序？" class="headerlink" title="如何设计微信小程序？"></a>如何设计微信小程序？</h2><h3 id="构建系统-amp-amp-目录结构"><a href="#构建系统-amp-amp-目录结构" class="headerlink" title="构建系统 &amp;&amp; 目录结构"></a>构建系统 &amp;&amp; 目录结构</h3><h4 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h4><p>由于微信小程序本身对工程化几乎没有任何的支持，所以动手搭建一份：<a href="https://github.com/qixiuss/wxapp-redux-starter" target="_blank" rel="external">wxapp-redux-starter</a>。</p>
<p><strong>使用gulp进行编译构建，主要功能包括：</strong></p>
<ul>
<li>集成了<code>Redux</code>，数据管理更方便</li>
<li>开发过程中，使用<code>xml</code>取代<code>wxml</code>，对开发工具更友好</li>
<li>开发过程中，使用<code>less</code>取代<code>wxss</code>，功能更强大</li>
<li>引入<code>es-promise</code>，以便可以创建并使用<code>Promise</code></li>
<li>添加<code>promisify</code>工具函数，可以便捷的将官方<code>Api</code>转换成<code>Pormise</code>模式</li>
<li>引入<code>normalizr</code>，可以将数据扁平化，更方便进行数据管理</li>
<li>引入<code>babel</code>自动进行<code>ES2015</code>特性转换</li>
<li>对<code>wxml/wxss/js/img</code>压缩，相对开发者工具提供的压缩，会减小一丢丢体积。<h4 id="目录结构设计"><a href="#目录结构设计" class="headerlink" title="目录结构设计"></a>目录结构设计</h4>按照pages、components、redux、vendors/libs、images几个核心部分拆分，直接上目录。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-6583ba0c0928481c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>dist目录：构建输出的文件存放到这个目录。</li>
<li>src目录：开发模式的文件，包括app、页面、组件、图片等静态资源、辅助函数库、Redux数据管理器、第三方工具库。</li>
<li>gulpfile.js：不用多说，gulp构建任务的入口文件。</li>
<li>package.json：不用多说，管理者构建任务的依赖。</li>
<li>thirdPlugins：由于小程序并不支持直接使用npm，我们可以自主拉取构建，然后拷贝到vendors里，有时候需要简单修改。</li>
</ul>
<p>构建系统会将src目录下的代码，编译处理后输出到dist目录，小程序开发工具只需要引入dist目录即可。</p>
<p>有了构建工具，代码开发起来更舒心，但很快就遇到另外一个糟心的问题，那就是如何管理散布在各处的数据？<br>要知道，微信小程序并没有提供组件化方案，所以<strong>把组件写成无状态组件</strong>特别适合，但是页面管理太多数据很凌乱，有什么办法可以将数据集中管理呢？</p>
<h3 id="引入Redux进行数据集中管理"><a href="#引入Redux进行数据集中管理" class="headerlink" title="引入Redux进行数据集中管理"></a>引入Redux进行数据集中管理</h3><p>关于Redux相关的内容，之前有三篇博客详细介绍，有兴趣的建议先移步：</p>
<ul>
<li>Redux整体介绍：<a href="http://www.jianshu.com/p/d296a8c34936" target="_blank" rel="external">Redux 入门教程，应用的状态管理器</a></li>
<li>对State进行横向和纵向拆分设计：<a href="http://www.jianshu.com/p/ba8654cb77b6" target="_blank" rel="external">State设计，Redux 开发第一步</a></li>
<li>Reducer的最佳实践：<a href="http://www.jianshu.com/p/938f8121ba0f" target="_blank" rel="external">Reducer 最佳实践，Redux 开发最重要的部分</a></li>
</ul>
<p>这儿就简单介绍一下，如何在微信小程序中引入Redux 以及 如何将微信小程序和Redux连接起来。</p>
<h4 id="引入Redux"><a href="#引入Redux" class="headerlink" title="引入Redux"></a>引入Redux</h4><p>直接在 <code>thirdPlugins</code>目录 运行 <code>yarn add redux / npm install redux</code>，等<code>redux</code>安装好了之后，将 <code>dist</code>目录 的 <code>redux.js/redux.min.js</code> 拷贝到<code>vendors</code>目录中。<br>需要进行简单的修改才能使用，将压缩版208行代码 <code>(i)</code> 改成 <code>(i || {})</code>即可。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-143fad06f8c52bca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="连接微信小程序和Redux"><a href="#连接微信小程序和Redux" class="headerlink" title="连接微信小程序和Redux"></a>连接微信小程序和Redux</h4><p>将Redux和微信小程序连接起来才会真的有用处。找了个现成的方案<a href="https://github.com/charleyw/wechat-weapp-redux" target="_blank" rel="external">charleyw/wechat-weapp-redux</a>，可以直接使用。</p>
<p>一个完整的Redux方案如下，包括：将Store注入到App中、将state的数据和reducer的方法映射到Page中。一旦state发生变化，Page.data也会更新，进而触发页面的重新渲染。</p>
<pre><code>// APP的逻辑
import { createStore, applyMiddleware, combineReducers } from &apos;./vendors/redux.js&apos;;
import thunk from &apos;./vendors/redux-thunk.js&apos;;
import { Provider } from &apos;./vendors/weapp-redux.js&apos;;

// import reducers
import { rootReducer } from &apos;./redux/reducer.js&apos;;

// 从Storage读取数据
let entities = wx.getStorageSync(&apos;entities&apos;) || {};

const store = createStore(
    rootReducer, {
        // 将读取的数据注入到store中
        entities: entities
    },
    applyMiddleware(
        thunk
    )
);

let appConfig = {
    onLaunch: function() {},

    onHide: function() {
        let state = store.getState(),
            cacheEntities = {};

        // 体积大于2M，直接清空，防止缓存占用过大体积
        if (sizeof(state.entities) &lt;= 2 * 1024 * 1024) {
            cacheEntities = state.entities;
        }

        // 退出时将entities缓存下来
        wx.setStorageSync(&apos;entities&apos;, cacheEntities);
    }
};

App(Provider(store)(appConfig));
// Page的逻辑
import { connect } from &apos;../../vendors/weapp-redux.js&apos;;

import { fetchArticleDetail } from &apos;../../redux/models/articles.js&apos;;

let pageConfig = {
    data: {
        id: 0,
        postsHash: {}
    },
    onLoad: function(params) {
        var me = this,
            { id, postsHash } = me.data;

        me.fetchArticleDetail(id, function() {}, function() {});
    }
}

// 考虑到列表页已经获取到部分数据
// 为了在详情页第一时间利用这些数据，我们将params传入
// 防止以后需要用data的数据，我们将data也一并传入
let mapStateToData = (state, params, data) =&gt; {
    return {
        id: params.id,
        postsHash: state.entities.posts
    }
};

let mapDispatchToPage = dispatch =&gt; ({
    fetchArticleDetail: (id, callback, errorCallback) =&gt; dispatch(fetchArticleDetail(id, callback, errorCallback)),
});

pageConfig = connect(mapStateToData, mapDispatchToPage)(pageConfig)
Page(pageConfig);
</code></pre><p>需要注意的是，为了保证第一时间能拿到数据，我们对<code>wechat-weapp-redux/src/connect.js</code>做了优化调整，修改的地方如下</p>
<pre><code>// 修改了以下两个函数
// 可以对照原项目修改，也可以直接拿我的模板项目使用
function handleChange(options) {
    if (!this.unsubscribe) {
        return
    }

    const state = this.store.getState();
    // 将data也一并传入
    const mappedState = mapState(state, options, this.data);
    if (!this.data || shallowEqual(this.data, mappedState)) {
        return;
    }
    this.setData(mappedState)
}

function onLoad(options) {
    this.store = app.store;
    if (!this.store) {
        warning(&quot;Store对象不存在!&quot;)
    }
    if (shouldSubscribe) {
        this.unsubscribe = this.store.subscribe(handleChange.bind(this, options))
        // 第一次处理的时候也传入options
        handleChange.apply(this, [options])
    }
    if (typeof _onLoad === &apos;function&apos;) {
        _onLoad.call(this, options)
    }
}
</code></pre><h4 id="引入Redux的优势"><a href="#引入Redux的优势" class="headerlink" title="引入Redux的优势"></a>引入Redux的优势</h4><p>引入Redux的好处在于可以集中管理数据，并且让Page的代码保持绝对简单，让所有的组件都变成简单可复用的无状态组件。<br>此外，Redux还让离线缓存更方便，数据复用更简单。</p>
<p>引入Redux解决了数据散布各处的问题，参考Redux的管理思路，我们构思了一套简单组件化解决方案：假设我们把所有的组件都设计成无状态组件，而组件的数据来源是Page.data，那么我们是否也可以将组件数据的管理抽离到一个单独的文件中呢？接下来讲讲我们使用的简单的组件化解决方案。</p>
<h4 id="简单的组件化解决方案"><a href="#简单的组件化解决方案" class="headerlink" title="简单的组件化解决方案"></a>简单的组件化解决方案</h4><p>这份组件化解决方案的核心就在于把组件的关联数据集中起来管理，只暴露出默认数据和数据的操作函数。</p>
<p>比如好奇心日报的详情页有个Toolbar，该Toolbar并不复杂，主要提供返回和点赞功能，其中点赞功能只对文章详情有效，研究所详情页会将点赞功能隐藏。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-2d1dc48a1ecaf25b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>// components/toolbar/index.js 文件
// 仅提供默认值，不需要和page中的数据保持同步
let defaultData = {
    isPraised: false,
    praiseCount: 0,
    showPraiseIcon: false,
};
// 切换点赞状态
function togglePraise() {
    // 本质上是修改Page.data中的toolbarData
}
// 返回上一级
function navigateToBack(wx) {
    wx.navigateBack({ delta: 1 });
}
module.exports = {
    defaultData,

    togglePraise,
    navigateToBack
}

// pages/articles/show.js 文件
import Toolbar from &apos;../../components/toolbar/index.js&apos;;

let pageConfig = {
    data: {
        // 其他数据
        id: 0,
        // Toolbar数据，单独的一份数据，便于维护
        toolbarData: Toolbar.defaultData
    },
    // 点赞或者取消赞
    togglePraise: function() {
        let me = this;

        Toolbar.togglePraise.call(me);
    }
}

// 这儿的组件化并不是真正的组件化
// 而是将组件相关的逻辑和函数抽离到单独的文件中，保证Page代码清晰。
// 同时也为这部分组件逻辑复用提供了可能。
// 本质上来说，抽离出的组件都是“操作Page.data的工具函数”，他们也是纯函数，和“操作state的reducer”类似。
</code></pre><p>这种Redux的组件化解决方案既简单又好用，保持一定的代码规范即可。这样设计当然是为了复用，同时也让Page的逻辑保持极度精简。</p>
<h2 id="开发中遇到了哪些难点-amp-amp-微信小程序有多少坑？"><a href="#开发中遇到了哪些难点-amp-amp-微信小程序有多少坑？" class="headerlink" title="开发中遇到了哪些难点 &amp;&amp; 微信小程序有多少坑？"></a>开发中遇到了哪些难点 &amp;&amp; 微信小程序有多少坑？</h2><p>微信小程序目前的确算不上公测的版本，开发者工具不完善、真机表现和开发环境差异很大、部分组件性能较差、部分功能有缺陷，只有经历了这些大坑，才会真的知道你有多“爱”微信小程序。这儿总结了开发中的难点以及微信小程序中遇到的比较明显的坑。</p>
<h3 id="富文本解析"><a href="#富文本解析" class="headerlink" title="富文本解析"></a>富文本解析</h3><p>微信小程序并不支持HTML标签，所以对于富文本解析来说，难度较大，而且有些功能还没有办法实现，比如：iframe视频、连接跳转等<br>这块功能建议由后台统一转换，如果非得前端转换，建议参考下面的思路。</p>
<p>非常感谢 <a href="https://github.com/icindy/wxParse" target="_blank" rel="external">wxParse</a> 这款组件，替我省了不少时间。推荐大家使用，期间遇到一些问题，也分享给大家。</p>
<ul>
<li>wxParse 默认层级只支持10层html嵌套，如果想要支持更深的层级，在wxParse.xml复制几份template即可。</li>
<li>wxParse 提供了图片加载成功的回调<code>wxParseImgLoad</code>，很好用。但如果富文本中的图片已经预设宽高比，那么可以不用依赖该回调，在html2jons.js中根据屏幕宽度直接计算出图片高度，先占位，可以避免页面频繁抖动的问题。</li>
<li>如果你的富文本中有自定义模块，对wxParse.xml中的template进行改造即可。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-52ce324bcc9879bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="数据扁平化"><a href="#数据扁平化" class="headerlink" title="数据扁平化"></a>数据扁平化</h3>具体如何扁平化，请移步上一篇博客 <a href="http://www.jianshu.com/p/ba8654cb77b6" target="_blank" rel="external">State设计，Redux 开发第一步</a>。<br>这儿只简单介绍下扁平化应用场景：<br>好奇心日报的研究所是三级表结构：<code>papers &gt; questions &gt; options</code>，后台返回的数据是三级嵌套数据，如果想要修改option.selected字段，需要三级嵌套循环！如果想要获取所有选中的option，需要三级嵌套循环！<h3 id="页面展现速度优化"><a href="#页面展现速度优化" class="headerlink" title="页面展现速度优化"></a>页面展现速度优化</h3>数据复用，比如复用列表页的数据，可以让详情页的标题等字段第一时间呈现出来。<br>离线缓存，同样可以让列表页和详情页第一时间呈现出来，甚至有可能减少请求数量。</li>
</ul>
<p>无论是数据复用还是离线缓存，配合数据扁平化，都非常好用。</p>
<h3 id="小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）"><a href="#小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）" class="headerlink" title="小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）"></a>小程序默认设置代理，会和Shadowsocks等VPN冲突（最新版已修复）</h3><p>解决方法很简单，设置微信小程序不使用代理；或者临时关闭VPN即可。<br>最新版开发者工具已经解决该问题。</p>
<h3 id="最新版微信小程序移除了对Promise的支持。"><a href="#最新版微信小程序移除了对Promise的支持。" class="headerlink" title="最新版微信小程序移除了对Promise的支持。"></a>最新版微信小程序移除了对Promise的支持。</h3><p>开发者自行引入兼容库即可，推荐<a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="external">es6-promise</a>。使用的时候，直接引入Promise即可。</p>
<pre><code>// 引入Promise
import Promise from &apos;../vendors/es6-promise.js&apos;;

// 用Promise封装wx.request网络请求
function request(method = &apos;GET&apos;) {
    return function(url, data = {}) {
        return new Promise(function(resolve, reject) {
            wx.request({
                url,
                data,
                method,
                header: {
                    &apos;Content-Type&apos;: &apos;application/json&apos;
                },
                success: function(res) {
                    let { statusCode, errMsg, data } = res;

                    if (statusCode == 200 &amp;&amp; data.meta &amp;&amp; data.meta.status == 200) {
                        resolve(data.response);
                    } else {
                        reject(&apos;网路请求错误，请稍后再试~&apos;);
                    }
                },
                fail: function(err) {
                    reject(&apos;网路请求不符合规范，请检查域名是否符合要求~&apos;);
                }
            });
        })
    }
}
export const GET = request(&apos;GET&apos;);
export const POST = request(&apos;POST&apos;);
export const PUT = request(&apos;PUT&apos;);
export const DELETE = request(&apos;DELETE&apos;);

// 用Promise封装小程序的其他API
export const promisify = (api) =&gt; {
    return (options, ...params) =&gt; {
        return new Promise((resolve, reject) =&gt; {
            api(Object.assign({}, options, { success: resolve, fail: reject }), ...params);
        });
    }
}
// 使用
const getLocation = promisify(wx.getLocation);
</code></pre><p>不清楚微信为何会临时移除Promise，统一内置不也挺好？</p>
<h3 id="小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。"><a href="#小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。" class="headerlink" title="小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。"></a>小程序不能实现完美的fullpage效果，会出现上下拉扯的感觉（最新版预计已修复，待实际验证）。</h3><p>小程序一旦滚动顶部或者底部，继续滑动的时候，就会出现拉扯现象。而这个拉扯现象还无法禁止。<br>最新版可以对页面配置disableScroll，预计可以修复这个问题，待实际验证。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-691d39e8e75dc7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）"><a href="#swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）" class="headerlink" title="swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）"></a>swiper组件不支持轮播，性能差，文档模糊（部分最新版已修复）</h4><ul>
<li>swiper组件之前并不支持轮播，最新版已修复</li>
<li>swiper组件之前是通过设置left属性来实现动画，在小米5、华为V8等高端等安卓机上能够感受到明显的卡顿，当然原因是X5内核引起的。最新版已修复，换成了transform，性能有一定的提升。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-942330479da5c884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><p>文档并未标记可以垂直轮播，但其实是可以的。</p>
<pre><code>// 简单设置vertical即可，但由于官方文档并未备注，尽量不要使用。可以自己开发一个swiper组件。
&lt;swiper vertical=&quot;true&quot;&gt;&lt;/swiper&gt;
</code></pre></li>
<li>swiper组件的小圆点其实是可以定制化的，但是官方文档并未说明，而且开发者工具也看不出来，只有鼠标hover到元素上的时候可以看到相关的class，简单猜测一下，最后分析出来它的实现方式。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1158202-70f78f4950ce9817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>// 圆点的父元素，用来控制圆点间的间距
.wx-swiper-dot {
    width: 30rpx;
    // 圆点，可以通过font-size修改圆点的大小，color修改圆点的颜色
    &amp;:before {
        width: 100%;
        display: inline-block;
        font-size: 56rpx;
        content: &apos;圆点编码&apos;;
    }
    // active状态的圆点
    &amp;.wx-swiper-dot-active {
        &amp;:before {
            color: #ffc81f;
        }
    }
}
</code></pre><h3 id="小程序WXSS的font-face的url不接受路径作为参数"><a href="#小程序WXSS的font-face的url不接受路径作为参数" class="headerlink" title="小程序WXSS的font-face的url不接受路径作为参数"></a>小程序WXSS的font-face的url不接受路径作为参数</h3><p>可以将字体文件转换为base64，然后引用。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-4d8cf6721984b58c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>同样，如果想要使用iconfont，也可以使用类似的方案，将iconfont字体文件base64之后再引入。</p>
<h4 id="小程序的margin表现有问题（最新版已经修复）"><a href="#小程序的margin表现有问题（最新版已经修复）" class="headerlink" title="小程序的margin表现有问题（最新版已经修复）"></a>小程序的margin表现有问题（最新版已经修复）</h4><p>之前发生margin折叠的时候，会取小的那个值。会导致底部留白等设置失效。</p>
<h4 id="canvas问题"><a href="#canvas问题" class="headerlink" title="canvas问题"></a>canvas问题</h4><p>canvas并没有深入研究，目前的发现的问题主要是两个，如下图标记：</p>
<ul>
<li>层级问题，canvas总是会盖在其他元素上面。</li>
<li>支持度不好，在小米5、iPhone5s画图会出现畸形。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-aaea239242906e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>最后通过CSS3的方式绘制饼图</p>
<pre><code>&lt;template name=&quot;pie&quot;&gt;
    &lt;view class=&quot;com-pie&quot;&gt;
        &lt;!-- 小于50% --&gt;
        &lt;view class=&quot;percent-1&quot; style=&quot;transform: rotate(0.4turn);&quot;&gt;&lt;/view&gt;
        &lt;view class=&quot;percent-2&quot;&gt;&lt;/view&gt;
        &lt;!-- 大于50% --&gt;
        &lt;view class=&quot;percent-1&quot; style=&quot;transform: rotate(0.5turn);&quot;&gt;&lt;/view&gt;
        &lt;view class=&quot;percent-2&quot; style=&quot;opacity:1; transform: rotate(0.3turn);&quot;&gt;&lt;/view&gt;
    &lt;/view&gt;
&lt;/template&gt;

.com-pie {
    position: relative;
    z-index: 0;
    display: inline-block;
    width: 100rpx;
    height: 100rpx;
    line-height: 100rpx;
    border-radius: 50%;
    color: #000;
    background-color: #ebebeb;
    background-image: linear-gradient(to right, transparent 50%, #cccccc 0);
    overflow: hidden;
    .percent-1,
    .percent-2 {
        position: absolute;
        top: 0;
        width: 60%;
        height: 100%;
        left: 50%;
        transform-origin: center left;
    }
    .percent-1 {
        background-color: inherit;
        z-index: -2;
    }
    .percent-2 {
        height: 110%;
        opacity: 0;
        z-index: -1;
        background-color: #cccccc;
    }
    &amp;.selected {
        background-color: #ffe9a5;
        background-image: linear-gradient(to right, transparent 50%, #ffc81f 0);
        .percent-2 {
            background-color: #ffc81f;
        }
    }
}
</code></pre><h3 id="微信小程序的rpx会出现精度问题"><a href="#微信小程序的rpx会出现精度问题" class="headerlink" title="微信小程序的rpx会出现精度问题"></a>微信小程序的rpx会出现精度问题</h3><p>设置margin-left/margin-right负值，可能导致页面能够左右晃动。猜测 是rpx导致的精度问题。<br>rpx本质上会转换为px，在不同宽度的设备上，实际的rpx值会转换为带小数的px值，四舍五入可能出现问题，之前使用rem布局的时候在QQ浏览器遇到过类似的问题。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-83e69b31a569928f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="wx-request表现不合理，并且携带特殊字符会报错"><a href="#wx-request表现不合理，并且携带特殊字符会报错" class="headerlink" title="wx.request表现不合理，并且携带特殊字符会报错"></a>wx.request表现不合理，并且携带特殊字符会报错</h4><ul>
<li>请求返回404错误，也会触发success回调。<br>不要想当然的认为会触发fail回调，判断一个请求成功或失败，请使用wx.request返回的状态来判断。只有不符合规范的请求，才会触发fail。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-ebad0e91ac279124.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></li>
<li>请求的数据中，如果有特殊字符（比如\u2820），会报错。<br>只会在真机上出现，开发者工具没毛病。估计会有更多的特殊字符会导致这个问题。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-9110f7d78b3fb4aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="开发者工具，切换页面的时候，有时候wxml不会同步切换"><a href="#开发者工具，切换页面的时候，有时候wxml不会同步切换" class="headerlink" title="开发者工具，切换页面的时候，有时候wxml不会同步切换"></a>开发者工具，切换页面的时候，有时候wxml不会同步切换</h3>希望微信什么时候能解决一下。<h3 id="微信小程序给wxml模板赋值的时候，解构放到前面可能会报错"><a href="#微信小程序给wxml模板赋值的时候，解构放到前面可能会报错" class="headerlink" title="微信小程序给wxml模板赋值的时候，解构放到前面可能会报错"></a>微信小程序给wxml模板赋值的时候，解构放到前面可能会报错</h3>最新版会遇到这个问题，老版本虽然不会报错，但是在部分真机上会出现问题。<br>原因未知，遇到这个问题的朋友可以考虑绕过去。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-e379fd7fca1b99cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h3 id="微信小程序的scroll-view暴露的bindscroll函数并不能实时监听"><a href="#微信小程序的scroll-view暴露的bindscroll函数并不能实时监听" class="headerlink" title="微信小程序的scroll-view暴露的bindscroll函数并不能实时监听"></a>微信小程序的scroll-view暴露的bindscroll函数并不能实时监听</h3>依赖实时获取滚动位置的功能不能实现。比如滚动时toolbar的动态隐藏和显示。<h3 id="最新版开发工具不能关掉自动刷新"><a href="#最新版开发工具不能关掉自动刷新" class="headerlink" title="最新版开发工具不能关掉自动刷新"></a>最新版开发工具不能关掉自动刷新</h3>微信小程序的会默认监听文件变化，然后自动刷新。<br>但不足的是每次都是全量刷新，而不是模块的热替换，反而会影响开发速度，尤其对于喜欢频繁Command + S的开发者，你会发现你的小程序在不断的刷新。建议关闭。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-1418bc0e4b307f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但最新版开发者工具，不勾选也会自动刷新。</li>
</ul>
<h3 id="微信小程序不支持requestAnimationFrame"><a href="#微信小程序不支持requestAnimationFrame" class="headerlink" title="微信小程序不支持requestAnimationFrame"></a>微信小程序不支持<code>requestAnimationFrame</code></h3><p>微信小程序不支持<code>requestAnimationFrame</code>，所以部分性能优化做不了。不支持的原因未知。</p>
<h3 id="Page-onload函数可以接受参数"><a href="#Page-onload函数可以接受参数" class="headerlink" title="Page.onload函数可以接受参数"></a>Page.onload函数可以接受参数</h3><p>该参数是有URL决定的，也就是URL携带的参数。<br>官方文档这块写的有点混淆，特意拿出来说一下。举个例子：url中传递的时候<code>id=1</code>，那么<code>option.id=1</code>，而不是什么<code>option.query</code>。<br><img src="http://upload-images.jianshu.io/upload_images/1158202-8135e6e4e97b2ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="真机上有概率卡死，目前不确定是代码问题还是小程序的问题。"><a href="#真机上有概率卡死，目前不确定是代码问题还是小程序的问题。" class="headerlink" title="真机上有概率卡死，目前不确定是代码问题还是小程序的问题。"></a>真机上有概率卡死，目前不确定是代码问题还是小程序的问题。</h3><p>有遇到类似问题的朋友欢迎指出。</p>
<h4 id="总结说点啥？"><a href="#总结说点啥？" class="headerlink" title="总结说点啥？"></a>总结说点啥？</h4><p>本文主要围绕微信小程序的基础知识、如何设计微信小程序、开发过程中遇到的问题三个方面介绍。<br>微信小程序的基础知识主要包括：</p>
<ul>
<li>两种配置文件 &amp;&amp; 两个核心函数</li>
<li>WXML模板语法，页面渲染</li>
<li>页面间的跳转</li>
<li>交互事件</li>
<li>官方组件和官方API</li>
</ul>
<p>如何设计微信小程序的内容主要包括：</p>
<ul>
<li>构建系统 &amp;&amp; 目录结构</li>
<li>引入Redux进行数据集中管理</li>
<li>简单的组件化解决方案</li>
</ul>
<p>最后还介绍开发过程中遇到的难点 以及 微信小程序的大小坑。</p>
<p>微信小程序本身并不复杂，开发过程却比较艰辛，尤其是第一次在真机上运行的时候，觉得这个世界恶意满满。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/03/微信小程序实战，从入门到弃坑（转）/" class="archive-article-date">
  	<time datetime="2017-01-03T02:59:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微信小程序/">微信小程序</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>













  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Jasonellen
    	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>

  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/CDN加速/" style="font-size: 10px;">CDN加速</a> <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/ES6/" style="font-size: 13.33px;">ES6</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IScroll/" style="font-size: 10px;">IScroll</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JS试题/" style="font-size: 10px;">JS试题</a> <a href="/tags/MYSQL/" style="font-size: 13.33px;">MYSQL</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/ReactNative/" style="font-size: 13.33px;">ReactNative</a> <a href="/tags/SVG/" style="font-size: 10px;">SVG</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a> <a href="/tags/ZnPicker/" style="font-size: 10px;">ZnPicker</a> <a href="/tags/canvas/" style="font-size: 16.67px;">canvas</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/filter/" style="font-size: 10px;">filter</a> <a href="/tags/import/" style="font-size: 10px;">import</a> <a href="/tags/jQuery/" style="font-size: 13.33px;">jQuery</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/mobiscroll/" style="font-size: 10px;">mobiscroll</a> <a href="/tags/package/" style="font-size: 10px;">package</a> <a href="/tags/php/" style="font-size: 16.67px;">php</a> <a href="/tags/react/" style="font-size: 16.67px;">react</a> <a href="/tags/regexp/" style="font-size: 13.33px;">regexp</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/upload/" style="font-size: 10px;">upload</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/异步函数/" style="font-size: 10px;">异步函数</a> <a href="/tags/弹球/" style="font-size: 10px;">弹球</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/移动端/" style="font-size: 13.33px;">移动端</a> <a href="/tags/简版日历/" style="font-size: 10px;">简版日历</a> <a href="/tags/运算符/" style="font-size: 10px;">运算符</a> <a href="/tags/配置文件/" style="font-size: 10px;">配置文件</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cn.bing.com/">必应</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://gold.xitu.io/">掘金</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="//vuefe.cn/guide/">Vue</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com/">百度</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://yaomengyyu.github.io/">家浩</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://wangyalijas.github.io/">王雅丽</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;我只是想学记录点东西&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>


    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>
</div>
  </div>
</body>
</html>